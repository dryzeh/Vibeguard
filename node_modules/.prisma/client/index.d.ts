
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Nightclub
 * 
 */
export type Nightclub = $Result.DefaultSelection<Prisma.$NightclubPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model FloorPlan
 * 
 */
export type FloorPlan = $Result.DefaultSelection<Prisma.$FloorPlanPayload>
/**
 * Model Zone
 * 
 */
export type Zone = $Result.DefaultSelection<Prisma.$ZonePayload>
/**
 * Model Bracelet
 * 
 */
export type Bracelet = $Result.DefaultSelection<Prisma.$BraceletPayload>
/**
 * Model Alert
 * 
 */
export type Alert = $Result.DefaultSelection<Prisma.$AlertPayload>
/**
 * Model Emergency
 * 
 */
export type Emergency = $Result.DefaultSelection<Prisma.$EmergencyPayload>
/**
 * Model Sensor
 * 
 */
export type Sensor = $Result.DefaultSelection<Prisma.$SensorPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model AnalyticsReport
 * 
 */
export type AnalyticsReport = $Result.DefaultSelection<Prisma.$AnalyticsReportPayload>
/**
 * Model AIModel
 * 
 */
export type AIModel = $Result.DefaultSelection<Prisma.$AIModelPayload>
/**
 * Model Prediction
 * 
 */
export type Prediction = $Result.DefaultSelection<Prisma.$PredictionPayload>
/**
 * Model Anomaly
 * 
 */
export type Anomaly = $Result.DefaultSelection<Prisma.$AnomalyPayload>
/**
 * Model BehaviorAnalysis
 * 
 */
export type BehaviorAnalysis = $Result.DefaultSelection<Prisma.$BehaviorAnalysisPayload>
/**
 * Model RealTimeMetric
 * 
 */
export type RealTimeMetric = $Result.DefaultSelection<Prisma.$RealTimeMetricPayload>
/**
 * Model DataStream
 * 
 */
export type DataStream = $Result.DefaultSelection<Prisma.$DataStreamPayload>
/**
 * Model CacheEntry
 * 
 */
export type CacheEntry = $Result.DefaultSelection<Prisma.$CacheEntryPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  ADMIN: 'ADMIN',
  MANAGER: 'MANAGER',
  SECURITY: 'SECURITY',
  STAFF: 'STAFF'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const UserStatus: {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
  SUSPENDED: 'SUSPENDED'
};

export type UserStatus = (typeof UserStatus)[keyof typeof UserStatus]


export const BraceletStatus: {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
  MAINTENANCE: 'MAINTENANCE',
  LOST: 'LOST'
};

export type BraceletStatus = (typeof BraceletStatus)[keyof typeof BraceletStatus]


export const AlertType: {
  DISTRESS: 'DISTRESS',
  BATTERY_LOW: 'BATTERY_LOW',
  ZONE_CAPACITY: 'ZONE_CAPACITY',
  SUSPICIOUS_ACTIVITY: 'SUSPICIOUS_ACTIVITY',
  MEDICAL: 'MEDICAL',
  FIRE: 'FIRE',
  OTHER: 'OTHER'
};

export type AlertType = (typeof AlertType)[keyof typeof AlertType]


export const AlertStatus: {
  ACTIVE: 'ACTIVE',
  ACKNOWLEDGED: 'ACKNOWLEDGED',
  RESOLVED: 'RESOLVED',
  IGNORED: 'IGNORED'
};

export type AlertStatus = (typeof AlertStatus)[keyof typeof AlertStatus]


export const EmergencyStatus: {
  ACTIVE: 'ACTIVE',
  RESPONDING: 'RESPONDING',
  RESOLVED: 'RESOLVED',
  ESCALATED: 'ESCALATED'
};

export type EmergencyStatus = (typeof EmergencyStatus)[keyof typeof EmergencyStatus]


export const SensorType: {
  OCCUPANCY: 'OCCUPANCY',
  TEMPERATURE: 'TEMPERATURE',
  NOISE: 'NOISE',
  AIR_QUALITY: 'AIR_QUALITY',
  MOTION: 'MOTION',
  OTHER: 'OTHER'
};

export type SensorType = (typeof SensorType)[keyof typeof SensorType]


export const SensorStatus: {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
  MAINTENANCE: 'MAINTENANCE',
  ERROR: 'ERROR'
};

export type SensorStatus = (typeof SensorStatus)[keyof typeof SensorStatus]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type UserStatus = $Enums.UserStatus

export const UserStatus: typeof $Enums.UserStatus

export type BraceletStatus = $Enums.BraceletStatus

export const BraceletStatus: typeof $Enums.BraceletStatus

export type AlertType = $Enums.AlertType

export const AlertType: typeof $Enums.AlertType

export type AlertStatus = $Enums.AlertStatus

export const AlertStatus: typeof $Enums.AlertStatus

export type EmergencyStatus = $Enums.EmergencyStatus

export const EmergencyStatus: typeof $Enums.EmergencyStatus

export type SensorType = $Enums.SensorType

export const SensorType: typeof $Enums.SensorType

export type SensorStatus = $Enums.SensorStatus

export const SensorStatus: typeof $Enums.SensorStatus

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Nightclubs
 * const nightclubs = await prisma.nightclub.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Nightclubs
   * const nightclubs = await prisma.nightclub.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.nightclub`: Exposes CRUD operations for the **Nightclub** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Nightclubs
    * const nightclubs = await prisma.nightclub.findMany()
    * ```
    */
  get nightclub(): Prisma.NightclubDelegate<ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.floorPlan`: Exposes CRUD operations for the **FloorPlan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FloorPlans
    * const floorPlans = await prisma.floorPlan.findMany()
    * ```
    */
  get floorPlan(): Prisma.FloorPlanDelegate<ExtArgs>;

  /**
   * `prisma.zone`: Exposes CRUD operations for the **Zone** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Zones
    * const zones = await prisma.zone.findMany()
    * ```
    */
  get zone(): Prisma.ZoneDelegate<ExtArgs>;

  /**
   * `prisma.bracelet`: Exposes CRUD operations for the **Bracelet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bracelets
    * const bracelets = await prisma.bracelet.findMany()
    * ```
    */
  get bracelet(): Prisma.BraceletDelegate<ExtArgs>;

  /**
   * `prisma.alert`: Exposes CRUD operations for the **Alert** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Alerts
    * const alerts = await prisma.alert.findMany()
    * ```
    */
  get alert(): Prisma.AlertDelegate<ExtArgs>;

  /**
   * `prisma.emergency`: Exposes CRUD operations for the **Emergency** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Emergencies
    * const emergencies = await prisma.emergency.findMany()
    * ```
    */
  get emergency(): Prisma.EmergencyDelegate<ExtArgs>;

  /**
   * `prisma.sensor`: Exposes CRUD operations for the **Sensor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sensors
    * const sensors = await prisma.sensor.findMany()
    * ```
    */
  get sensor(): Prisma.SensorDelegate<ExtArgs>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs>;

  /**
   * `prisma.analyticsReport`: Exposes CRUD operations for the **AnalyticsReport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AnalyticsReports
    * const analyticsReports = await prisma.analyticsReport.findMany()
    * ```
    */
  get analyticsReport(): Prisma.AnalyticsReportDelegate<ExtArgs>;

  /**
   * `prisma.aIModel`: Exposes CRUD operations for the **AIModel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AIModels
    * const aIModels = await prisma.aIModel.findMany()
    * ```
    */
  get aIModel(): Prisma.AIModelDelegate<ExtArgs>;

  /**
   * `prisma.prediction`: Exposes CRUD operations for the **Prediction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Predictions
    * const predictions = await prisma.prediction.findMany()
    * ```
    */
  get prediction(): Prisma.PredictionDelegate<ExtArgs>;

  /**
   * `prisma.anomaly`: Exposes CRUD operations for the **Anomaly** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Anomalies
    * const anomalies = await prisma.anomaly.findMany()
    * ```
    */
  get anomaly(): Prisma.AnomalyDelegate<ExtArgs>;

  /**
   * `prisma.behaviorAnalysis`: Exposes CRUD operations for the **BehaviorAnalysis** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BehaviorAnalyses
    * const behaviorAnalyses = await prisma.behaviorAnalysis.findMany()
    * ```
    */
  get behaviorAnalysis(): Prisma.BehaviorAnalysisDelegate<ExtArgs>;

  /**
   * `prisma.realTimeMetric`: Exposes CRUD operations for the **RealTimeMetric** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RealTimeMetrics
    * const realTimeMetrics = await prisma.realTimeMetric.findMany()
    * ```
    */
  get realTimeMetric(): Prisma.RealTimeMetricDelegate<ExtArgs>;

  /**
   * `prisma.dataStream`: Exposes CRUD operations for the **DataStream** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DataStreams
    * const dataStreams = await prisma.dataStream.findMany()
    * ```
    */
  get dataStream(): Prisma.DataStreamDelegate<ExtArgs>;

  /**
   * `prisma.cacheEntry`: Exposes CRUD operations for the **CacheEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CacheEntries
    * const cacheEntries = await prisma.cacheEntry.findMany()
    * ```
    */
  get cacheEntry(): Prisma.CacheEntryDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Nightclub: 'Nightclub',
    User: 'User',
    FloorPlan: 'FloorPlan',
    Zone: 'Zone',
    Bracelet: 'Bracelet',
    Alert: 'Alert',
    Emergency: 'Emergency',
    Sensor: 'Sensor',
    AuditLog: 'AuditLog',
    AnalyticsReport: 'AnalyticsReport',
    AIModel: 'AIModel',
    Prediction: 'Prediction',
    Anomaly: 'Anomaly',
    BehaviorAnalysis: 'BehaviorAnalysis',
    RealTimeMetric: 'RealTimeMetric',
    DataStream: 'DataStream',
    CacheEntry: 'CacheEntry'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "nightclub" | "user" | "floorPlan" | "zone" | "bracelet" | "alert" | "emergency" | "sensor" | "auditLog" | "analyticsReport" | "aIModel" | "prediction" | "anomaly" | "behaviorAnalysis" | "realTimeMetric" | "dataStream" | "cacheEntry"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Nightclub: {
        payload: Prisma.$NightclubPayload<ExtArgs>
        fields: Prisma.NightclubFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NightclubFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NightclubPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NightclubFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NightclubPayload>
          }
          findFirst: {
            args: Prisma.NightclubFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NightclubPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NightclubFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NightclubPayload>
          }
          findMany: {
            args: Prisma.NightclubFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NightclubPayload>[]
          }
          create: {
            args: Prisma.NightclubCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NightclubPayload>
          }
          createMany: {
            args: Prisma.NightclubCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NightclubCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NightclubPayload>[]
          }
          delete: {
            args: Prisma.NightclubDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NightclubPayload>
          }
          update: {
            args: Prisma.NightclubUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NightclubPayload>
          }
          deleteMany: {
            args: Prisma.NightclubDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NightclubUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NightclubUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NightclubPayload>
          }
          aggregate: {
            args: Prisma.NightclubAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNightclub>
          }
          groupBy: {
            args: Prisma.NightclubGroupByArgs<ExtArgs>
            result: $Utils.Optional<NightclubGroupByOutputType>[]
          }
          count: {
            args: Prisma.NightclubCountArgs<ExtArgs>
            result: $Utils.Optional<NightclubCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      FloorPlan: {
        payload: Prisma.$FloorPlanPayload<ExtArgs>
        fields: Prisma.FloorPlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FloorPlanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FloorPlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FloorPlanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FloorPlanPayload>
          }
          findFirst: {
            args: Prisma.FloorPlanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FloorPlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FloorPlanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FloorPlanPayload>
          }
          findMany: {
            args: Prisma.FloorPlanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FloorPlanPayload>[]
          }
          create: {
            args: Prisma.FloorPlanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FloorPlanPayload>
          }
          createMany: {
            args: Prisma.FloorPlanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FloorPlanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FloorPlanPayload>[]
          }
          delete: {
            args: Prisma.FloorPlanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FloorPlanPayload>
          }
          update: {
            args: Prisma.FloorPlanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FloorPlanPayload>
          }
          deleteMany: {
            args: Prisma.FloorPlanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FloorPlanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FloorPlanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FloorPlanPayload>
          }
          aggregate: {
            args: Prisma.FloorPlanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFloorPlan>
          }
          groupBy: {
            args: Prisma.FloorPlanGroupByArgs<ExtArgs>
            result: $Utils.Optional<FloorPlanGroupByOutputType>[]
          }
          count: {
            args: Prisma.FloorPlanCountArgs<ExtArgs>
            result: $Utils.Optional<FloorPlanCountAggregateOutputType> | number
          }
        }
      }
      Zone: {
        payload: Prisma.$ZonePayload<ExtArgs>
        fields: Prisma.ZoneFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ZoneFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ZoneFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>
          }
          findFirst: {
            args: Prisma.ZoneFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ZoneFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>
          }
          findMany: {
            args: Prisma.ZoneFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>[]
          }
          create: {
            args: Prisma.ZoneCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>
          }
          createMany: {
            args: Prisma.ZoneCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ZoneCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>[]
          }
          delete: {
            args: Prisma.ZoneDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>
          }
          update: {
            args: Prisma.ZoneUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>
          }
          deleteMany: {
            args: Prisma.ZoneDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ZoneUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ZoneUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZonePayload>
          }
          aggregate: {
            args: Prisma.ZoneAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateZone>
          }
          groupBy: {
            args: Prisma.ZoneGroupByArgs<ExtArgs>
            result: $Utils.Optional<ZoneGroupByOutputType>[]
          }
          count: {
            args: Prisma.ZoneCountArgs<ExtArgs>
            result: $Utils.Optional<ZoneCountAggregateOutputType> | number
          }
        }
      }
      Bracelet: {
        payload: Prisma.$BraceletPayload<ExtArgs>
        fields: Prisma.BraceletFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BraceletFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BraceletPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BraceletFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BraceletPayload>
          }
          findFirst: {
            args: Prisma.BraceletFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BraceletPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BraceletFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BraceletPayload>
          }
          findMany: {
            args: Prisma.BraceletFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BraceletPayload>[]
          }
          create: {
            args: Prisma.BraceletCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BraceletPayload>
          }
          createMany: {
            args: Prisma.BraceletCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BraceletCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BraceletPayload>[]
          }
          delete: {
            args: Prisma.BraceletDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BraceletPayload>
          }
          update: {
            args: Prisma.BraceletUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BraceletPayload>
          }
          deleteMany: {
            args: Prisma.BraceletDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BraceletUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BraceletUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BraceletPayload>
          }
          aggregate: {
            args: Prisma.BraceletAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBracelet>
          }
          groupBy: {
            args: Prisma.BraceletGroupByArgs<ExtArgs>
            result: $Utils.Optional<BraceletGroupByOutputType>[]
          }
          count: {
            args: Prisma.BraceletCountArgs<ExtArgs>
            result: $Utils.Optional<BraceletCountAggregateOutputType> | number
          }
        }
      }
      Alert: {
        payload: Prisma.$AlertPayload<ExtArgs>
        fields: Prisma.AlertFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AlertFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AlertFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          findFirst: {
            args: Prisma.AlertFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AlertFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          findMany: {
            args: Prisma.AlertFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>[]
          }
          create: {
            args: Prisma.AlertCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          createMany: {
            args: Prisma.AlertCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AlertCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>[]
          }
          delete: {
            args: Prisma.AlertDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          update: {
            args: Prisma.AlertUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          deleteMany: {
            args: Prisma.AlertDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AlertUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AlertUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AlertPayload>
          }
          aggregate: {
            args: Prisma.AlertAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAlert>
          }
          groupBy: {
            args: Prisma.AlertGroupByArgs<ExtArgs>
            result: $Utils.Optional<AlertGroupByOutputType>[]
          }
          count: {
            args: Prisma.AlertCountArgs<ExtArgs>
            result: $Utils.Optional<AlertCountAggregateOutputType> | number
          }
        }
      }
      Emergency: {
        payload: Prisma.$EmergencyPayload<ExtArgs>
        fields: Prisma.EmergencyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmergencyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmergencyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyPayload>
          }
          findFirst: {
            args: Prisma.EmergencyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmergencyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyPayload>
          }
          findMany: {
            args: Prisma.EmergencyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyPayload>[]
          }
          create: {
            args: Prisma.EmergencyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyPayload>
          }
          createMany: {
            args: Prisma.EmergencyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmergencyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyPayload>[]
          }
          delete: {
            args: Prisma.EmergencyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyPayload>
          }
          update: {
            args: Prisma.EmergencyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyPayload>
          }
          deleteMany: {
            args: Prisma.EmergencyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmergencyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EmergencyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmergencyPayload>
          }
          aggregate: {
            args: Prisma.EmergencyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmergency>
          }
          groupBy: {
            args: Prisma.EmergencyGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmergencyGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmergencyCountArgs<ExtArgs>
            result: $Utils.Optional<EmergencyCountAggregateOutputType> | number
          }
        }
      }
      Sensor: {
        payload: Prisma.$SensorPayload<ExtArgs>
        fields: Prisma.SensorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SensorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SensorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SensorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SensorPayload>
          }
          findFirst: {
            args: Prisma.SensorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SensorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SensorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SensorPayload>
          }
          findMany: {
            args: Prisma.SensorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SensorPayload>[]
          }
          create: {
            args: Prisma.SensorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SensorPayload>
          }
          createMany: {
            args: Prisma.SensorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SensorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SensorPayload>[]
          }
          delete: {
            args: Prisma.SensorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SensorPayload>
          }
          update: {
            args: Prisma.SensorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SensorPayload>
          }
          deleteMany: {
            args: Prisma.SensorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SensorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SensorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SensorPayload>
          }
          aggregate: {
            args: Prisma.SensorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSensor>
          }
          groupBy: {
            args: Prisma.SensorGroupByArgs<ExtArgs>
            result: $Utils.Optional<SensorGroupByOutputType>[]
          }
          count: {
            args: Prisma.SensorCountArgs<ExtArgs>
            result: $Utils.Optional<SensorCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      AnalyticsReport: {
        payload: Prisma.$AnalyticsReportPayload<ExtArgs>
        fields: Prisma.AnalyticsReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AnalyticsReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AnalyticsReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsReportPayload>
          }
          findFirst: {
            args: Prisma.AnalyticsReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AnalyticsReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsReportPayload>
          }
          findMany: {
            args: Prisma.AnalyticsReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsReportPayload>[]
          }
          create: {
            args: Prisma.AnalyticsReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsReportPayload>
          }
          createMany: {
            args: Prisma.AnalyticsReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AnalyticsReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsReportPayload>[]
          }
          delete: {
            args: Prisma.AnalyticsReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsReportPayload>
          }
          update: {
            args: Prisma.AnalyticsReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsReportPayload>
          }
          deleteMany: {
            args: Prisma.AnalyticsReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AnalyticsReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AnalyticsReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnalyticsReportPayload>
          }
          aggregate: {
            args: Prisma.AnalyticsReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnalyticsReport>
          }
          groupBy: {
            args: Prisma.AnalyticsReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnalyticsReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.AnalyticsReportCountArgs<ExtArgs>
            result: $Utils.Optional<AnalyticsReportCountAggregateOutputType> | number
          }
        }
      }
      AIModel: {
        payload: Prisma.$AIModelPayload<ExtArgs>
        fields: Prisma.AIModelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AIModelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIModelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AIModelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIModelPayload>
          }
          findFirst: {
            args: Prisma.AIModelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIModelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AIModelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIModelPayload>
          }
          findMany: {
            args: Prisma.AIModelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIModelPayload>[]
          }
          create: {
            args: Prisma.AIModelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIModelPayload>
          }
          createMany: {
            args: Prisma.AIModelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AIModelCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIModelPayload>[]
          }
          delete: {
            args: Prisma.AIModelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIModelPayload>
          }
          update: {
            args: Prisma.AIModelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIModelPayload>
          }
          deleteMany: {
            args: Prisma.AIModelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AIModelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AIModelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AIModelPayload>
          }
          aggregate: {
            args: Prisma.AIModelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAIModel>
          }
          groupBy: {
            args: Prisma.AIModelGroupByArgs<ExtArgs>
            result: $Utils.Optional<AIModelGroupByOutputType>[]
          }
          count: {
            args: Prisma.AIModelCountArgs<ExtArgs>
            result: $Utils.Optional<AIModelCountAggregateOutputType> | number
          }
        }
      }
      Prediction: {
        payload: Prisma.$PredictionPayload<ExtArgs>
        fields: Prisma.PredictionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PredictionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PredictionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PredictionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PredictionPayload>
          }
          findFirst: {
            args: Prisma.PredictionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PredictionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PredictionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PredictionPayload>
          }
          findMany: {
            args: Prisma.PredictionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PredictionPayload>[]
          }
          create: {
            args: Prisma.PredictionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PredictionPayload>
          }
          createMany: {
            args: Prisma.PredictionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PredictionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PredictionPayload>[]
          }
          delete: {
            args: Prisma.PredictionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PredictionPayload>
          }
          update: {
            args: Prisma.PredictionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PredictionPayload>
          }
          deleteMany: {
            args: Prisma.PredictionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PredictionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PredictionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PredictionPayload>
          }
          aggregate: {
            args: Prisma.PredictionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePrediction>
          }
          groupBy: {
            args: Prisma.PredictionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PredictionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PredictionCountArgs<ExtArgs>
            result: $Utils.Optional<PredictionCountAggregateOutputType> | number
          }
        }
      }
      Anomaly: {
        payload: Prisma.$AnomalyPayload<ExtArgs>
        fields: Prisma.AnomalyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AnomalyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnomalyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AnomalyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnomalyPayload>
          }
          findFirst: {
            args: Prisma.AnomalyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnomalyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AnomalyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnomalyPayload>
          }
          findMany: {
            args: Prisma.AnomalyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnomalyPayload>[]
          }
          create: {
            args: Prisma.AnomalyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnomalyPayload>
          }
          createMany: {
            args: Prisma.AnomalyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AnomalyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnomalyPayload>[]
          }
          delete: {
            args: Prisma.AnomalyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnomalyPayload>
          }
          update: {
            args: Prisma.AnomalyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnomalyPayload>
          }
          deleteMany: {
            args: Prisma.AnomalyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AnomalyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AnomalyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AnomalyPayload>
          }
          aggregate: {
            args: Prisma.AnomalyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnomaly>
          }
          groupBy: {
            args: Prisma.AnomalyGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnomalyGroupByOutputType>[]
          }
          count: {
            args: Prisma.AnomalyCountArgs<ExtArgs>
            result: $Utils.Optional<AnomalyCountAggregateOutputType> | number
          }
        }
      }
      BehaviorAnalysis: {
        payload: Prisma.$BehaviorAnalysisPayload<ExtArgs>
        fields: Prisma.BehaviorAnalysisFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BehaviorAnalysisFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BehaviorAnalysisPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BehaviorAnalysisFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BehaviorAnalysisPayload>
          }
          findFirst: {
            args: Prisma.BehaviorAnalysisFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BehaviorAnalysisPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BehaviorAnalysisFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BehaviorAnalysisPayload>
          }
          findMany: {
            args: Prisma.BehaviorAnalysisFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BehaviorAnalysisPayload>[]
          }
          create: {
            args: Prisma.BehaviorAnalysisCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BehaviorAnalysisPayload>
          }
          createMany: {
            args: Prisma.BehaviorAnalysisCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BehaviorAnalysisCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BehaviorAnalysisPayload>[]
          }
          delete: {
            args: Prisma.BehaviorAnalysisDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BehaviorAnalysisPayload>
          }
          update: {
            args: Prisma.BehaviorAnalysisUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BehaviorAnalysisPayload>
          }
          deleteMany: {
            args: Prisma.BehaviorAnalysisDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BehaviorAnalysisUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BehaviorAnalysisUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BehaviorAnalysisPayload>
          }
          aggregate: {
            args: Prisma.BehaviorAnalysisAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBehaviorAnalysis>
          }
          groupBy: {
            args: Prisma.BehaviorAnalysisGroupByArgs<ExtArgs>
            result: $Utils.Optional<BehaviorAnalysisGroupByOutputType>[]
          }
          count: {
            args: Prisma.BehaviorAnalysisCountArgs<ExtArgs>
            result: $Utils.Optional<BehaviorAnalysisCountAggregateOutputType> | number
          }
        }
      }
      RealTimeMetric: {
        payload: Prisma.$RealTimeMetricPayload<ExtArgs>
        fields: Prisma.RealTimeMetricFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RealTimeMetricFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RealTimeMetricPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RealTimeMetricFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RealTimeMetricPayload>
          }
          findFirst: {
            args: Prisma.RealTimeMetricFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RealTimeMetricPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RealTimeMetricFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RealTimeMetricPayload>
          }
          findMany: {
            args: Prisma.RealTimeMetricFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RealTimeMetricPayload>[]
          }
          create: {
            args: Prisma.RealTimeMetricCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RealTimeMetricPayload>
          }
          createMany: {
            args: Prisma.RealTimeMetricCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RealTimeMetricCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RealTimeMetricPayload>[]
          }
          delete: {
            args: Prisma.RealTimeMetricDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RealTimeMetricPayload>
          }
          update: {
            args: Prisma.RealTimeMetricUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RealTimeMetricPayload>
          }
          deleteMany: {
            args: Prisma.RealTimeMetricDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RealTimeMetricUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RealTimeMetricUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RealTimeMetricPayload>
          }
          aggregate: {
            args: Prisma.RealTimeMetricAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRealTimeMetric>
          }
          groupBy: {
            args: Prisma.RealTimeMetricGroupByArgs<ExtArgs>
            result: $Utils.Optional<RealTimeMetricGroupByOutputType>[]
          }
          count: {
            args: Prisma.RealTimeMetricCountArgs<ExtArgs>
            result: $Utils.Optional<RealTimeMetricCountAggregateOutputType> | number
          }
        }
      }
      DataStream: {
        payload: Prisma.$DataStreamPayload<ExtArgs>
        fields: Prisma.DataStreamFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DataStreamFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataStreamPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DataStreamFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataStreamPayload>
          }
          findFirst: {
            args: Prisma.DataStreamFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataStreamPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DataStreamFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataStreamPayload>
          }
          findMany: {
            args: Prisma.DataStreamFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataStreamPayload>[]
          }
          create: {
            args: Prisma.DataStreamCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataStreamPayload>
          }
          createMany: {
            args: Prisma.DataStreamCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DataStreamCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataStreamPayload>[]
          }
          delete: {
            args: Prisma.DataStreamDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataStreamPayload>
          }
          update: {
            args: Prisma.DataStreamUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataStreamPayload>
          }
          deleteMany: {
            args: Prisma.DataStreamDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DataStreamUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DataStreamUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DataStreamPayload>
          }
          aggregate: {
            args: Prisma.DataStreamAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDataStream>
          }
          groupBy: {
            args: Prisma.DataStreamGroupByArgs<ExtArgs>
            result: $Utils.Optional<DataStreamGroupByOutputType>[]
          }
          count: {
            args: Prisma.DataStreamCountArgs<ExtArgs>
            result: $Utils.Optional<DataStreamCountAggregateOutputType> | number
          }
        }
      }
      CacheEntry: {
        payload: Prisma.$CacheEntryPayload<ExtArgs>
        fields: Prisma.CacheEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CacheEntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CacheEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CacheEntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CacheEntryPayload>
          }
          findFirst: {
            args: Prisma.CacheEntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CacheEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CacheEntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CacheEntryPayload>
          }
          findMany: {
            args: Prisma.CacheEntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CacheEntryPayload>[]
          }
          create: {
            args: Prisma.CacheEntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CacheEntryPayload>
          }
          createMany: {
            args: Prisma.CacheEntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CacheEntryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CacheEntryPayload>[]
          }
          delete: {
            args: Prisma.CacheEntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CacheEntryPayload>
          }
          update: {
            args: Prisma.CacheEntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CacheEntryPayload>
          }
          deleteMany: {
            args: Prisma.CacheEntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CacheEntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CacheEntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CacheEntryPayload>
          }
          aggregate: {
            args: Prisma.CacheEntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCacheEntry>
          }
          groupBy: {
            args: Prisma.CacheEntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CacheEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CacheEntryCountArgs<ExtArgs>
            result: $Utils.Optional<CacheEntryCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type NightclubCountOutputType
   */

  export type NightclubCountOutputType = {
    floorPlans: number
    users: number
    bracelets: number
    zones: number
    emergencies: number
    analyticsReports: number
    predictions: number
    anomalies: number
    behaviors: number
    realTimeMetrics: number
    dataStreams: number
    cacheEntries: number
  }

  export type NightclubCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    floorPlans?: boolean | NightclubCountOutputTypeCountFloorPlansArgs
    users?: boolean | NightclubCountOutputTypeCountUsersArgs
    bracelets?: boolean | NightclubCountOutputTypeCountBraceletsArgs
    zones?: boolean | NightclubCountOutputTypeCountZonesArgs
    emergencies?: boolean | NightclubCountOutputTypeCountEmergenciesArgs
    analyticsReports?: boolean | NightclubCountOutputTypeCountAnalyticsReportsArgs
    predictions?: boolean | NightclubCountOutputTypeCountPredictionsArgs
    anomalies?: boolean | NightclubCountOutputTypeCountAnomaliesArgs
    behaviors?: boolean | NightclubCountOutputTypeCountBehaviorsArgs
    realTimeMetrics?: boolean | NightclubCountOutputTypeCountRealTimeMetricsArgs
    dataStreams?: boolean | NightclubCountOutputTypeCountDataStreamsArgs
    cacheEntries?: boolean | NightclubCountOutputTypeCountCacheEntriesArgs
  }

  // Custom InputTypes
  /**
   * NightclubCountOutputType without action
   */
  export type NightclubCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NightclubCountOutputType
     */
    select?: NightclubCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * NightclubCountOutputType without action
   */
  export type NightclubCountOutputTypeCountFloorPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FloorPlanWhereInput
  }

  /**
   * NightclubCountOutputType without action
   */
  export type NightclubCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * NightclubCountOutputType without action
   */
  export type NightclubCountOutputTypeCountBraceletsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BraceletWhereInput
  }

  /**
   * NightclubCountOutputType without action
   */
  export type NightclubCountOutputTypeCountZonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ZoneWhereInput
  }

  /**
   * NightclubCountOutputType without action
   */
  export type NightclubCountOutputTypeCountEmergenciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmergencyWhereInput
  }

  /**
   * NightclubCountOutputType without action
   */
  export type NightclubCountOutputTypeCountAnalyticsReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnalyticsReportWhereInput
  }

  /**
   * NightclubCountOutputType without action
   */
  export type NightclubCountOutputTypeCountPredictionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PredictionWhereInput
  }

  /**
   * NightclubCountOutputType without action
   */
  export type NightclubCountOutputTypeCountAnomaliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnomalyWhereInput
  }

  /**
   * NightclubCountOutputType without action
   */
  export type NightclubCountOutputTypeCountBehaviorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BehaviorAnalysisWhereInput
  }

  /**
   * NightclubCountOutputType without action
   */
  export type NightclubCountOutputTypeCountRealTimeMetricsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RealTimeMetricWhereInput
  }

  /**
   * NightclubCountOutputType without action
   */
  export type NightclubCountOutputTypeCountDataStreamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DataStreamWhereInput
  }

  /**
   * NightclubCountOutputType without action
   */
  export type NightclubCountOutputTypeCountCacheEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CacheEntryWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    alerts: number
    emergencies: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    alerts?: boolean | UserCountOutputTypeCountAlertsArgs
    emergencies?: boolean | UserCountOutputTypeCountEmergenciesArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAlertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlertWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEmergenciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmergencyWhereInput
  }


  /**
   * Count Type FloorPlanCountOutputType
   */

  export type FloorPlanCountOutputType = {
    zones: number
  }

  export type FloorPlanCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    zones?: boolean | FloorPlanCountOutputTypeCountZonesArgs
  }

  // Custom InputTypes
  /**
   * FloorPlanCountOutputType without action
   */
  export type FloorPlanCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FloorPlanCountOutputType
     */
    select?: FloorPlanCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FloorPlanCountOutputType without action
   */
  export type FloorPlanCountOutputTypeCountZonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ZoneWhereInput
  }


  /**
   * Count Type ZoneCountOutputType
   */

  export type ZoneCountOutputType = {
    alerts: number
    emergencies: number
    sensors: number
    anomalies: number
    behaviors: number
    realTimeMetrics: number
    predictions: number
  }

  export type ZoneCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    alerts?: boolean | ZoneCountOutputTypeCountAlertsArgs
    emergencies?: boolean | ZoneCountOutputTypeCountEmergenciesArgs
    sensors?: boolean | ZoneCountOutputTypeCountSensorsArgs
    anomalies?: boolean | ZoneCountOutputTypeCountAnomaliesArgs
    behaviors?: boolean | ZoneCountOutputTypeCountBehaviorsArgs
    realTimeMetrics?: boolean | ZoneCountOutputTypeCountRealTimeMetricsArgs
    predictions?: boolean | ZoneCountOutputTypeCountPredictionsArgs
  }

  // Custom InputTypes
  /**
   * ZoneCountOutputType without action
   */
  export type ZoneCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZoneCountOutputType
     */
    select?: ZoneCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ZoneCountOutputType without action
   */
  export type ZoneCountOutputTypeCountAlertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlertWhereInput
  }

  /**
   * ZoneCountOutputType without action
   */
  export type ZoneCountOutputTypeCountEmergenciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmergencyWhereInput
  }

  /**
   * ZoneCountOutputType without action
   */
  export type ZoneCountOutputTypeCountSensorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SensorWhereInput
  }

  /**
   * ZoneCountOutputType without action
   */
  export type ZoneCountOutputTypeCountAnomaliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnomalyWhereInput
  }

  /**
   * ZoneCountOutputType without action
   */
  export type ZoneCountOutputTypeCountBehaviorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BehaviorAnalysisWhereInput
  }

  /**
   * ZoneCountOutputType without action
   */
  export type ZoneCountOutputTypeCountRealTimeMetricsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RealTimeMetricWhereInput
  }

  /**
   * ZoneCountOutputType without action
   */
  export type ZoneCountOutputTypeCountPredictionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PredictionWhereInput
  }


  /**
   * Count Type BraceletCountOutputType
   */

  export type BraceletCountOutputType = {
    alerts: number
    emergencies: number
  }

  export type BraceletCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    alerts?: boolean | BraceletCountOutputTypeCountAlertsArgs
    emergencies?: boolean | BraceletCountOutputTypeCountEmergenciesArgs
  }

  // Custom InputTypes
  /**
   * BraceletCountOutputType without action
   */
  export type BraceletCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BraceletCountOutputType
     */
    select?: BraceletCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BraceletCountOutputType without action
   */
  export type BraceletCountOutputTypeCountAlertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlertWhereInput
  }

  /**
   * BraceletCountOutputType without action
   */
  export type BraceletCountOutputTypeCountEmergenciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmergencyWhereInput
  }


  /**
   * Count Type AIModelCountOutputType
   */

  export type AIModelCountOutputType = {
    predictions: number
    anomalies: number
    behaviorAnalyses: number
  }

  export type AIModelCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    predictions?: boolean | AIModelCountOutputTypeCountPredictionsArgs
    anomalies?: boolean | AIModelCountOutputTypeCountAnomaliesArgs
    behaviorAnalyses?: boolean | AIModelCountOutputTypeCountBehaviorAnalysesArgs
  }

  // Custom InputTypes
  /**
   * AIModelCountOutputType without action
   */
  export type AIModelCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIModelCountOutputType
     */
    select?: AIModelCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AIModelCountOutputType without action
   */
  export type AIModelCountOutputTypeCountPredictionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PredictionWhereInput
  }

  /**
   * AIModelCountOutputType without action
   */
  export type AIModelCountOutputTypeCountAnomaliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnomalyWhereInput
  }

  /**
   * AIModelCountOutputType without action
   */
  export type AIModelCountOutputTypeCountBehaviorAnalysesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BehaviorAnalysisWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Nightclub
   */

  export type AggregateNightclub = {
    _count: NightclubCountAggregateOutputType | null
    _min: NightclubMinAggregateOutputType | null
    _max: NightclubMaxAggregateOutputType | null
  }

  export type NightclubMinAggregateOutputType = {
    id: string | null
    name: string | null
    address: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NightclubMaxAggregateOutputType = {
    id: string | null
    name: string | null
    address: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NightclubCountAggregateOutputType = {
    id: number
    name: number
    address: number
    settings: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NightclubMinAggregateInputType = {
    id?: true
    name?: true
    address?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NightclubMaxAggregateInputType = {
    id?: true
    name?: true
    address?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NightclubCountAggregateInputType = {
    id?: true
    name?: true
    address?: true
    settings?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NightclubAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Nightclub to aggregate.
     */
    where?: NightclubWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Nightclubs to fetch.
     */
    orderBy?: NightclubOrderByWithRelationInput | NightclubOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NightclubWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Nightclubs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Nightclubs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Nightclubs
    **/
    _count?: true | NightclubCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NightclubMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NightclubMaxAggregateInputType
  }

  export type GetNightclubAggregateType<T extends NightclubAggregateArgs> = {
        [P in keyof T & keyof AggregateNightclub]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNightclub[P]>
      : GetScalarType<T[P], AggregateNightclub[P]>
  }




  export type NightclubGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NightclubWhereInput
    orderBy?: NightclubOrderByWithAggregationInput | NightclubOrderByWithAggregationInput[]
    by: NightclubScalarFieldEnum[] | NightclubScalarFieldEnum
    having?: NightclubScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NightclubCountAggregateInputType | true
    _min?: NightclubMinAggregateInputType
    _max?: NightclubMaxAggregateInputType
  }

  export type NightclubGroupByOutputType = {
    id: string
    name: string
    address: string
    settings: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: NightclubCountAggregateOutputType | null
    _min: NightclubMinAggregateOutputType | null
    _max: NightclubMaxAggregateOutputType | null
  }

  type GetNightclubGroupByPayload<T extends NightclubGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NightclubGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NightclubGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NightclubGroupByOutputType[P]>
            : GetScalarType<T[P], NightclubGroupByOutputType[P]>
        }
      >
    >


  export type NightclubSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    settings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    floorPlans?: boolean | Nightclub$floorPlansArgs<ExtArgs>
    users?: boolean | Nightclub$usersArgs<ExtArgs>
    bracelets?: boolean | Nightclub$braceletsArgs<ExtArgs>
    zones?: boolean | Nightclub$zonesArgs<ExtArgs>
    emergencies?: boolean | Nightclub$emergenciesArgs<ExtArgs>
    analyticsReports?: boolean | Nightclub$analyticsReportsArgs<ExtArgs>
    predictions?: boolean | Nightclub$predictionsArgs<ExtArgs>
    anomalies?: boolean | Nightclub$anomaliesArgs<ExtArgs>
    behaviors?: boolean | Nightclub$behaviorsArgs<ExtArgs>
    realTimeMetrics?: boolean | Nightclub$realTimeMetricsArgs<ExtArgs>
    dataStreams?: boolean | Nightclub$dataStreamsArgs<ExtArgs>
    cacheEntries?: boolean | Nightclub$cacheEntriesArgs<ExtArgs>
    _count?: boolean | NightclubCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["nightclub"]>

  export type NightclubSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    settings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["nightclub"]>

  export type NightclubSelectScalar = {
    id?: boolean
    name?: boolean
    address?: boolean
    settings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NightclubInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    floorPlans?: boolean | Nightclub$floorPlansArgs<ExtArgs>
    users?: boolean | Nightclub$usersArgs<ExtArgs>
    bracelets?: boolean | Nightclub$braceletsArgs<ExtArgs>
    zones?: boolean | Nightclub$zonesArgs<ExtArgs>
    emergencies?: boolean | Nightclub$emergenciesArgs<ExtArgs>
    analyticsReports?: boolean | Nightclub$analyticsReportsArgs<ExtArgs>
    predictions?: boolean | Nightclub$predictionsArgs<ExtArgs>
    anomalies?: boolean | Nightclub$anomaliesArgs<ExtArgs>
    behaviors?: boolean | Nightclub$behaviorsArgs<ExtArgs>
    realTimeMetrics?: boolean | Nightclub$realTimeMetricsArgs<ExtArgs>
    dataStreams?: boolean | Nightclub$dataStreamsArgs<ExtArgs>
    cacheEntries?: boolean | Nightclub$cacheEntriesArgs<ExtArgs>
    _count?: boolean | NightclubCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type NightclubIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $NightclubPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Nightclub"
    objects: {
      floorPlans: Prisma.$FloorPlanPayload<ExtArgs>[]
      users: Prisma.$UserPayload<ExtArgs>[]
      bracelets: Prisma.$BraceletPayload<ExtArgs>[]
      zones: Prisma.$ZonePayload<ExtArgs>[]
      emergencies: Prisma.$EmergencyPayload<ExtArgs>[]
      analyticsReports: Prisma.$AnalyticsReportPayload<ExtArgs>[]
      predictions: Prisma.$PredictionPayload<ExtArgs>[]
      anomalies: Prisma.$AnomalyPayload<ExtArgs>[]
      behaviors: Prisma.$BehaviorAnalysisPayload<ExtArgs>[]
      realTimeMetrics: Prisma.$RealTimeMetricPayload<ExtArgs>[]
      dataStreams: Prisma.$DataStreamPayload<ExtArgs>[]
      cacheEntries: Prisma.$CacheEntryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      address: string
      settings: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["nightclub"]>
    composites: {}
  }

  type NightclubGetPayload<S extends boolean | null | undefined | NightclubDefaultArgs> = $Result.GetResult<Prisma.$NightclubPayload, S>

  type NightclubCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NightclubFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NightclubCountAggregateInputType | true
    }

  export interface NightclubDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Nightclub'], meta: { name: 'Nightclub' } }
    /**
     * Find zero or one Nightclub that matches the filter.
     * @param {NightclubFindUniqueArgs} args - Arguments to find a Nightclub
     * @example
     * // Get one Nightclub
     * const nightclub = await prisma.nightclub.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NightclubFindUniqueArgs>(args: SelectSubset<T, NightclubFindUniqueArgs<ExtArgs>>): Prisma__NightclubClient<$Result.GetResult<Prisma.$NightclubPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Nightclub that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NightclubFindUniqueOrThrowArgs} args - Arguments to find a Nightclub
     * @example
     * // Get one Nightclub
     * const nightclub = await prisma.nightclub.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NightclubFindUniqueOrThrowArgs>(args: SelectSubset<T, NightclubFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NightclubClient<$Result.GetResult<Prisma.$NightclubPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Nightclub that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NightclubFindFirstArgs} args - Arguments to find a Nightclub
     * @example
     * // Get one Nightclub
     * const nightclub = await prisma.nightclub.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NightclubFindFirstArgs>(args?: SelectSubset<T, NightclubFindFirstArgs<ExtArgs>>): Prisma__NightclubClient<$Result.GetResult<Prisma.$NightclubPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Nightclub that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NightclubFindFirstOrThrowArgs} args - Arguments to find a Nightclub
     * @example
     * // Get one Nightclub
     * const nightclub = await prisma.nightclub.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NightclubFindFirstOrThrowArgs>(args?: SelectSubset<T, NightclubFindFirstOrThrowArgs<ExtArgs>>): Prisma__NightclubClient<$Result.GetResult<Prisma.$NightclubPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Nightclubs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NightclubFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Nightclubs
     * const nightclubs = await prisma.nightclub.findMany()
     * 
     * // Get first 10 Nightclubs
     * const nightclubs = await prisma.nightclub.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const nightclubWithIdOnly = await prisma.nightclub.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NightclubFindManyArgs>(args?: SelectSubset<T, NightclubFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NightclubPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Nightclub.
     * @param {NightclubCreateArgs} args - Arguments to create a Nightclub.
     * @example
     * // Create one Nightclub
     * const Nightclub = await prisma.nightclub.create({
     *   data: {
     *     // ... data to create a Nightclub
     *   }
     * })
     * 
     */
    create<T extends NightclubCreateArgs>(args: SelectSubset<T, NightclubCreateArgs<ExtArgs>>): Prisma__NightclubClient<$Result.GetResult<Prisma.$NightclubPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Nightclubs.
     * @param {NightclubCreateManyArgs} args - Arguments to create many Nightclubs.
     * @example
     * // Create many Nightclubs
     * const nightclub = await prisma.nightclub.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NightclubCreateManyArgs>(args?: SelectSubset<T, NightclubCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Nightclubs and returns the data saved in the database.
     * @param {NightclubCreateManyAndReturnArgs} args - Arguments to create many Nightclubs.
     * @example
     * // Create many Nightclubs
     * const nightclub = await prisma.nightclub.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Nightclubs and only return the `id`
     * const nightclubWithIdOnly = await prisma.nightclub.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NightclubCreateManyAndReturnArgs>(args?: SelectSubset<T, NightclubCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NightclubPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Nightclub.
     * @param {NightclubDeleteArgs} args - Arguments to delete one Nightclub.
     * @example
     * // Delete one Nightclub
     * const Nightclub = await prisma.nightclub.delete({
     *   where: {
     *     // ... filter to delete one Nightclub
     *   }
     * })
     * 
     */
    delete<T extends NightclubDeleteArgs>(args: SelectSubset<T, NightclubDeleteArgs<ExtArgs>>): Prisma__NightclubClient<$Result.GetResult<Prisma.$NightclubPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Nightclub.
     * @param {NightclubUpdateArgs} args - Arguments to update one Nightclub.
     * @example
     * // Update one Nightclub
     * const nightclub = await prisma.nightclub.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NightclubUpdateArgs>(args: SelectSubset<T, NightclubUpdateArgs<ExtArgs>>): Prisma__NightclubClient<$Result.GetResult<Prisma.$NightclubPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Nightclubs.
     * @param {NightclubDeleteManyArgs} args - Arguments to filter Nightclubs to delete.
     * @example
     * // Delete a few Nightclubs
     * const { count } = await prisma.nightclub.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NightclubDeleteManyArgs>(args?: SelectSubset<T, NightclubDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Nightclubs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NightclubUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Nightclubs
     * const nightclub = await prisma.nightclub.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NightclubUpdateManyArgs>(args: SelectSubset<T, NightclubUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Nightclub.
     * @param {NightclubUpsertArgs} args - Arguments to update or create a Nightclub.
     * @example
     * // Update or create a Nightclub
     * const nightclub = await prisma.nightclub.upsert({
     *   create: {
     *     // ... data to create a Nightclub
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Nightclub we want to update
     *   }
     * })
     */
    upsert<T extends NightclubUpsertArgs>(args: SelectSubset<T, NightclubUpsertArgs<ExtArgs>>): Prisma__NightclubClient<$Result.GetResult<Prisma.$NightclubPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Nightclubs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NightclubCountArgs} args - Arguments to filter Nightclubs to count.
     * @example
     * // Count the number of Nightclubs
     * const count = await prisma.nightclub.count({
     *   where: {
     *     // ... the filter for the Nightclubs we want to count
     *   }
     * })
    **/
    count<T extends NightclubCountArgs>(
      args?: Subset<T, NightclubCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NightclubCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Nightclub.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NightclubAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NightclubAggregateArgs>(args: Subset<T, NightclubAggregateArgs>): Prisma.PrismaPromise<GetNightclubAggregateType<T>>

    /**
     * Group by Nightclub.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NightclubGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NightclubGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NightclubGroupByArgs['orderBy'] }
        : { orderBy?: NightclubGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NightclubGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNightclubGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Nightclub model
   */
  readonly fields: NightclubFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Nightclub.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NightclubClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    floorPlans<T extends Nightclub$floorPlansArgs<ExtArgs> = {}>(args?: Subset<T, Nightclub$floorPlansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FloorPlanPayload<ExtArgs>, T, "findMany"> | Null>
    users<T extends Nightclub$usersArgs<ExtArgs> = {}>(args?: Subset<T, Nightclub$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    bracelets<T extends Nightclub$braceletsArgs<ExtArgs> = {}>(args?: Subset<T, Nightclub$braceletsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BraceletPayload<ExtArgs>, T, "findMany"> | Null>
    zones<T extends Nightclub$zonesArgs<ExtArgs> = {}>(args?: Subset<T, Nightclub$zonesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "findMany"> | Null>
    emergencies<T extends Nightclub$emergenciesArgs<ExtArgs> = {}>(args?: Subset<T, Nightclub$emergenciesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmergencyPayload<ExtArgs>, T, "findMany"> | Null>
    analyticsReports<T extends Nightclub$analyticsReportsArgs<ExtArgs> = {}>(args?: Subset<T, Nightclub$analyticsReportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalyticsReportPayload<ExtArgs>, T, "findMany"> | Null>
    predictions<T extends Nightclub$predictionsArgs<ExtArgs> = {}>(args?: Subset<T, Nightclub$predictionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PredictionPayload<ExtArgs>, T, "findMany"> | Null>
    anomalies<T extends Nightclub$anomaliesArgs<ExtArgs> = {}>(args?: Subset<T, Nightclub$anomaliesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnomalyPayload<ExtArgs>, T, "findMany"> | Null>
    behaviors<T extends Nightclub$behaviorsArgs<ExtArgs> = {}>(args?: Subset<T, Nightclub$behaviorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BehaviorAnalysisPayload<ExtArgs>, T, "findMany"> | Null>
    realTimeMetrics<T extends Nightclub$realTimeMetricsArgs<ExtArgs> = {}>(args?: Subset<T, Nightclub$realTimeMetricsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RealTimeMetricPayload<ExtArgs>, T, "findMany"> | Null>
    dataStreams<T extends Nightclub$dataStreamsArgs<ExtArgs> = {}>(args?: Subset<T, Nightclub$dataStreamsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DataStreamPayload<ExtArgs>, T, "findMany"> | Null>
    cacheEntries<T extends Nightclub$cacheEntriesArgs<ExtArgs> = {}>(args?: Subset<T, Nightclub$cacheEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CacheEntryPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Nightclub model
   */ 
  interface NightclubFieldRefs {
    readonly id: FieldRef<"Nightclub", 'String'>
    readonly name: FieldRef<"Nightclub", 'String'>
    readonly address: FieldRef<"Nightclub", 'String'>
    readonly settings: FieldRef<"Nightclub", 'Json'>
    readonly createdAt: FieldRef<"Nightclub", 'DateTime'>
    readonly updatedAt: FieldRef<"Nightclub", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Nightclub findUnique
   */
  export type NightclubFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nightclub
     */
    select?: NightclubSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NightclubInclude<ExtArgs> | null
    /**
     * Filter, which Nightclub to fetch.
     */
    where: NightclubWhereUniqueInput
  }

  /**
   * Nightclub findUniqueOrThrow
   */
  export type NightclubFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nightclub
     */
    select?: NightclubSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NightclubInclude<ExtArgs> | null
    /**
     * Filter, which Nightclub to fetch.
     */
    where: NightclubWhereUniqueInput
  }

  /**
   * Nightclub findFirst
   */
  export type NightclubFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nightclub
     */
    select?: NightclubSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NightclubInclude<ExtArgs> | null
    /**
     * Filter, which Nightclub to fetch.
     */
    where?: NightclubWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Nightclubs to fetch.
     */
    orderBy?: NightclubOrderByWithRelationInput | NightclubOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Nightclubs.
     */
    cursor?: NightclubWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Nightclubs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Nightclubs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Nightclubs.
     */
    distinct?: NightclubScalarFieldEnum | NightclubScalarFieldEnum[]
  }

  /**
   * Nightclub findFirstOrThrow
   */
  export type NightclubFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nightclub
     */
    select?: NightclubSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NightclubInclude<ExtArgs> | null
    /**
     * Filter, which Nightclub to fetch.
     */
    where?: NightclubWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Nightclubs to fetch.
     */
    orderBy?: NightclubOrderByWithRelationInput | NightclubOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Nightclubs.
     */
    cursor?: NightclubWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Nightclubs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Nightclubs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Nightclubs.
     */
    distinct?: NightclubScalarFieldEnum | NightclubScalarFieldEnum[]
  }

  /**
   * Nightclub findMany
   */
  export type NightclubFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nightclub
     */
    select?: NightclubSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NightclubInclude<ExtArgs> | null
    /**
     * Filter, which Nightclubs to fetch.
     */
    where?: NightclubWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Nightclubs to fetch.
     */
    orderBy?: NightclubOrderByWithRelationInput | NightclubOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Nightclubs.
     */
    cursor?: NightclubWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Nightclubs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Nightclubs.
     */
    skip?: number
    distinct?: NightclubScalarFieldEnum | NightclubScalarFieldEnum[]
  }

  /**
   * Nightclub create
   */
  export type NightclubCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nightclub
     */
    select?: NightclubSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NightclubInclude<ExtArgs> | null
    /**
     * The data needed to create a Nightclub.
     */
    data: XOR<NightclubCreateInput, NightclubUncheckedCreateInput>
  }

  /**
   * Nightclub createMany
   */
  export type NightclubCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Nightclubs.
     */
    data: NightclubCreateManyInput | NightclubCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Nightclub createManyAndReturn
   */
  export type NightclubCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nightclub
     */
    select?: NightclubSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Nightclubs.
     */
    data: NightclubCreateManyInput | NightclubCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Nightclub update
   */
  export type NightclubUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nightclub
     */
    select?: NightclubSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NightclubInclude<ExtArgs> | null
    /**
     * The data needed to update a Nightclub.
     */
    data: XOR<NightclubUpdateInput, NightclubUncheckedUpdateInput>
    /**
     * Choose, which Nightclub to update.
     */
    where: NightclubWhereUniqueInput
  }

  /**
   * Nightclub updateMany
   */
  export type NightclubUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Nightclubs.
     */
    data: XOR<NightclubUpdateManyMutationInput, NightclubUncheckedUpdateManyInput>
    /**
     * Filter which Nightclubs to update
     */
    where?: NightclubWhereInput
  }

  /**
   * Nightclub upsert
   */
  export type NightclubUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nightclub
     */
    select?: NightclubSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NightclubInclude<ExtArgs> | null
    /**
     * The filter to search for the Nightclub to update in case it exists.
     */
    where: NightclubWhereUniqueInput
    /**
     * In case the Nightclub found by the `where` argument doesn't exist, create a new Nightclub with this data.
     */
    create: XOR<NightclubCreateInput, NightclubUncheckedCreateInput>
    /**
     * In case the Nightclub was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NightclubUpdateInput, NightclubUncheckedUpdateInput>
  }

  /**
   * Nightclub delete
   */
  export type NightclubDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nightclub
     */
    select?: NightclubSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NightclubInclude<ExtArgs> | null
    /**
     * Filter which Nightclub to delete.
     */
    where: NightclubWhereUniqueInput
  }

  /**
   * Nightclub deleteMany
   */
  export type NightclubDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Nightclubs to delete
     */
    where?: NightclubWhereInput
  }

  /**
   * Nightclub.floorPlans
   */
  export type Nightclub$floorPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FloorPlan
     */
    select?: FloorPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FloorPlanInclude<ExtArgs> | null
    where?: FloorPlanWhereInput
    orderBy?: FloorPlanOrderByWithRelationInput | FloorPlanOrderByWithRelationInput[]
    cursor?: FloorPlanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FloorPlanScalarFieldEnum | FloorPlanScalarFieldEnum[]
  }

  /**
   * Nightclub.users
   */
  export type Nightclub$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Nightclub.bracelets
   */
  export type Nightclub$braceletsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bracelet
     */
    select?: BraceletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BraceletInclude<ExtArgs> | null
    where?: BraceletWhereInput
    orderBy?: BraceletOrderByWithRelationInput | BraceletOrderByWithRelationInput[]
    cursor?: BraceletWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BraceletScalarFieldEnum | BraceletScalarFieldEnum[]
  }

  /**
   * Nightclub.zones
   */
  export type Nightclub$zonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    where?: ZoneWhereInput
    orderBy?: ZoneOrderByWithRelationInput | ZoneOrderByWithRelationInput[]
    cursor?: ZoneWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ZoneScalarFieldEnum | ZoneScalarFieldEnum[]
  }

  /**
   * Nightclub.emergencies
   */
  export type Nightclub$emergenciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emergency
     */
    select?: EmergencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyInclude<ExtArgs> | null
    where?: EmergencyWhereInput
    orderBy?: EmergencyOrderByWithRelationInput | EmergencyOrderByWithRelationInput[]
    cursor?: EmergencyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmergencyScalarFieldEnum | EmergencyScalarFieldEnum[]
  }

  /**
   * Nightclub.analyticsReports
   */
  export type Nightclub$analyticsReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsReport
     */
    select?: AnalyticsReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsReportInclude<ExtArgs> | null
    where?: AnalyticsReportWhereInput
    orderBy?: AnalyticsReportOrderByWithRelationInput | AnalyticsReportOrderByWithRelationInput[]
    cursor?: AnalyticsReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnalyticsReportScalarFieldEnum | AnalyticsReportScalarFieldEnum[]
  }

  /**
   * Nightclub.predictions
   */
  export type Nightclub$predictionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prediction
     */
    select?: PredictionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PredictionInclude<ExtArgs> | null
    where?: PredictionWhereInput
    orderBy?: PredictionOrderByWithRelationInput | PredictionOrderByWithRelationInput[]
    cursor?: PredictionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PredictionScalarFieldEnum | PredictionScalarFieldEnum[]
  }

  /**
   * Nightclub.anomalies
   */
  export type Nightclub$anomaliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Anomaly
     */
    select?: AnomalySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnomalyInclude<ExtArgs> | null
    where?: AnomalyWhereInput
    orderBy?: AnomalyOrderByWithRelationInput | AnomalyOrderByWithRelationInput[]
    cursor?: AnomalyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnomalyScalarFieldEnum | AnomalyScalarFieldEnum[]
  }

  /**
   * Nightclub.behaviors
   */
  export type Nightclub$behaviorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BehaviorAnalysis
     */
    select?: BehaviorAnalysisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BehaviorAnalysisInclude<ExtArgs> | null
    where?: BehaviorAnalysisWhereInput
    orderBy?: BehaviorAnalysisOrderByWithRelationInput | BehaviorAnalysisOrderByWithRelationInput[]
    cursor?: BehaviorAnalysisWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BehaviorAnalysisScalarFieldEnum | BehaviorAnalysisScalarFieldEnum[]
  }

  /**
   * Nightclub.realTimeMetrics
   */
  export type Nightclub$realTimeMetricsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RealTimeMetric
     */
    select?: RealTimeMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RealTimeMetricInclude<ExtArgs> | null
    where?: RealTimeMetricWhereInput
    orderBy?: RealTimeMetricOrderByWithRelationInput | RealTimeMetricOrderByWithRelationInput[]
    cursor?: RealTimeMetricWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RealTimeMetricScalarFieldEnum | RealTimeMetricScalarFieldEnum[]
  }

  /**
   * Nightclub.dataStreams
   */
  export type Nightclub$dataStreamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataStream
     */
    select?: DataStreamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataStreamInclude<ExtArgs> | null
    where?: DataStreamWhereInput
    orderBy?: DataStreamOrderByWithRelationInput | DataStreamOrderByWithRelationInput[]
    cursor?: DataStreamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DataStreamScalarFieldEnum | DataStreamScalarFieldEnum[]
  }

  /**
   * Nightclub.cacheEntries
   */
  export type Nightclub$cacheEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CacheEntry
     */
    select?: CacheEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CacheEntryInclude<ExtArgs> | null
    where?: CacheEntryWhereInput
    orderBy?: CacheEntryOrderByWithRelationInput | CacheEntryOrderByWithRelationInput[]
    cursor?: CacheEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CacheEntryScalarFieldEnum | CacheEntryScalarFieldEnum[]
  }

  /**
   * Nightclub without action
   */
  export type NightclubDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nightclub
     */
    select?: NightclubSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NightclubInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    name: string | null
    role: $Enums.UserRole | null
    status: $Enums.UserStatus | null
    deviceId: string | null
    nightclubId: string | null
    resetToken: string | null
    resetTokenExpiry: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    lastLogin: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    name: string | null
    role: $Enums.UserRole | null
    status: $Enums.UserStatus | null
    deviceId: string | null
    nightclubId: string | null
    resetToken: string | null
    resetTokenExpiry: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    lastLogin: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    name: number
    role: number
    status: number
    deviceId: number
    nightclubId: number
    resetToken: number
    resetTokenExpiry: number
    createdAt: number
    updatedAt: number
    lastLogin: number
    lastLocation: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    role?: true
    status?: true
    deviceId?: true
    nightclubId?: true
    resetToken?: true
    resetTokenExpiry?: true
    createdAt?: true
    updatedAt?: true
    lastLogin?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    role?: true
    status?: true
    deviceId?: true
    nightclubId?: true
    resetToken?: true
    resetTokenExpiry?: true
    createdAt?: true
    updatedAt?: true
    lastLogin?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    role?: true
    status?: true
    deviceId?: true
    nightclubId?: true
    resetToken?: true
    resetTokenExpiry?: true
    createdAt?: true
    updatedAt?: true
    lastLogin?: true
    lastLocation?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    password: string
    name: string
    role: $Enums.UserRole
    status: $Enums.UserStatus
    deviceId: string | null
    nightclubId: string | null
    resetToken: string | null
    resetTokenExpiry: Date | null
    createdAt: Date
    updatedAt: Date
    lastLogin: Date | null
    lastLocation: JsonValue | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    role?: boolean
    status?: boolean
    deviceId?: boolean
    nightclubId?: boolean
    resetToken?: boolean
    resetTokenExpiry?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastLogin?: boolean
    lastLocation?: boolean
    nightclub?: boolean | User$nightclubArgs<ExtArgs>
    alerts?: boolean | User$alertsArgs<ExtArgs>
    emergencies?: boolean | User$emergenciesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    role?: boolean
    status?: boolean
    deviceId?: boolean
    nightclubId?: boolean
    resetToken?: boolean
    resetTokenExpiry?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastLogin?: boolean
    lastLocation?: boolean
    nightclub?: boolean | User$nightclubArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    role?: boolean
    status?: boolean
    deviceId?: boolean
    nightclubId?: boolean
    resetToken?: boolean
    resetTokenExpiry?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastLogin?: boolean
    lastLocation?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    nightclub?: boolean | User$nightclubArgs<ExtArgs>
    alerts?: boolean | User$alertsArgs<ExtArgs>
    emergencies?: boolean | User$emergenciesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    nightclub?: boolean | User$nightclubArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      nightclub: Prisma.$NightclubPayload<ExtArgs> | null
      alerts: Prisma.$AlertPayload<ExtArgs>[]
      emergencies: Prisma.$EmergencyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      password: string
      name: string
      role: $Enums.UserRole
      status: $Enums.UserStatus
      deviceId: string | null
      nightclubId: string | null
      resetToken: string | null
      resetTokenExpiry: Date | null
      createdAt: Date
      updatedAt: Date
      lastLogin: Date | null
      lastLocation: Prisma.JsonValue | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    nightclub<T extends User$nightclubArgs<ExtArgs> = {}>(args?: Subset<T, User$nightclubArgs<ExtArgs>>): Prisma__NightclubClient<$Result.GetResult<Prisma.$NightclubPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    alerts<T extends User$alertsArgs<ExtArgs> = {}>(args?: Subset<T, User$alertsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findMany"> | Null>
    emergencies<T extends User$emergenciesArgs<ExtArgs> = {}>(args?: Subset<T, User$emergenciesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmergencyPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly status: FieldRef<"User", 'UserStatus'>
    readonly deviceId: FieldRef<"User", 'String'>
    readonly nightclubId: FieldRef<"User", 'String'>
    readonly resetToken: FieldRef<"User", 'String'>
    readonly resetTokenExpiry: FieldRef<"User", 'DateTime'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly lastLogin: FieldRef<"User", 'DateTime'>
    readonly lastLocation: FieldRef<"User", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.nightclub
   */
  export type User$nightclubArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Nightclub
     */
    select?: NightclubSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NightclubInclude<ExtArgs> | null
    where?: NightclubWhereInput
  }

  /**
   * User.alerts
   */
  export type User$alertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    where?: AlertWhereInput
    orderBy?: AlertOrderByWithRelationInput | AlertOrderByWithRelationInput[]
    cursor?: AlertWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AlertScalarFieldEnum | AlertScalarFieldEnum[]
  }

  /**
   * User.emergencies
   */
  export type User$emergenciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emergency
     */
    select?: EmergencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyInclude<ExtArgs> | null
    where?: EmergencyWhereInput
    orderBy?: EmergencyOrderByWithRelationInput | EmergencyOrderByWithRelationInput[]
    cursor?: EmergencyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmergencyScalarFieldEnum | EmergencyScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model FloorPlan
   */

  export type AggregateFloorPlan = {
    _count: FloorPlanCountAggregateOutputType | null
    _min: FloorPlanMinAggregateOutputType | null
    _max: FloorPlanMaxAggregateOutputType | null
  }

  export type FloorPlanMinAggregateOutputType = {
    id: string | null
    name: string | null
    imageUrl: string | null
    nightclubId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FloorPlanMaxAggregateOutputType = {
    id: string | null
    name: string | null
    imageUrl: string | null
    nightclubId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FloorPlanCountAggregateOutputType = {
    id: number
    name: number
    imageUrl: number
    nightclubId: number
    createdAt: number
    updatedAt: number
    metadata: number
    _all: number
  }


  export type FloorPlanMinAggregateInputType = {
    id?: true
    name?: true
    imageUrl?: true
    nightclubId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FloorPlanMaxAggregateInputType = {
    id?: true
    name?: true
    imageUrl?: true
    nightclubId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FloorPlanCountAggregateInputType = {
    id?: true
    name?: true
    imageUrl?: true
    nightclubId?: true
    createdAt?: true
    updatedAt?: true
    metadata?: true
    _all?: true
  }

  export type FloorPlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FloorPlan to aggregate.
     */
    where?: FloorPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FloorPlans to fetch.
     */
    orderBy?: FloorPlanOrderByWithRelationInput | FloorPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FloorPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FloorPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FloorPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FloorPlans
    **/
    _count?: true | FloorPlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FloorPlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FloorPlanMaxAggregateInputType
  }

  export type GetFloorPlanAggregateType<T extends FloorPlanAggregateArgs> = {
        [P in keyof T & keyof AggregateFloorPlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFloorPlan[P]>
      : GetScalarType<T[P], AggregateFloorPlan[P]>
  }




  export type FloorPlanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FloorPlanWhereInput
    orderBy?: FloorPlanOrderByWithAggregationInput | FloorPlanOrderByWithAggregationInput[]
    by: FloorPlanScalarFieldEnum[] | FloorPlanScalarFieldEnum
    having?: FloorPlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FloorPlanCountAggregateInputType | true
    _min?: FloorPlanMinAggregateInputType
    _max?: FloorPlanMaxAggregateInputType
  }

  export type FloorPlanGroupByOutputType = {
    id: string
    name: string
    imageUrl: string
    nightclubId: string
    createdAt: Date
    updatedAt: Date
    metadata: JsonValue | null
    _count: FloorPlanCountAggregateOutputType | null
    _min: FloorPlanMinAggregateOutputType | null
    _max: FloorPlanMaxAggregateOutputType | null
  }

  type GetFloorPlanGroupByPayload<T extends FloorPlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FloorPlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FloorPlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FloorPlanGroupByOutputType[P]>
            : GetScalarType<T[P], FloorPlanGroupByOutputType[P]>
        }
      >
    >


  export type FloorPlanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    imageUrl?: boolean
    nightclubId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    metadata?: boolean
    nightclub?: boolean | NightclubDefaultArgs<ExtArgs>
    zones?: boolean | FloorPlan$zonesArgs<ExtArgs>
    _count?: boolean | FloorPlanCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["floorPlan"]>

  export type FloorPlanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    imageUrl?: boolean
    nightclubId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    metadata?: boolean
    nightclub?: boolean | NightclubDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["floorPlan"]>

  export type FloorPlanSelectScalar = {
    id?: boolean
    name?: boolean
    imageUrl?: boolean
    nightclubId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    metadata?: boolean
  }

  export type FloorPlanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    nightclub?: boolean | NightclubDefaultArgs<ExtArgs>
    zones?: boolean | FloorPlan$zonesArgs<ExtArgs>
    _count?: boolean | FloorPlanCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FloorPlanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    nightclub?: boolean | NightclubDefaultArgs<ExtArgs>
  }

  export type $FloorPlanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FloorPlan"
    objects: {
      nightclub: Prisma.$NightclubPayload<ExtArgs>
      zones: Prisma.$ZonePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      imageUrl: string
      nightclubId: string
      createdAt: Date
      updatedAt: Date
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["floorPlan"]>
    composites: {}
  }

  type FloorPlanGetPayload<S extends boolean | null | undefined | FloorPlanDefaultArgs> = $Result.GetResult<Prisma.$FloorPlanPayload, S>

  type FloorPlanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FloorPlanFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FloorPlanCountAggregateInputType | true
    }

  export interface FloorPlanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FloorPlan'], meta: { name: 'FloorPlan' } }
    /**
     * Find zero or one FloorPlan that matches the filter.
     * @param {FloorPlanFindUniqueArgs} args - Arguments to find a FloorPlan
     * @example
     * // Get one FloorPlan
     * const floorPlan = await prisma.floorPlan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FloorPlanFindUniqueArgs>(args: SelectSubset<T, FloorPlanFindUniqueArgs<ExtArgs>>): Prisma__FloorPlanClient<$Result.GetResult<Prisma.$FloorPlanPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one FloorPlan that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FloorPlanFindUniqueOrThrowArgs} args - Arguments to find a FloorPlan
     * @example
     * // Get one FloorPlan
     * const floorPlan = await prisma.floorPlan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FloorPlanFindUniqueOrThrowArgs>(args: SelectSubset<T, FloorPlanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FloorPlanClient<$Result.GetResult<Prisma.$FloorPlanPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first FloorPlan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FloorPlanFindFirstArgs} args - Arguments to find a FloorPlan
     * @example
     * // Get one FloorPlan
     * const floorPlan = await prisma.floorPlan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FloorPlanFindFirstArgs>(args?: SelectSubset<T, FloorPlanFindFirstArgs<ExtArgs>>): Prisma__FloorPlanClient<$Result.GetResult<Prisma.$FloorPlanPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first FloorPlan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FloorPlanFindFirstOrThrowArgs} args - Arguments to find a FloorPlan
     * @example
     * // Get one FloorPlan
     * const floorPlan = await prisma.floorPlan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FloorPlanFindFirstOrThrowArgs>(args?: SelectSubset<T, FloorPlanFindFirstOrThrowArgs<ExtArgs>>): Prisma__FloorPlanClient<$Result.GetResult<Prisma.$FloorPlanPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more FloorPlans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FloorPlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FloorPlans
     * const floorPlans = await prisma.floorPlan.findMany()
     * 
     * // Get first 10 FloorPlans
     * const floorPlans = await prisma.floorPlan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const floorPlanWithIdOnly = await prisma.floorPlan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FloorPlanFindManyArgs>(args?: SelectSubset<T, FloorPlanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FloorPlanPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a FloorPlan.
     * @param {FloorPlanCreateArgs} args - Arguments to create a FloorPlan.
     * @example
     * // Create one FloorPlan
     * const FloorPlan = await prisma.floorPlan.create({
     *   data: {
     *     // ... data to create a FloorPlan
     *   }
     * })
     * 
     */
    create<T extends FloorPlanCreateArgs>(args: SelectSubset<T, FloorPlanCreateArgs<ExtArgs>>): Prisma__FloorPlanClient<$Result.GetResult<Prisma.$FloorPlanPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many FloorPlans.
     * @param {FloorPlanCreateManyArgs} args - Arguments to create many FloorPlans.
     * @example
     * // Create many FloorPlans
     * const floorPlan = await prisma.floorPlan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FloorPlanCreateManyArgs>(args?: SelectSubset<T, FloorPlanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FloorPlans and returns the data saved in the database.
     * @param {FloorPlanCreateManyAndReturnArgs} args - Arguments to create many FloorPlans.
     * @example
     * // Create many FloorPlans
     * const floorPlan = await prisma.floorPlan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FloorPlans and only return the `id`
     * const floorPlanWithIdOnly = await prisma.floorPlan.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FloorPlanCreateManyAndReturnArgs>(args?: SelectSubset<T, FloorPlanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FloorPlanPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a FloorPlan.
     * @param {FloorPlanDeleteArgs} args - Arguments to delete one FloorPlan.
     * @example
     * // Delete one FloorPlan
     * const FloorPlan = await prisma.floorPlan.delete({
     *   where: {
     *     // ... filter to delete one FloorPlan
     *   }
     * })
     * 
     */
    delete<T extends FloorPlanDeleteArgs>(args: SelectSubset<T, FloorPlanDeleteArgs<ExtArgs>>): Prisma__FloorPlanClient<$Result.GetResult<Prisma.$FloorPlanPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one FloorPlan.
     * @param {FloorPlanUpdateArgs} args - Arguments to update one FloorPlan.
     * @example
     * // Update one FloorPlan
     * const floorPlan = await prisma.floorPlan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FloorPlanUpdateArgs>(args: SelectSubset<T, FloorPlanUpdateArgs<ExtArgs>>): Prisma__FloorPlanClient<$Result.GetResult<Prisma.$FloorPlanPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more FloorPlans.
     * @param {FloorPlanDeleteManyArgs} args - Arguments to filter FloorPlans to delete.
     * @example
     * // Delete a few FloorPlans
     * const { count } = await prisma.floorPlan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FloorPlanDeleteManyArgs>(args?: SelectSubset<T, FloorPlanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FloorPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FloorPlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FloorPlans
     * const floorPlan = await prisma.floorPlan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FloorPlanUpdateManyArgs>(args: SelectSubset<T, FloorPlanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FloorPlan.
     * @param {FloorPlanUpsertArgs} args - Arguments to update or create a FloorPlan.
     * @example
     * // Update or create a FloorPlan
     * const floorPlan = await prisma.floorPlan.upsert({
     *   create: {
     *     // ... data to create a FloorPlan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FloorPlan we want to update
     *   }
     * })
     */
    upsert<T extends FloorPlanUpsertArgs>(args: SelectSubset<T, FloorPlanUpsertArgs<ExtArgs>>): Prisma__FloorPlanClient<$Result.GetResult<Prisma.$FloorPlanPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of FloorPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FloorPlanCountArgs} args - Arguments to filter FloorPlans to count.
     * @example
     * // Count the number of FloorPlans
     * const count = await prisma.floorPlan.count({
     *   where: {
     *     // ... the filter for the FloorPlans we want to count
     *   }
     * })
    **/
    count<T extends FloorPlanCountArgs>(
      args?: Subset<T, FloorPlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FloorPlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FloorPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FloorPlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FloorPlanAggregateArgs>(args: Subset<T, FloorPlanAggregateArgs>): Prisma.PrismaPromise<GetFloorPlanAggregateType<T>>

    /**
     * Group by FloorPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FloorPlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FloorPlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FloorPlanGroupByArgs['orderBy'] }
        : { orderBy?: FloorPlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FloorPlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFloorPlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FloorPlan model
   */
  readonly fields: FloorPlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FloorPlan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FloorPlanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    nightclub<T extends NightclubDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NightclubDefaultArgs<ExtArgs>>): Prisma__NightclubClient<$Result.GetResult<Prisma.$NightclubPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    zones<T extends FloorPlan$zonesArgs<ExtArgs> = {}>(args?: Subset<T, FloorPlan$zonesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FloorPlan model
   */ 
  interface FloorPlanFieldRefs {
    readonly id: FieldRef<"FloorPlan", 'String'>
    readonly name: FieldRef<"FloorPlan", 'String'>
    readonly imageUrl: FieldRef<"FloorPlan", 'String'>
    readonly nightclubId: FieldRef<"FloorPlan", 'String'>
    readonly createdAt: FieldRef<"FloorPlan", 'DateTime'>
    readonly updatedAt: FieldRef<"FloorPlan", 'DateTime'>
    readonly metadata: FieldRef<"FloorPlan", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * FloorPlan findUnique
   */
  export type FloorPlanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FloorPlan
     */
    select?: FloorPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FloorPlanInclude<ExtArgs> | null
    /**
     * Filter, which FloorPlan to fetch.
     */
    where: FloorPlanWhereUniqueInput
  }

  /**
   * FloorPlan findUniqueOrThrow
   */
  export type FloorPlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FloorPlan
     */
    select?: FloorPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FloorPlanInclude<ExtArgs> | null
    /**
     * Filter, which FloorPlan to fetch.
     */
    where: FloorPlanWhereUniqueInput
  }

  /**
   * FloorPlan findFirst
   */
  export type FloorPlanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FloorPlan
     */
    select?: FloorPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FloorPlanInclude<ExtArgs> | null
    /**
     * Filter, which FloorPlan to fetch.
     */
    where?: FloorPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FloorPlans to fetch.
     */
    orderBy?: FloorPlanOrderByWithRelationInput | FloorPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FloorPlans.
     */
    cursor?: FloorPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FloorPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FloorPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FloorPlans.
     */
    distinct?: FloorPlanScalarFieldEnum | FloorPlanScalarFieldEnum[]
  }

  /**
   * FloorPlan findFirstOrThrow
   */
  export type FloorPlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FloorPlan
     */
    select?: FloorPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FloorPlanInclude<ExtArgs> | null
    /**
     * Filter, which FloorPlan to fetch.
     */
    where?: FloorPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FloorPlans to fetch.
     */
    orderBy?: FloorPlanOrderByWithRelationInput | FloorPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FloorPlans.
     */
    cursor?: FloorPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FloorPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FloorPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FloorPlans.
     */
    distinct?: FloorPlanScalarFieldEnum | FloorPlanScalarFieldEnum[]
  }

  /**
   * FloorPlan findMany
   */
  export type FloorPlanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FloorPlan
     */
    select?: FloorPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FloorPlanInclude<ExtArgs> | null
    /**
     * Filter, which FloorPlans to fetch.
     */
    where?: FloorPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FloorPlans to fetch.
     */
    orderBy?: FloorPlanOrderByWithRelationInput | FloorPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FloorPlans.
     */
    cursor?: FloorPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FloorPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FloorPlans.
     */
    skip?: number
    distinct?: FloorPlanScalarFieldEnum | FloorPlanScalarFieldEnum[]
  }

  /**
   * FloorPlan create
   */
  export type FloorPlanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FloorPlan
     */
    select?: FloorPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FloorPlanInclude<ExtArgs> | null
    /**
     * The data needed to create a FloorPlan.
     */
    data: XOR<FloorPlanCreateInput, FloorPlanUncheckedCreateInput>
  }

  /**
   * FloorPlan createMany
   */
  export type FloorPlanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FloorPlans.
     */
    data: FloorPlanCreateManyInput | FloorPlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FloorPlan createManyAndReturn
   */
  export type FloorPlanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FloorPlan
     */
    select?: FloorPlanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many FloorPlans.
     */
    data: FloorPlanCreateManyInput | FloorPlanCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FloorPlanIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FloorPlan update
   */
  export type FloorPlanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FloorPlan
     */
    select?: FloorPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FloorPlanInclude<ExtArgs> | null
    /**
     * The data needed to update a FloorPlan.
     */
    data: XOR<FloorPlanUpdateInput, FloorPlanUncheckedUpdateInput>
    /**
     * Choose, which FloorPlan to update.
     */
    where: FloorPlanWhereUniqueInput
  }

  /**
   * FloorPlan updateMany
   */
  export type FloorPlanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FloorPlans.
     */
    data: XOR<FloorPlanUpdateManyMutationInput, FloorPlanUncheckedUpdateManyInput>
    /**
     * Filter which FloorPlans to update
     */
    where?: FloorPlanWhereInput
  }

  /**
   * FloorPlan upsert
   */
  export type FloorPlanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FloorPlan
     */
    select?: FloorPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FloorPlanInclude<ExtArgs> | null
    /**
     * The filter to search for the FloorPlan to update in case it exists.
     */
    where: FloorPlanWhereUniqueInput
    /**
     * In case the FloorPlan found by the `where` argument doesn't exist, create a new FloorPlan with this data.
     */
    create: XOR<FloorPlanCreateInput, FloorPlanUncheckedCreateInput>
    /**
     * In case the FloorPlan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FloorPlanUpdateInput, FloorPlanUncheckedUpdateInput>
  }

  /**
   * FloorPlan delete
   */
  export type FloorPlanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FloorPlan
     */
    select?: FloorPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FloorPlanInclude<ExtArgs> | null
    /**
     * Filter which FloorPlan to delete.
     */
    where: FloorPlanWhereUniqueInput
  }

  /**
   * FloorPlan deleteMany
   */
  export type FloorPlanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FloorPlans to delete
     */
    where?: FloorPlanWhereInput
  }

  /**
   * FloorPlan.zones
   */
  export type FloorPlan$zonesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    where?: ZoneWhereInput
    orderBy?: ZoneOrderByWithRelationInput | ZoneOrderByWithRelationInput[]
    cursor?: ZoneWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ZoneScalarFieldEnum | ZoneScalarFieldEnum[]
  }

  /**
   * FloorPlan without action
   */
  export type FloorPlanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FloorPlan
     */
    select?: FloorPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FloorPlanInclude<ExtArgs> | null
  }


  /**
   * Model Zone
   */

  export type AggregateZone = {
    _count: ZoneCountAggregateOutputType | null
    _avg: ZoneAvgAggregateOutputType | null
    _sum: ZoneSumAggregateOutputType | null
    _min: ZoneMinAggregateOutputType | null
    _max: ZoneMaxAggregateOutputType | null
  }

  export type ZoneAvgAggregateOutputType = {
    capacity: number | null
  }

  export type ZoneSumAggregateOutputType = {
    capacity: number | null
  }

  export type ZoneMinAggregateOutputType = {
    id: string | null
    name: string | null
    capacity: number | null
    floorPlanId: string | null
    nightclubId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ZoneMaxAggregateOutputType = {
    id: string | null
    name: string | null
    capacity: number | null
    floorPlanId: string | null
    nightclubId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ZoneCountAggregateOutputType = {
    id: number
    name: number
    coordinates: number
    capacity: number
    floorPlanId: number
    nightclubId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ZoneAvgAggregateInputType = {
    capacity?: true
  }

  export type ZoneSumAggregateInputType = {
    capacity?: true
  }

  export type ZoneMinAggregateInputType = {
    id?: true
    name?: true
    capacity?: true
    floorPlanId?: true
    nightclubId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ZoneMaxAggregateInputType = {
    id?: true
    name?: true
    capacity?: true
    floorPlanId?: true
    nightclubId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ZoneCountAggregateInputType = {
    id?: true
    name?: true
    coordinates?: true
    capacity?: true
    floorPlanId?: true
    nightclubId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ZoneAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Zone to aggregate.
     */
    where?: ZoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Zones to fetch.
     */
    orderBy?: ZoneOrderByWithRelationInput | ZoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ZoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Zones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Zones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Zones
    **/
    _count?: true | ZoneCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ZoneAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ZoneSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ZoneMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ZoneMaxAggregateInputType
  }

  export type GetZoneAggregateType<T extends ZoneAggregateArgs> = {
        [P in keyof T & keyof AggregateZone]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateZone[P]>
      : GetScalarType<T[P], AggregateZone[P]>
  }




  export type ZoneGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ZoneWhereInput
    orderBy?: ZoneOrderByWithAggregationInput | ZoneOrderByWithAggregationInput[]
    by: ZoneScalarFieldEnum[] | ZoneScalarFieldEnum
    having?: ZoneScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ZoneCountAggregateInputType | true
    _avg?: ZoneAvgAggregateInputType
    _sum?: ZoneSumAggregateInputType
    _min?: ZoneMinAggregateInputType
    _max?: ZoneMaxAggregateInputType
  }

  export type ZoneGroupByOutputType = {
    id: string
    name: string
    coordinates: JsonValue
    capacity: number
    floorPlanId: string
    nightclubId: string
    createdAt: Date
    updatedAt: Date
    _count: ZoneCountAggregateOutputType | null
    _avg: ZoneAvgAggregateOutputType | null
    _sum: ZoneSumAggregateOutputType | null
    _min: ZoneMinAggregateOutputType | null
    _max: ZoneMaxAggregateOutputType | null
  }

  type GetZoneGroupByPayload<T extends ZoneGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ZoneGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ZoneGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ZoneGroupByOutputType[P]>
            : GetScalarType<T[P], ZoneGroupByOutputType[P]>
        }
      >
    >


  export type ZoneSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    coordinates?: boolean
    capacity?: boolean
    floorPlanId?: boolean
    nightclubId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    floorPlan?: boolean | FloorPlanDefaultArgs<ExtArgs>
    nightclub?: boolean | NightclubDefaultArgs<ExtArgs>
    alerts?: boolean | Zone$alertsArgs<ExtArgs>
    emergencies?: boolean | Zone$emergenciesArgs<ExtArgs>
    sensors?: boolean | Zone$sensorsArgs<ExtArgs>
    anomalies?: boolean | Zone$anomaliesArgs<ExtArgs>
    behaviors?: boolean | Zone$behaviorsArgs<ExtArgs>
    realTimeMetrics?: boolean | Zone$realTimeMetricsArgs<ExtArgs>
    predictions?: boolean | Zone$predictionsArgs<ExtArgs>
    _count?: boolean | ZoneCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["zone"]>

  export type ZoneSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    coordinates?: boolean
    capacity?: boolean
    floorPlanId?: boolean
    nightclubId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    floorPlan?: boolean | FloorPlanDefaultArgs<ExtArgs>
    nightclub?: boolean | NightclubDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["zone"]>

  export type ZoneSelectScalar = {
    id?: boolean
    name?: boolean
    coordinates?: boolean
    capacity?: boolean
    floorPlanId?: boolean
    nightclubId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ZoneInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    floorPlan?: boolean | FloorPlanDefaultArgs<ExtArgs>
    nightclub?: boolean | NightclubDefaultArgs<ExtArgs>
    alerts?: boolean | Zone$alertsArgs<ExtArgs>
    emergencies?: boolean | Zone$emergenciesArgs<ExtArgs>
    sensors?: boolean | Zone$sensorsArgs<ExtArgs>
    anomalies?: boolean | Zone$anomaliesArgs<ExtArgs>
    behaviors?: boolean | Zone$behaviorsArgs<ExtArgs>
    realTimeMetrics?: boolean | Zone$realTimeMetricsArgs<ExtArgs>
    predictions?: boolean | Zone$predictionsArgs<ExtArgs>
    _count?: boolean | ZoneCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ZoneIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    floorPlan?: boolean | FloorPlanDefaultArgs<ExtArgs>
    nightclub?: boolean | NightclubDefaultArgs<ExtArgs>
  }

  export type $ZonePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Zone"
    objects: {
      floorPlan: Prisma.$FloorPlanPayload<ExtArgs>
      nightclub: Prisma.$NightclubPayload<ExtArgs>
      alerts: Prisma.$AlertPayload<ExtArgs>[]
      emergencies: Prisma.$EmergencyPayload<ExtArgs>[]
      sensors: Prisma.$SensorPayload<ExtArgs>[]
      anomalies: Prisma.$AnomalyPayload<ExtArgs>[]
      behaviors: Prisma.$BehaviorAnalysisPayload<ExtArgs>[]
      realTimeMetrics: Prisma.$RealTimeMetricPayload<ExtArgs>[]
      predictions: Prisma.$PredictionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      coordinates: Prisma.JsonValue
      capacity: number
      floorPlanId: string
      nightclubId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["zone"]>
    composites: {}
  }

  type ZoneGetPayload<S extends boolean | null | undefined | ZoneDefaultArgs> = $Result.GetResult<Prisma.$ZonePayload, S>

  type ZoneCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ZoneFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ZoneCountAggregateInputType | true
    }

  export interface ZoneDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Zone'], meta: { name: 'Zone' } }
    /**
     * Find zero or one Zone that matches the filter.
     * @param {ZoneFindUniqueArgs} args - Arguments to find a Zone
     * @example
     * // Get one Zone
     * const zone = await prisma.zone.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ZoneFindUniqueArgs>(args: SelectSubset<T, ZoneFindUniqueArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Zone that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ZoneFindUniqueOrThrowArgs} args - Arguments to find a Zone
     * @example
     * // Get one Zone
     * const zone = await prisma.zone.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ZoneFindUniqueOrThrowArgs>(args: SelectSubset<T, ZoneFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Zone that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneFindFirstArgs} args - Arguments to find a Zone
     * @example
     * // Get one Zone
     * const zone = await prisma.zone.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ZoneFindFirstArgs>(args?: SelectSubset<T, ZoneFindFirstArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Zone that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneFindFirstOrThrowArgs} args - Arguments to find a Zone
     * @example
     * // Get one Zone
     * const zone = await prisma.zone.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ZoneFindFirstOrThrowArgs>(args?: SelectSubset<T, ZoneFindFirstOrThrowArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Zones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Zones
     * const zones = await prisma.zone.findMany()
     * 
     * // Get first 10 Zones
     * const zones = await prisma.zone.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const zoneWithIdOnly = await prisma.zone.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ZoneFindManyArgs>(args?: SelectSubset<T, ZoneFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Zone.
     * @param {ZoneCreateArgs} args - Arguments to create a Zone.
     * @example
     * // Create one Zone
     * const Zone = await prisma.zone.create({
     *   data: {
     *     // ... data to create a Zone
     *   }
     * })
     * 
     */
    create<T extends ZoneCreateArgs>(args: SelectSubset<T, ZoneCreateArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Zones.
     * @param {ZoneCreateManyArgs} args - Arguments to create many Zones.
     * @example
     * // Create many Zones
     * const zone = await prisma.zone.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ZoneCreateManyArgs>(args?: SelectSubset<T, ZoneCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Zones and returns the data saved in the database.
     * @param {ZoneCreateManyAndReturnArgs} args - Arguments to create many Zones.
     * @example
     * // Create many Zones
     * const zone = await prisma.zone.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Zones and only return the `id`
     * const zoneWithIdOnly = await prisma.zone.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ZoneCreateManyAndReturnArgs>(args?: SelectSubset<T, ZoneCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Zone.
     * @param {ZoneDeleteArgs} args - Arguments to delete one Zone.
     * @example
     * // Delete one Zone
     * const Zone = await prisma.zone.delete({
     *   where: {
     *     // ... filter to delete one Zone
     *   }
     * })
     * 
     */
    delete<T extends ZoneDeleteArgs>(args: SelectSubset<T, ZoneDeleteArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Zone.
     * @param {ZoneUpdateArgs} args - Arguments to update one Zone.
     * @example
     * // Update one Zone
     * const zone = await prisma.zone.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ZoneUpdateArgs>(args: SelectSubset<T, ZoneUpdateArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Zones.
     * @param {ZoneDeleteManyArgs} args - Arguments to filter Zones to delete.
     * @example
     * // Delete a few Zones
     * const { count } = await prisma.zone.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ZoneDeleteManyArgs>(args?: SelectSubset<T, ZoneDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Zones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Zones
     * const zone = await prisma.zone.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ZoneUpdateManyArgs>(args: SelectSubset<T, ZoneUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Zone.
     * @param {ZoneUpsertArgs} args - Arguments to update or create a Zone.
     * @example
     * // Update or create a Zone
     * const zone = await prisma.zone.upsert({
     *   create: {
     *     // ... data to create a Zone
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Zone we want to update
     *   }
     * })
     */
    upsert<T extends ZoneUpsertArgs>(args: SelectSubset<T, ZoneUpsertArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Zones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneCountArgs} args - Arguments to filter Zones to count.
     * @example
     * // Count the number of Zones
     * const count = await prisma.zone.count({
     *   where: {
     *     // ... the filter for the Zones we want to count
     *   }
     * })
    **/
    count<T extends ZoneCountArgs>(
      args?: Subset<T, ZoneCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ZoneCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Zone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ZoneAggregateArgs>(args: Subset<T, ZoneAggregateArgs>): Prisma.PrismaPromise<GetZoneAggregateType<T>>

    /**
     * Group by Zone.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZoneGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ZoneGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ZoneGroupByArgs['orderBy'] }
        : { orderBy?: ZoneGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ZoneGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetZoneGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Zone model
   */
  readonly fields: ZoneFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Zone.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ZoneClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    floorPlan<T extends FloorPlanDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FloorPlanDefaultArgs<ExtArgs>>): Prisma__FloorPlanClient<$Result.GetResult<Prisma.$FloorPlanPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    nightclub<T extends NightclubDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NightclubDefaultArgs<ExtArgs>>): Prisma__NightclubClient<$Result.GetResult<Prisma.$NightclubPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    alerts<T extends Zone$alertsArgs<ExtArgs> = {}>(args?: Subset<T, Zone$alertsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findMany"> | Null>
    emergencies<T extends Zone$emergenciesArgs<ExtArgs> = {}>(args?: Subset<T, Zone$emergenciesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmergencyPayload<ExtArgs>, T, "findMany"> | Null>
    sensors<T extends Zone$sensorsArgs<ExtArgs> = {}>(args?: Subset<T, Zone$sensorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SensorPayload<ExtArgs>, T, "findMany"> | Null>
    anomalies<T extends Zone$anomaliesArgs<ExtArgs> = {}>(args?: Subset<T, Zone$anomaliesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnomalyPayload<ExtArgs>, T, "findMany"> | Null>
    behaviors<T extends Zone$behaviorsArgs<ExtArgs> = {}>(args?: Subset<T, Zone$behaviorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BehaviorAnalysisPayload<ExtArgs>, T, "findMany"> | Null>
    realTimeMetrics<T extends Zone$realTimeMetricsArgs<ExtArgs> = {}>(args?: Subset<T, Zone$realTimeMetricsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RealTimeMetricPayload<ExtArgs>, T, "findMany"> | Null>
    predictions<T extends Zone$predictionsArgs<ExtArgs> = {}>(args?: Subset<T, Zone$predictionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PredictionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Zone model
   */ 
  interface ZoneFieldRefs {
    readonly id: FieldRef<"Zone", 'String'>
    readonly name: FieldRef<"Zone", 'String'>
    readonly coordinates: FieldRef<"Zone", 'Json'>
    readonly capacity: FieldRef<"Zone", 'Int'>
    readonly floorPlanId: FieldRef<"Zone", 'String'>
    readonly nightclubId: FieldRef<"Zone", 'String'>
    readonly createdAt: FieldRef<"Zone", 'DateTime'>
    readonly updatedAt: FieldRef<"Zone", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Zone findUnique
   */
  export type ZoneFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * Filter, which Zone to fetch.
     */
    where: ZoneWhereUniqueInput
  }

  /**
   * Zone findUniqueOrThrow
   */
  export type ZoneFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * Filter, which Zone to fetch.
     */
    where: ZoneWhereUniqueInput
  }

  /**
   * Zone findFirst
   */
  export type ZoneFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * Filter, which Zone to fetch.
     */
    where?: ZoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Zones to fetch.
     */
    orderBy?: ZoneOrderByWithRelationInput | ZoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Zones.
     */
    cursor?: ZoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Zones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Zones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Zones.
     */
    distinct?: ZoneScalarFieldEnum | ZoneScalarFieldEnum[]
  }

  /**
   * Zone findFirstOrThrow
   */
  export type ZoneFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * Filter, which Zone to fetch.
     */
    where?: ZoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Zones to fetch.
     */
    orderBy?: ZoneOrderByWithRelationInput | ZoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Zones.
     */
    cursor?: ZoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Zones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Zones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Zones.
     */
    distinct?: ZoneScalarFieldEnum | ZoneScalarFieldEnum[]
  }

  /**
   * Zone findMany
   */
  export type ZoneFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * Filter, which Zones to fetch.
     */
    where?: ZoneWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Zones to fetch.
     */
    orderBy?: ZoneOrderByWithRelationInput | ZoneOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Zones.
     */
    cursor?: ZoneWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Zones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Zones.
     */
    skip?: number
    distinct?: ZoneScalarFieldEnum | ZoneScalarFieldEnum[]
  }

  /**
   * Zone create
   */
  export type ZoneCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * The data needed to create a Zone.
     */
    data: XOR<ZoneCreateInput, ZoneUncheckedCreateInput>
  }

  /**
   * Zone createMany
   */
  export type ZoneCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Zones.
     */
    data: ZoneCreateManyInput | ZoneCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Zone createManyAndReturn
   */
  export type ZoneCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Zones.
     */
    data: ZoneCreateManyInput | ZoneCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Zone update
   */
  export type ZoneUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * The data needed to update a Zone.
     */
    data: XOR<ZoneUpdateInput, ZoneUncheckedUpdateInput>
    /**
     * Choose, which Zone to update.
     */
    where: ZoneWhereUniqueInput
  }

  /**
   * Zone updateMany
   */
  export type ZoneUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Zones.
     */
    data: XOR<ZoneUpdateManyMutationInput, ZoneUncheckedUpdateManyInput>
    /**
     * Filter which Zones to update
     */
    where?: ZoneWhereInput
  }

  /**
   * Zone upsert
   */
  export type ZoneUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * The filter to search for the Zone to update in case it exists.
     */
    where: ZoneWhereUniqueInput
    /**
     * In case the Zone found by the `where` argument doesn't exist, create a new Zone with this data.
     */
    create: XOR<ZoneCreateInput, ZoneUncheckedCreateInput>
    /**
     * In case the Zone was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ZoneUpdateInput, ZoneUncheckedUpdateInput>
  }

  /**
   * Zone delete
   */
  export type ZoneDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    /**
     * Filter which Zone to delete.
     */
    where: ZoneWhereUniqueInput
  }

  /**
   * Zone deleteMany
   */
  export type ZoneDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Zones to delete
     */
    where?: ZoneWhereInput
  }

  /**
   * Zone.alerts
   */
  export type Zone$alertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    where?: AlertWhereInput
    orderBy?: AlertOrderByWithRelationInput | AlertOrderByWithRelationInput[]
    cursor?: AlertWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AlertScalarFieldEnum | AlertScalarFieldEnum[]
  }

  /**
   * Zone.emergencies
   */
  export type Zone$emergenciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emergency
     */
    select?: EmergencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyInclude<ExtArgs> | null
    where?: EmergencyWhereInput
    orderBy?: EmergencyOrderByWithRelationInput | EmergencyOrderByWithRelationInput[]
    cursor?: EmergencyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmergencyScalarFieldEnum | EmergencyScalarFieldEnum[]
  }

  /**
   * Zone.sensors
   */
  export type Zone$sensorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sensor
     */
    select?: SensorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SensorInclude<ExtArgs> | null
    where?: SensorWhereInput
    orderBy?: SensorOrderByWithRelationInput | SensorOrderByWithRelationInput[]
    cursor?: SensorWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SensorScalarFieldEnum | SensorScalarFieldEnum[]
  }

  /**
   * Zone.anomalies
   */
  export type Zone$anomaliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Anomaly
     */
    select?: AnomalySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnomalyInclude<ExtArgs> | null
    where?: AnomalyWhereInput
    orderBy?: AnomalyOrderByWithRelationInput | AnomalyOrderByWithRelationInput[]
    cursor?: AnomalyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnomalyScalarFieldEnum | AnomalyScalarFieldEnum[]
  }

  /**
   * Zone.behaviors
   */
  export type Zone$behaviorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BehaviorAnalysis
     */
    select?: BehaviorAnalysisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BehaviorAnalysisInclude<ExtArgs> | null
    where?: BehaviorAnalysisWhereInput
    orderBy?: BehaviorAnalysisOrderByWithRelationInput | BehaviorAnalysisOrderByWithRelationInput[]
    cursor?: BehaviorAnalysisWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BehaviorAnalysisScalarFieldEnum | BehaviorAnalysisScalarFieldEnum[]
  }

  /**
   * Zone.realTimeMetrics
   */
  export type Zone$realTimeMetricsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RealTimeMetric
     */
    select?: RealTimeMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RealTimeMetricInclude<ExtArgs> | null
    where?: RealTimeMetricWhereInput
    orderBy?: RealTimeMetricOrderByWithRelationInput | RealTimeMetricOrderByWithRelationInput[]
    cursor?: RealTimeMetricWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RealTimeMetricScalarFieldEnum | RealTimeMetricScalarFieldEnum[]
  }

  /**
   * Zone.predictions
   */
  export type Zone$predictionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prediction
     */
    select?: PredictionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PredictionInclude<ExtArgs> | null
    where?: PredictionWhereInput
    orderBy?: PredictionOrderByWithRelationInput | PredictionOrderByWithRelationInput[]
    cursor?: PredictionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PredictionScalarFieldEnum | PredictionScalarFieldEnum[]
  }

  /**
   * Zone without action
   */
  export type ZoneDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
  }


  /**
   * Model Bracelet
   */

  export type AggregateBracelet = {
    _count: BraceletCountAggregateOutputType | null
    _avg: BraceletAvgAggregateOutputType | null
    _sum: BraceletSumAggregateOutputType | null
    _min: BraceletMinAggregateOutputType | null
    _max: BraceletMaxAggregateOutputType | null
  }

  export type BraceletAvgAggregateOutputType = {
    batteryLevel: number | null
  }

  export type BraceletSumAggregateOutputType = {
    batteryLevel: number | null
  }

  export type BraceletMinAggregateOutputType = {
    id: string | null
    deviceId: string | null
    batteryLevel: number | null
    status: $Enums.BraceletStatus | null
    lastSeen: Date | null
    nightclubId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BraceletMaxAggregateOutputType = {
    id: string | null
    deviceId: string | null
    batteryLevel: number | null
    status: $Enums.BraceletStatus | null
    lastSeen: Date | null
    nightclubId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BraceletCountAggregateOutputType = {
    id: number
    deviceId: number
    batteryLevel: number
    status: number
    lastSeen: number
    nightclubId: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BraceletAvgAggregateInputType = {
    batteryLevel?: true
  }

  export type BraceletSumAggregateInputType = {
    batteryLevel?: true
  }

  export type BraceletMinAggregateInputType = {
    id?: true
    deviceId?: true
    batteryLevel?: true
    status?: true
    lastSeen?: true
    nightclubId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BraceletMaxAggregateInputType = {
    id?: true
    deviceId?: true
    batteryLevel?: true
    status?: true
    lastSeen?: true
    nightclubId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BraceletCountAggregateInputType = {
    id?: true
    deviceId?: true
    batteryLevel?: true
    status?: true
    lastSeen?: true
    nightclubId?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BraceletAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bracelet to aggregate.
     */
    where?: BraceletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bracelets to fetch.
     */
    orderBy?: BraceletOrderByWithRelationInput | BraceletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BraceletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bracelets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bracelets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bracelets
    **/
    _count?: true | BraceletCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BraceletAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BraceletSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BraceletMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BraceletMaxAggregateInputType
  }

  export type GetBraceletAggregateType<T extends BraceletAggregateArgs> = {
        [P in keyof T & keyof AggregateBracelet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBracelet[P]>
      : GetScalarType<T[P], AggregateBracelet[P]>
  }




  export type BraceletGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BraceletWhereInput
    orderBy?: BraceletOrderByWithAggregationInput | BraceletOrderByWithAggregationInput[]
    by: BraceletScalarFieldEnum[] | BraceletScalarFieldEnum
    having?: BraceletScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BraceletCountAggregateInputType | true
    _avg?: BraceletAvgAggregateInputType
    _sum?: BraceletSumAggregateInputType
    _min?: BraceletMinAggregateInputType
    _max?: BraceletMaxAggregateInputType
  }

  export type BraceletGroupByOutputType = {
    id: string
    deviceId: string
    batteryLevel: number | null
    status: $Enums.BraceletStatus
    lastSeen: Date | null
    nightclubId: string
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: BraceletCountAggregateOutputType | null
    _avg: BraceletAvgAggregateOutputType | null
    _sum: BraceletSumAggregateOutputType | null
    _min: BraceletMinAggregateOutputType | null
    _max: BraceletMaxAggregateOutputType | null
  }

  type GetBraceletGroupByPayload<T extends BraceletGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BraceletGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BraceletGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BraceletGroupByOutputType[P]>
            : GetScalarType<T[P], BraceletGroupByOutputType[P]>
        }
      >
    >


  export type BraceletSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deviceId?: boolean
    batteryLevel?: boolean
    status?: boolean
    lastSeen?: boolean
    nightclubId?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    nightclub?: boolean | NightclubDefaultArgs<ExtArgs>
    alerts?: boolean | Bracelet$alertsArgs<ExtArgs>
    emergencies?: boolean | Bracelet$emergenciesArgs<ExtArgs>
    _count?: boolean | BraceletCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bracelet"]>

  export type BraceletSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    deviceId?: boolean
    batteryLevel?: boolean
    status?: boolean
    lastSeen?: boolean
    nightclubId?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    nightclub?: boolean | NightclubDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bracelet"]>

  export type BraceletSelectScalar = {
    id?: boolean
    deviceId?: boolean
    batteryLevel?: boolean
    status?: boolean
    lastSeen?: boolean
    nightclubId?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BraceletInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    nightclub?: boolean | NightclubDefaultArgs<ExtArgs>
    alerts?: boolean | Bracelet$alertsArgs<ExtArgs>
    emergencies?: boolean | Bracelet$emergenciesArgs<ExtArgs>
    _count?: boolean | BraceletCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BraceletIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    nightclub?: boolean | NightclubDefaultArgs<ExtArgs>
  }

  export type $BraceletPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Bracelet"
    objects: {
      nightclub: Prisma.$NightclubPayload<ExtArgs>
      alerts: Prisma.$AlertPayload<ExtArgs>[]
      emergencies: Prisma.$EmergencyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      deviceId: string
      batteryLevel: number | null
      status: $Enums.BraceletStatus
      lastSeen: Date | null
      nightclubId: string
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["bracelet"]>
    composites: {}
  }

  type BraceletGetPayload<S extends boolean | null | undefined | BraceletDefaultArgs> = $Result.GetResult<Prisma.$BraceletPayload, S>

  type BraceletCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BraceletFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BraceletCountAggregateInputType | true
    }

  export interface BraceletDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Bracelet'], meta: { name: 'Bracelet' } }
    /**
     * Find zero or one Bracelet that matches the filter.
     * @param {BraceletFindUniqueArgs} args - Arguments to find a Bracelet
     * @example
     * // Get one Bracelet
     * const bracelet = await prisma.bracelet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BraceletFindUniqueArgs>(args: SelectSubset<T, BraceletFindUniqueArgs<ExtArgs>>): Prisma__BraceletClient<$Result.GetResult<Prisma.$BraceletPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Bracelet that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BraceletFindUniqueOrThrowArgs} args - Arguments to find a Bracelet
     * @example
     * // Get one Bracelet
     * const bracelet = await prisma.bracelet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BraceletFindUniqueOrThrowArgs>(args: SelectSubset<T, BraceletFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BraceletClient<$Result.GetResult<Prisma.$BraceletPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Bracelet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BraceletFindFirstArgs} args - Arguments to find a Bracelet
     * @example
     * // Get one Bracelet
     * const bracelet = await prisma.bracelet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BraceletFindFirstArgs>(args?: SelectSubset<T, BraceletFindFirstArgs<ExtArgs>>): Prisma__BraceletClient<$Result.GetResult<Prisma.$BraceletPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Bracelet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BraceletFindFirstOrThrowArgs} args - Arguments to find a Bracelet
     * @example
     * // Get one Bracelet
     * const bracelet = await prisma.bracelet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BraceletFindFirstOrThrowArgs>(args?: SelectSubset<T, BraceletFindFirstOrThrowArgs<ExtArgs>>): Prisma__BraceletClient<$Result.GetResult<Prisma.$BraceletPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Bracelets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BraceletFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bracelets
     * const bracelets = await prisma.bracelet.findMany()
     * 
     * // Get first 10 Bracelets
     * const bracelets = await prisma.bracelet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const braceletWithIdOnly = await prisma.bracelet.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BraceletFindManyArgs>(args?: SelectSubset<T, BraceletFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BraceletPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Bracelet.
     * @param {BraceletCreateArgs} args - Arguments to create a Bracelet.
     * @example
     * // Create one Bracelet
     * const Bracelet = await prisma.bracelet.create({
     *   data: {
     *     // ... data to create a Bracelet
     *   }
     * })
     * 
     */
    create<T extends BraceletCreateArgs>(args: SelectSubset<T, BraceletCreateArgs<ExtArgs>>): Prisma__BraceletClient<$Result.GetResult<Prisma.$BraceletPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Bracelets.
     * @param {BraceletCreateManyArgs} args - Arguments to create many Bracelets.
     * @example
     * // Create many Bracelets
     * const bracelet = await prisma.bracelet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BraceletCreateManyArgs>(args?: SelectSubset<T, BraceletCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Bracelets and returns the data saved in the database.
     * @param {BraceletCreateManyAndReturnArgs} args - Arguments to create many Bracelets.
     * @example
     * // Create many Bracelets
     * const bracelet = await prisma.bracelet.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Bracelets and only return the `id`
     * const braceletWithIdOnly = await prisma.bracelet.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BraceletCreateManyAndReturnArgs>(args?: SelectSubset<T, BraceletCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BraceletPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Bracelet.
     * @param {BraceletDeleteArgs} args - Arguments to delete one Bracelet.
     * @example
     * // Delete one Bracelet
     * const Bracelet = await prisma.bracelet.delete({
     *   where: {
     *     // ... filter to delete one Bracelet
     *   }
     * })
     * 
     */
    delete<T extends BraceletDeleteArgs>(args: SelectSubset<T, BraceletDeleteArgs<ExtArgs>>): Prisma__BraceletClient<$Result.GetResult<Prisma.$BraceletPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Bracelet.
     * @param {BraceletUpdateArgs} args - Arguments to update one Bracelet.
     * @example
     * // Update one Bracelet
     * const bracelet = await prisma.bracelet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BraceletUpdateArgs>(args: SelectSubset<T, BraceletUpdateArgs<ExtArgs>>): Prisma__BraceletClient<$Result.GetResult<Prisma.$BraceletPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Bracelets.
     * @param {BraceletDeleteManyArgs} args - Arguments to filter Bracelets to delete.
     * @example
     * // Delete a few Bracelets
     * const { count } = await prisma.bracelet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BraceletDeleteManyArgs>(args?: SelectSubset<T, BraceletDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bracelets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BraceletUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bracelets
     * const bracelet = await prisma.bracelet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BraceletUpdateManyArgs>(args: SelectSubset<T, BraceletUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Bracelet.
     * @param {BraceletUpsertArgs} args - Arguments to update or create a Bracelet.
     * @example
     * // Update or create a Bracelet
     * const bracelet = await prisma.bracelet.upsert({
     *   create: {
     *     // ... data to create a Bracelet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bracelet we want to update
     *   }
     * })
     */
    upsert<T extends BraceletUpsertArgs>(args: SelectSubset<T, BraceletUpsertArgs<ExtArgs>>): Prisma__BraceletClient<$Result.GetResult<Prisma.$BraceletPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Bracelets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BraceletCountArgs} args - Arguments to filter Bracelets to count.
     * @example
     * // Count the number of Bracelets
     * const count = await prisma.bracelet.count({
     *   where: {
     *     // ... the filter for the Bracelets we want to count
     *   }
     * })
    **/
    count<T extends BraceletCountArgs>(
      args?: Subset<T, BraceletCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BraceletCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bracelet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BraceletAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BraceletAggregateArgs>(args: Subset<T, BraceletAggregateArgs>): Prisma.PrismaPromise<GetBraceletAggregateType<T>>

    /**
     * Group by Bracelet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BraceletGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BraceletGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BraceletGroupByArgs['orderBy'] }
        : { orderBy?: BraceletGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BraceletGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBraceletGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Bracelet model
   */
  readonly fields: BraceletFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Bracelet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BraceletClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    nightclub<T extends NightclubDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NightclubDefaultArgs<ExtArgs>>): Prisma__NightclubClient<$Result.GetResult<Prisma.$NightclubPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    alerts<T extends Bracelet$alertsArgs<ExtArgs> = {}>(args?: Subset<T, Bracelet$alertsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findMany"> | Null>
    emergencies<T extends Bracelet$emergenciesArgs<ExtArgs> = {}>(args?: Subset<T, Bracelet$emergenciesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmergencyPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Bracelet model
   */ 
  interface BraceletFieldRefs {
    readonly id: FieldRef<"Bracelet", 'String'>
    readonly deviceId: FieldRef<"Bracelet", 'String'>
    readonly batteryLevel: FieldRef<"Bracelet", 'Int'>
    readonly status: FieldRef<"Bracelet", 'BraceletStatus'>
    readonly lastSeen: FieldRef<"Bracelet", 'DateTime'>
    readonly nightclubId: FieldRef<"Bracelet", 'String'>
    readonly metadata: FieldRef<"Bracelet", 'Json'>
    readonly createdAt: FieldRef<"Bracelet", 'DateTime'>
    readonly updatedAt: FieldRef<"Bracelet", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Bracelet findUnique
   */
  export type BraceletFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bracelet
     */
    select?: BraceletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BraceletInclude<ExtArgs> | null
    /**
     * Filter, which Bracelet to fetch.
     */
    where: BraceletWhereUniqueInput
  }

  /**
   * Bracelet findUniqueOrThrow
   */
  export type BraceletFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bracelet
     */
    select?: BraceletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BraceletInclude<ExtArgs> | null
    /**
     * Filter, which Bracelet to fetch.
     */
    where: BraceletWhereUniqueInput
  }

  /**
   * Bracelet findFirst
   */
  export type BraceletFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bracelet
     */
    select?: BraceletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BraceletInclude<ExtArgs> | null
    /**
     * Filter, which Bracelet to fetch.
     */
    where?: BraceletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bracelets to fetch.
     */
    orderBy?: BraceletOrderByWithRelationInput | BraceletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bracelets.
     */
    cursor?: BraceletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bracelets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bracelets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bracelets.
     */
    distinct?: BraceletScalarFieldEnum | BraceletScalarFieldEnum[]
  }

  /**
   * Bracelet findFirstOrThrow
   */
  export type BraceletFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bracelet
     */
    select?: BraceletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BraceletInclude<ExtArgs> | null
    /**
     * Filter, which Bracelet to fetch.
     */
    where?: BraceletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bracelets to fetch.
     */
    orderBy?: BraceletOrderByWithRelationInput | BraceletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bracelets.
     */
    cursor?: BraceletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bracelets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bracelets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bracelets.
     */
    distinct?: BraceletScalarFieldEnum | BraceletScalarFieldEnum[]
  }

  /**
   * Bracelet findMany
   */
  export type BraceletFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bracelet
     */
    select?: BraceletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BraceletInclude<ExtArgs> | null
    /**
     * Filter, which Bracelets to fetch.
     */
    where?: BraceletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bracelets to fetch.
     */
    orderBy?: BraceletOrderByWithRelationInput | BraceletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bracelets.
     */
    cursor?: BraceletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bracelets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bracelets.
     */
    skip?: number
    distinct?: BraceletScalarFieldEnum | BraceletScalarFieldEnum[]
  }

  /**
   * Bracelet create
   */
  export type BraceletCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bracelet
     */
    select?: BraceletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BraceletInclude<ExtArgs> | null
    /**
     * The data needed to create a Bracelet.
     */
    data: XOR<BraceletCreateInput, BraceletUncheckedCreateInput>
  }

  /**
   * Bracelet createMany
   */
  export type BraceletCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bracelets.
     */
    data: BraceletCreateManyInput | BraceletCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Bracelet createManyAndReturn
   */
  export type BraceletCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bracelet
     */
    select?: BraceletSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Bracelets.
     */
    data: BraceletCreateManyInput | BraceletCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BraceletIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Bracelet update
   */
  export type BraceletUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bracelet
     */
    select?: BraceletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BraceletInclude<ExtArgs> | null
    /**
     * The data needed to update a Bracelet.
     */
    data: XOR<BraceletUpdateInput, BraceletUncheckedUpdateInput>
    /**
     * Choose, which Bracelet to update.
     */
    where: BraceletWhereUniqueInput
  }

  /**
   * Bracelet updateMany
   */
  export type BraceletUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bracelets.
     */
    data: XOR<BraceletUpdateManyMutationInput, BraceletUncheckedUpdateManyInput>
    /**
     * Filter which Bracelets to update
     */
    where?: BraceletWhereInput
  }

  /**
   * Bracelet upsert
   */
  export type BraceletUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bracelet
     */
    select?: BraceletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BraceletInclude<ExtArgs> | null
    /**
     * The filter to search for the Bracelet to update in case it exists.
     */
    where: BraceletWhereUniqueInput
    /**
     * In case the Bracelet found by the `where` argument doesn't exist, create a new Bracelet with this data.
     */
    create: XOR<BraceletCreateInput, BraceletUncheckedCreateInput>
    /**
     * In case the Bracelet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BraceletUpdateInput, BraceletUncheckedUpdateInput>
  }

  /**
   * Bracelet delete
   */
  export type BraceletDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bracelet
     */
    select?: BraceletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BraceletInclude<ExtArgs> | null
    /**
     * Filter which Bracelet to delete.
     */
    where: BraceletWhereUniqueInput
  }

  /**
   * Bracelet deleteMany
   */
  export type BraceletDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bracelets to delete
     */
    where?: BraceletWhereInput
  }

  /**
   * Bracelet.alerts
   */
  export type Bracelet$alertsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    where?: AlertWhereInput
    orderBy?: AlertOrderByWithRelationInput | AlertOrderByWithRelationInput[]
    cursor?: AlertWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AlertScalarFieldEnum | AlertScalarFieldEnum[]
  }

  /**
   * Bracelet.emergencies
   */
  export type Bracelet$emergenciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emergency
     */
    select?: EmergencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyInclude<ExtArgs> | null
    where?: EmergencyWhereInput
    orderBy?: EmergencyOrderByWithRelationInput | EmergencyOrderByWithRelationInput[]
    cursor?: EmergencyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmergencyScalarFieldEnum | EmergencyScalarFieldEnum[]
  }

  /**
   * Bracelet without action
   */
  export type BraceletDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bracelet
     */
    select?: BraceletSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BraceletInclude<ExtArgs> | null
  }


  /**
   * Model Alert
   */

  export type AggregateAlert = {
    _count: AlertCountAggregateOutputType | null
    _min: AlertMinAggregateOutputType | null
    _max: AlertMaxAggregateOutputType | null
  }

  export type AlertMinAggregateOutputType = {
    id: string | null
    type: $Enums.AlertType | null
    status: $Enums.AlertStatus | null
    braceletId: string | null
    userId: string | null
    zoneId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    resolvedAt: Date | null
  }

  export type AlertMaxAggregateOutputType = {
    id: string | null
    type: $Enums.AlertType | null
    status: $Enums.AlertStatus | null
    braceletId: string | null
    userId: string | null
    zoneId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    resolvedAt: Date | null
  }

  export type AlertCountAggregateOutputType = {
    id: number
    type: number
    status: number
    braceletId: number
    userId: number
    zoneId: number
    metadata: number
    createdAt: number
    updatedAt: number
    resolvedAt: number
    _all: number
  }


  export type AlertMinAggregateInputType = {
    id?: true
    type?: true
    status?: true
    braceletId?: true
    userId?: true
    zoneId?: true
    createdAt?: true
    updatedAt?: true
    resolvedAt?: true
  }

  export type AlertMaxAggregateInputType = {
    id?: true
    type?: true
    status?: true
    braceletId?: true
    userId?: true
    zoneId?: true
    createdAt?: true
    updatedAt?: true
    resolvedAt?: true
  }

  export type AlertCountAggregateInputType = {
    id?: true
    type?: true
    status?: true
    braceletId?: true
    userId?: true
    zoneId?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    resolvedAt?: true
    _all?: true
  }

  export type AlertAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Alert to aggregate.
     */
    where?: AlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alerts to fetch.
     */
    orderBy?: AlertOrderByWithRelationInput | AlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Alerts
    **/
    _count?: true | AlertCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AlertMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AlertMaxAggregateInputType
  }

  export type GetAlertAggregateType<T extends AlertAggregateArgs> = {
        [P in keyof T & keyof AggregateAlert]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAlert[P]>
      : GetScalarType<T[P], AggregateAlert[P]>
  }




  export type AlertGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AlertWhereInput
    orderBy?: AlertOrderByWithAggregationInput | AlertOrderByWithAggregationInput[]
    by: AlertScalarFieldEnum[] | AlertScalarFieldEnum
    having?: AlertScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AlertCountAggregateInputType | true
    _min?: AlertMinAggregateInputType
    _max?: AlertMaxAggregateInputType
  }

  export type AlertGroupByOutputType = {
    id: string
    type: $Enums.AlertType
    status: $Enums.AlertStatus
    braceletId: string
    userId: string
    zoneId: string
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    resolvedAt: Date | null
    _count: AlertCountAggregateOutputType | null
    _min: AlertMinAggregateOutputType | null
    _max: AlertMaxAggregateOutputType | null
  }

  type GetAlertGroupByPayload<T extends AlertGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AlertGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AlertGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AlertGroupByOutputType[P]>
            : GetScalarType<T[P], AlertGroupByOutputType[P]>
        }
      >
    >


  export type AlertSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    status?: boolean
    braceletId?: boolean
    userId?: boolean
    zoneId?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    resolvedAt?: boolean
    bracelet?: boolean | BraceletDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    zone?: boolean | ZoneDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["alert"]>

  export type AlertSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    status?: boolean
    braceletId?: boolean
    userId?: boolean
    zoneId?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    resolvedAt?: boolean
    bracelet?: boolean | BraceletDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    zone?: boolean | ZoneDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["alert"]>

  export type AlertSelectScalar = {
    id?: boolean
    type?: boolean
    status?: boolean
    braceletId?: boolean
    userId?: boolean
    zoneId?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    resolvedAt?: boolean
  }

  export type AlertInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bracelet?: boolean | BraceletDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    zone?: boolean | ZoneDefaultArgs<ExtArgs>
  }
  export type AlertIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bracelet?: boolean | BraceletDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    zone?: boolean | ZoneDefaultArgs<ExtArgs>
  }

  export type $AlertPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Alert"
    objects: {
      bracelet: Prisma.$BraceletPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      zone: Prisma.$ZonePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: $Enums.AlertType
      status: $Enums.AlertStatus
      braceletId: string
      userId: string
      zoneId: string
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
      resolvedAt: Date | null
    }, ExtArgs["result"]["alert"]>
    composites: {}
  }

  type AlertGetPayload<S extends boolean | null | undefined | AlertDefaultArgs> = $Result.GetResult<Prisma.$AlertPayload, S>

  type AlertCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AlertFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AlertCountAggregateInputType | true
    }

  export interface AlertDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Alert'], meta: { name: 'Alert' } }
    /**
     * Find zero or one Alert that matches the filter.
     * @param {AlertFindUniqueArgs} args - Arguments to find a Alert
     * @example
     * // Get one Alert
     * const alert = await prisma.alert.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AlertFindUniqueArgs>(args: SelectSubset<T, AlertFindUniqueArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Alert that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AlertFindUniqueOrThrowArgs} args - Arguments to find a Alert
     * @example
     * // Get one Alert
     * const alert = await prisma.alert.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AlertFindUniqueOrThrowArgs>(args: SelectSubset<T, AlertFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Alert that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertFindFirstArgs} args - Arguments to find a Alert
     * @example
     * // Get one Alert
     * const alert = await prisma.alert.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AlertFindFirstArgs>(args?: SelectSubset<T, AlertFindFirstArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Alert that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertFindFirstOrThrowArgs} args - Arguments to find a Alert
     * @example
     * // Get one Alert
     * const alert = await prisma.alert.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AlertFindFirstOrThrowArgs>(args?: SelectSubset<T, AlertFindFirstOrThrowArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Alerts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Alerts
     * const alerts = await prisma.alert.findMany()
     * 
     * // Get first 10 Alerts
     * const alerts = await prisma.alert.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const alertWithIdOnly = await prisma.alert.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AlertFindManyArgs>(args?: SelectSubset<T, AlertFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Alert.
     * @param {AlertCreateArgs} args - Arguments to create a Alert.
     * @example
     * // Create one Alert
     * const Alert = await prisma.alert.create({
     *   data: {
     *     // ... data to create a Alert
     *   }
     * })
     * 
     */
    create<T extends AlertCreateArgs>(args: SelectSubset<T, AlertCreateArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Alerts.
     * @param {AlertCreateManyArgs} args - Arguments to create many Alerts.
     * @example
     * // Create many Alerts
     * const alert = await prisma.alert.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AlertCreateManyArgs>(args?: SelectSubset<T, AlertCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Alerts and returns the data saved in the database.
     * @param {AlertCreateManyAndReturnArgs} args - Arguments to create many Alerts.
     * @example
     * // Create many Alerts
     * const alert = await prisma.alert.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Alerts and only return the `id`
     * const alertWithIdOnly = await prisma.alert.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AlertCreateManyAndReturnArgs>(args?: SelectSubset<T, AlertCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Alert.
     * @param {AlertDeleteArgs} args - Arguments to delete one Alert.
     * @example
     * // Delete one Alert
     * const Alert = await prisma.alert.delete({
     *   where: {
     *     // ... filter to delete one Alert
     *   }
     * })
     * 
     */
    delete<T extends AlertDeleteArgs>(args: SelectSubset<T, AlertDeleteArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Alert.
     * @param {AlertUpdateArgs} args - Arguments to update one Alert.
     * @example
     * // Update one Alert
     * const alert = await prisma.alert.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AlertUpdateArgs>(args: SelectSubset<T, AlertUpdateArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Alerts.
     * @param {AlertDeleteManyArgs} args - Arguments to filter Alerts to delete.
     * @example
     * // Delete a few Alerts
     * const { count } = await prisma.alert.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AlertDeleteManyArgs>(args?: SelectSubset<T, AlertDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Alerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Alerts
     * const alert = await prisma.alert.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AlertUpdateManyArgs>(args: SelectSubset<T, AlertUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Alert.
     * @param {AlertUpsertArgs} args - Arguments to update or create a Alert.
     * @example
     * // Update or create a Alert
     * const alert = await prisma.alert.upsert({
     *   create: {
     *     // ... data to create a Alert
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Alert we want to update
     *   }
     * })
     */
    upsert<T extends AlertUpsertArgs>(args: SelectSubset<T, AlertUpsertArgs<ExtArgs>>): Prisma__AlertClient<$Result.GetResult<Prisma.$AlertPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Alerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertCountArgs} args - Arguments to filter Alerts to count.
     * @example
     * // Count the number of Alerts
     * const count = await prisma.alert.count({
     *   where: {
     *     // ... the filter for the Alerts we want to count
     *   }
     * })
    **/
    count<T extends AlertCountArgs>(
      args?: Subset<T, AlertCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AlertCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Alert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AlertAggregateArgs>(args: Subset<T, AlertAggregateArgs>): Prisma.PrismaPromise<GetAlertAggregateType<T>>

    /**
     * Group by Alert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AlertGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AlertGroupByArgs['orderBy'] }
        : { orderBy?: AlertGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AlertGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAlertGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Alert model
   */
  readonly fields: AlertFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Alert.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AlertClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bracelet<T extends BraceletDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BraceletDefaultArgs<ExtArgs>>): Prisma__BraceletClient<$Result.GetResult<Prisma.$BraceletPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    zone<T extends ZoneDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ZoneDefaultArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Alert model
   */ 
  interface AlertFieldRefs {
    readonly id: FieldRef<"Alert", 'String'>
    readonly type: FieldRef<"Alert", 'AlertType'>
    readonly status: FieldRef<"Alert", 'AlertStatus'>
    readonly braceletId: FieldRef<"Alert", 'String'>
    readonly userId: FieldRef<"Alert", 'String'>
    readonly zoneId: FieldRef<"Alert", 'String'>
    readonly metadata: FieldRef<"Alert", 'Json'>
    readonly createdAt: FieldRef<"Alert", 'DateTime'>
    readonly updatedAt: FieldRef<"Alert", 'DateTime'>
    readonly resolvedAt: FieldRef<"Alert", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Alert findUnique
   */
  export type AlertFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter, which Alert to fetch.
     */
    where: AlertWhereUniqueInput
  }

  /**
   * Alert findUniqueOrThrow
   */
  export type AlertFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter, which Alert to fetch.
     */
    where: AlertWhereUniqueInput
  }

  /**
   * Alert findFirst
   */
  export type AlertFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter, which Alert to fetch.
     */
    where?: AlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alerts to fetch.
     */
    orderBy?: AlertOrderByWithRelationInput | AlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Alerts.
     */
    cursor?: AlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Alerts.
     */
    distinct?: AlertScalarFieldEnum | AlertScalarFieldEnum[]
  }

  /**
   * Alert findFirstOrThrow
   */
  export type AlertFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter, which Alert to fetch.
     */
    where?: AlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alerts to fetch.
     */
    orderBy?: AlertOrderByWithRelationInput | AlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Alerts.
     */
    cursor?: AlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Alerts.
     */
    distinct?: AlertScalarFieldEnum | AlertScalarFieldEnum[]
  }

  /**
   * Alert findMany
   */
  export type AlertFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter, which Alerts to fetch.
     */
    where?: AlertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Alerts to fetch.
     */
    orderBy?: AlertOrderByWithRelationInput | AlertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Alerts.
     */
    cursor?: AlertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Alerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Alerts.
     */
    skip?: number
    distinct?: AlertScalarFieldEnum | AlertScalarFieldEnum[]
  }

  /**
   * Alert create
   */
  export type AlertCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * The data needed to create a Alert.
     */
    data: XOR<AlertCreateInput, AlertUncheckedCreateInput>
  }

  /**
   * Alert createMany
   */
  export type AlertCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Alerts.
     */
    data: AlertCreateManyInput | AlertCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Alert createManyAndReturn
   */
  export type AlertCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Alerts.
     */
    data: AlertCreateManyInput | AlertCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Alert update
   */
  export type AlertUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * The data needed to update a Alert.
     */
    data: XOR<AlertUpdateInput, AlertUncheckedUpdateInput>
    /**
     * Choose, which Alert to update.
     */
    where: AlertWhereUniqueInput
  }

  /**
   * Alert updateMany
   */
  export type AlertUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Alerts.
     */
    data: XOR<AlertUpdateManyMutationInput, AlertUncheckedUpdateManyInput>
    /**
     * Filter which Alerts to update
     */
    where?: AlertWhereInput
  }

  /**
   * Alert upsert
   */
  export type AlertUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * The filter to search for the Alert to update in case it exists.
     */
    where: AlertWhereUniqueInput
    /**
     * In case the Alert found by the `where` argument doesn't exist, create a new Alert with this data.
     */
    create: XOR<AlertCreateInput, AlertUncheckedCreateInput>
    /**
     * In case the Alert was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AlertUpdateInput, AlertUncheckedUpdateInput>
  }

  /**
   * Alert delete
   */
  export type AlertDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
    /**
     * Filter which Alert to delete.
     */
    where: AlertWhereUniqueInput
  }

  /**
   * Alert deleteMany
   */
  export type AlertDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Alerts to delete
     */
    where?: AlertWhereInput
  }

  /**
   * Alert without action
   */
  export type AlertDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Alert
     */
    select?: AlertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AlertInclude<ExtArgs> | null
  }


  /**
   * Model Emergency
   */

  export type AggregateEmergency = {
    _count: EmergencyCountAggregateOutputType | null
    _avg: EmergencyAvgAggregateOutputType | null
    _sum: EmergencySumAggregateOutputType | null
    _min: EmergencyMinAggregateOutputType | null
    _max: EmergencyMaxAggregateOutputType | null
  }

  export type EmergencyAvgAggregateOutputType = {
    responseTime: number | null
  }

  export type EmergencySumAggregateOutputType = {
    responseTime: number | null
  }

  export type EmergencyMinAggregateOutputType = {
    id: string | null
    status: $Enums.EmergencyStatus | null
    braceletId: string | null
    zoneId: string | null
    nightclubId: string | null
    responderId: string | null
    responseTime: number | null
    createdAt: Date | null
    updatedAt: Date | null
    resolvedAt: Date | null
  }

  export type EmergencyMaxAggregateOutputType = {
    id: string | null
    status: $Enums.EmergencyStatus | null
    braceletId: string | null
    zoneId: string | null
    nightclubId: string | null
    responderId: string | null
    responseTime: number | null
    createdAt: Date | null
    updatedAt: Date | null
    resolvedAt: Date | null
  }

  export type EmergencyCountAggregateOutputType = {
    id: number
    status: number
    braceletId: number
    zoneId: number
    nightclubId: number
    responderId: number
    responseTime: number
    escalationDetails: number
    resolutionDetails: number
    metadata: number
    createdAt: number
    updatedAt: number
    resolvedAt: number
    _all: number
  }


  export type EmergencyAvgAggregateInputType = {
    responseTime?: true
  }

  export type EmergencySumAggregateInputType = {
    responseTime?: true
  }

  export type EmergencyMinAggregateInputType = {
    id?: true
    status?: true
    braceletId?: true
    zoneId?: true
    nightclubId?: true
    responderId?: true
    responseTime?: true
    createdAt?: true
    updatedAt?: true
    resolvedAt?: true
  }

  export type EmergencyMaxAggregateInputType = {
    id?: true
    status?: true
    braceletId?: true
    zoneId?: true
    nightclubId?: true
    responderId?: true
    responseTime?: true
    createdAt?: true
    updatedAt?: true
    resolvedAt?: true
  }

  export type EmergencyCountAggregateInputType = {
    id?: true
    status?: true
    braceletId?: true
    zoneId?: true
    nightclubId?: true
    responderId?: true
    responseTime?: true
    escalationDetails?: true
    resolutionDetails?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    resolvedAt?: true
    _all?: true
  }

  export type EmergencyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Emergency to aggregate.
     */
    where?: EmergencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Emergencies to fetch.
     */
    orderBy?: EmergencyOrderByWithRelationInput | EmergencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmergencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Emergencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Emergencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Emergencies
    **/
    _count?: true | EmergencyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmergencyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmergencySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmergencyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmergencyMaxAggregateInputType
  }

  export type GetEmergencyAggregateType<T extends EmergencyAggregateArgs> = {
        [P in keyof T & keyof AggregateEmergency]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmergency[P]>
      : GetScalarType<T[P], AggregateEmergency[P]>
  }




  export type EmergencyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmergencyWhereInput
    orderBy?: EmergencyOrderByWithAggregationInput | EmergencyOrderByWithAggregationInput[]
    by: EmergencyScalarFieldEnum[] | EmergencyScalarFieldEnum
    having?: EmergencyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmergencyCountAggregateInputType | true
    _avg?: EmergencyAvgAggregateInputType
    _sum?: EmergencySumAggregateInputType
    _min?: EmergencyMinAggregateInputType
    _max?: EmergencyMaxAggregateInputType
  }

  export type EmergencyGroupByOutputType = {
    id: string
    status: $Enums.EmergencyStatus
    braceletId: string
    zoneId: string
    nightclubId: string
    responderId: string | null
    responseTime: number | null
    escalationDetails: JsonValue | null
    resolutionDetails: JsonValue | null
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    resolvedAt: Date | null
    _count: EmergencyCountAggregateOutputType | null
    _avg: EmergencyAvgAggregateOutputType | null
    _sum: EmergencySumAggregateOutputType | null
    _min: EmergencyMinAggregateOutputType | null
    _max: EmergencyMaxAggregateOutputType | null
  }

  type GetEmergencyGroupByPayload<T extends EmergencyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmergencyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmergencyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmergencyGroupByOutputType[P]>
            : GetScalarType<T[P], EmergencyGroupByOutputType[P]>
        }
      >
    >


  export type EmergencySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    braceletId?: boolean
    zoneId?: boolean
    nightclubId?: boolean
    responderId?: boolean
    responseTime?: boolean
    escalationDetails?: boolean
    resolutionDetails?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    resolvedAt?: boolean
    bracelet?: boolean | BraceletDefaultArgs<ExtArgs>
    zone?: boolean | ZoneDefaultArgs<ExtArgs>
    nightclub?: boolean | NightclubDefaultArgs<ExtArgs>
    responder?: boolean | Emergency$responderArgs<ExtArgs>
  }, ExtArgs["result"]["emergency"]>

  export type EmergencySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    status?: boolean
    braceletId?: boolean
    zoneId?: boolean
    nightclubId?: boolean
    responderId?: boolean
    responseTime?: boolean
    escalationDetails?: boolean
    resolutionDetails?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    resolvedAt?: boolean
    bracelet?: boolean | BraceletDefaultArgs<ExtArgs>
    zone?: boolean | ZoneDefaultArgs<ExtArgs>
    nightclub?: boolean | NightclubDefaultArgs<ExtArgs>
    responder?: boolean | Emergency$responderArgs<ExtArgs>
  }, ExtArgs["result"]["emergency"]>

  export type EmergencySelectScalar = {
    id?: boolean
    status?: boolean
    braceletId?: boolean
    zoneId?: boolean
    nightclubId?: boolean
    responderId?: boolean
    responseTime?: boolean
    escalationDetails?: boolean
    resolutionDetails?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    resolvedAt?: boolean
  }

  export type EmergencyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bracelet?: boolean | BraceletDefaultArgs<ExtArgs>
    zone?: boolean | ZoneDefaultArgs<ExtArgs>
    nightclub?: boolean | NightclubDefaultArgs<ExtArgs>
    responder?: boolean | Emergency$responderArgs<ExtArgs>
  }
  export type EmergencyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bracelet?: boolean | BraceletDefaultArgs<ExtArgs>
    zone?: boolean | ZoneDefaultArgs<ExtArgs>
    nightclub?: boolean | NightclubDefaultArgs<ExtArgs>
    responder?: boolean | Emergency$responderArgs<ExtArgs>
  }

  export type $EmergencyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Emergency"
    objects: {
      bracelet: Prisma.$BraceletPayload<ExtArgs>
      zone: Prisma.$ZonePayload<ExtArgs>
      nightclub: Prisma.$NightclubPayload<ExtArgs>
      responder: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      status: $Enums.EmergencyStatus
      braceletId: string
      zoneId: string
      nightclubId: string
      responderId: string | null
      responseTime: number | null
      escalationDetails: Prisma.JsonValue | null
      resolutionDetails: Prisma.JsonValue | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
      resolvedAt: Date | null
    }, ExtArgs["result"]["emergency"]>
    composites: {}
  }

  type EmergencyGetPayload<S extends boolean | null | undefined | EmergencyDefaultArgs> = $Result.GetResult<Prisma.$EmergencyPayload, S>

  type EmergencyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmergencyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmergencyCountAggregateInputType | true
    }

  export interface EmergencyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Emergency'], meta: { name: 'Emergency' } }
    /**
     * Find zero or one Emergency that matches the filter.
     * @param {EmergencyFindUniqueArgs} args - Arguments to find a Emergency
     * @example
     * // Get one Emergency
     * const emergency = await prisma.emergency.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmergencyFindUniqueArgs>(args: SelectSubset<T, EmergencyFindUniqueArgs<ExtArgs>>): Prisma__EmergencyClient<$Result.GetResult<Prisma.$EmergencyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Emergency that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EmergencyFindUniqueOrThrowArgs} args - Arguments to find a Emergency
     * @example
     * // Get one Emergency
     * const emergency = await prisma.emergency.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmergencyFindUniqueOrThrowArgs>(args: SelectSubset<T, EmergencyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmergencyClient<$Result.GetResult<Prisma.$EmergencyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Emergency that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmergencyFindFirstArgs} args - Arguments to find a Emergency
     * @example
     * // Get one Emergency
     * const emergency = await prisma.emergency.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmergencyFindFirstArgs>(args?: SelectSubset<T, EmergencyFindFirstArgs<ExtArgs>>): Prisma__EmergencyClient<$Result.GetResult<Prisma.$EmergencyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Emergency that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmergencyFindFirstOrThrowArgs} args - Arguments to find a Emergency
     * @example
     * // Get one Emergency
     * const emergency = await prisma.emergency.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmergencyFindFirstOrThrowArgs>(args?: SelectSubset<T, EmergencyFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmergencyClient<$Result.GetResult<Prisma.$EmergencyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Emergencies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmergencyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Emergencies
     * const emergencies = await prisma.emergency.findMany()
     * 
     * // Get first 10 Emergencies
     * const emergencies = await prisma.emergency.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emergencyWithIdOnly = await prisma.emergency.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmergencyFindManyArgs>(args?: SelectSubset<T, EmergencyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmergencyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Emergency.
     * @param {EmergencyCreateArgs} args - Arguments to create a Emergency.
     * @example
     * // Create one Emergency
     * const Emergency = await prisma.emergency.create({
     *   data: {
     *     // ... data to create a Emergency
     *   }
     * })
     * 
     */
    create<T extends EmergencyCreateArgs>(args: SelectSubset<T, EmergencyCreateArgs<ExtArgs>>): Prisma__EmergencyClient<$Result.GetResult<Prisma.$EmergencyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Emergencies.
     * @param {EmergencyCreateManyArgs} args - Arguments to create many Emergencies.
     * @example
     * // Create many Emergencies
     * const emergency = await prisma.emergency.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmergencyCreateManyArgs>(args?: SelectSubset<T, EmergencyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Emergencies and returns the data saved in the database.
     * @param {EmergencyCreateManyAndReturnArgs} args - Arguments to create many Emergencies.
     * @example
     * // Create many Emergencies
     * const emergency = await prisma.emergency.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Emergencies and only return the `id`
     * const emergencyWithIdOnly = await prisma.emergency.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmergencyCreateManyAndReturnArgs>(args?: SelectSubset<T, EmergencyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmergencyPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Emergency.
     * @param {EmergencyDeleteArgs} args - Arguments to delete one Emergency.
     * @example
     * // Delete one Emergency
     * const Emergency = await prisma.emergency.delete({
     *   where: {
     *     // ... filter to delete one Emergency
     *   }
     * })
     * 
     */
    delete<T extends EmergencyDeleteArgs>(args: SelectSubset<T, EmergencyDeleteArgs<ExtArgs>>): Prisma__EmergencyClient<$Result.GetResult<Prisma.$EmergencyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Emergency.
     * @param {EmergencyUpdateArgs} args - Arguments to update one Emergency.
     * @example
     * // Update one Emergency
     * const emergency = await prisma.emergency.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmergencyUpdateArgs>(args: SelectSubset<T, EmergencyUpdateArgs<ExtArgs>>): Prisma__EmergencyClient<$Result.GetResult<Prisma.$EmergencyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Emergencies.
     * @param {EmergencyDeleteManyArgs} args - Arguments to filter Emergencies to delete.
     * @example
     * // Delete a few Emergencies
     * const { count } = await prisma.emergency.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmergencyDeleteManyArgs>(args?: SelectSubset<T, EmergencyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Emergencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmergencyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Emergencies
     * const emergency = await prisma.emergency.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmergencyUpdateManyArgs>(args: SelectSubset<T, EmergencyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Emergency.
     * @param {EmergencyUpsertArgs} args - Arguments to update or create a Emergency.
     * @example
     * // Update or create a Emergency
     * const emergency = await prisma.emergency.upsert({
     *   create: {
     *     // ... data to create a Emergency
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Emergency we want to update
     *   }
     * })
     */
    upsert<T extends EmergencyUpsertArgs>(args: SelectSubset<T, EmergencyUpsertArgs<ExtArgs>>): Prisma__EmergencyClient<$Result.GetResult<Prisma.$EmergencyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Emergencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmergencyCountArgs} args - Arguments to filter Emergencies to count.
     * @example
     * // Count the number of Emergencies
     * const count = await prisma.emergency.count({
     *   where: {
     *     // ... the filter for the Emergencies we want to count
     *   }
     * })
    **/
    count<T extends EmergencyCountArgs>(
      args?: Subset<T, EmergencyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmergencyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Emergency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmergencyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmergencyAggregateArgs>(args: Subset<T, EmergencyAggregateArgs>): Prisma.PrismaPromise<GetEmergencyAggregateType<T>>

    /**
     * Group by Emergency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmergencyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmergencyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmergencyGroupByArgs['orderBy'] }
        : { orderBy?: EmergencyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmergencyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmergencyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Emergency model
   */
  readonly fields: EmergencyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Emergency.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmergencyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bracelet<T extends BraceletDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BraceletDefaultArgs<ExtArgs>>): Prisma__BraceletClient<$Result.GetResult<Prisma.$BraceletPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    zone<T extends ZoneDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ZoneDefaultArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    nightclub<T extends NightclubDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NightclubDefaultArgs<ExtArgs>>): Prisma__NightclubClient<$Result.GetResult<Prisma.$NightclubPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    responder<T extends Emergency$responderArgs<ExtArgs> = {}>(args?: Subset<T, Emergency$responderArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Emergency model
   */ 
  interface EmergencyFieldRefs {
    readonly id: FieldRef<"Emergency", 'String'>
    readonly status: FieldRef<"Emergency", 'EmergencyStatus'>
    readonly braceletId: FieldRef<"Emergency", 'String'>
    readonly zoneId: FieldRef<"Emergency", 'String'>
    readonly nightclubId: FieldRef<"Emergency", 'String'>
    readonly responderId: FieldRef<"Emergency", 'String'>
    readonly responseTime: FieldRef<"Emergency", 'Int'>
    readonly escalationDetails: FieldRef<"Emergency", 'Json'>
    readonly resolutionDetails: FieldRef<"Emergency", 'Json'>
    readonly metadata: FieldRef<"Emergency", 'Json'>
    readonly createdAt: FieldRef<"Emergency", 'DateTime'>
    readonly updatedAt: FieldRef<"Emergency", 'DateTime'>
    readonly resolvedAt: FieldRef<"Emergency", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Emergency findUnique
   */
  export type EmergencyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emergency
     */
    select?: EmergencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyInclude<ExtArgs> | null
    /**
     * Filter, which Emergency to fetch.
     */
    where: EmergencyWhereUniqueInput
  }

  /**
   * Emergency findUniqueOrThrow
   */
  export type EmergencyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emergency
     */
    select?: EmergencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyInclude<ExtArgs> | null
    /**
     * Filter, which Emergency to fetch.
     */
    where: EmergencyWhereUniqueInput
  }

  /**
   * Emergency findFirst
   */
  export type EmergencyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emergency
     */
    select?: EmergencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyInclude<ExtArgs> | null
    /**
     * Filter, which Emergency to fetch.
     */
    where?: EmergencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Emergencies to fetch.
     */
    orderBy?: EmergencyOrderByWithRelationInput | EmergencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Emergencies.
     */
    cursor?: EmergencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Emergencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Emergencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Emergencies.
     */
    distinct?: EmergencyScalarFieldEnum | EmergencyScalarFieldEnum[]
  }

  /**
   * Emergency findFirstOrThrow
   */
  export type EmergencyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emergency
     */
    select?: EmergencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyInclude<ExtArgs> | null
    /**
     * Filter, which Emergency to fetch.
     */
    where?: EmergencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Emergencies to fetch.
     */
    orderBy?: EmergencyOrderByWithRelationInput | EmergencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Emergencies.
     */
    cursor?: EmergencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Emergencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Emergencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Emergencies.
     */
    distinct?: EmergencyScalarFieldEnum | EmergencyScalarFieldEnum[]
  }

  /**
   * Emergency findMany
   */
  export type EmergencyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emergency
     */
    select?: EmergencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyInclude<ExtArgs> | null
    /**
     * Filter, which Emergencies to fetch.
     */
    where?: EmergencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Emergencies to fetch.
     */
    orderBy?: EmergencyOrderByWithRelationInput | EmergencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Emergencies.
     */
    cursor?: EmergencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Emergencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Emergencies.
     */
    skip?: number
    distinct?: EmergencyScalarFieldEnum | EmergencyScalarFieldEnum[]
  }

  /**
   * Emergency create
   */
  export type EmergencyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emergency
     */
    select?: EmergencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyInclude<ExtArgs> | null
    /**
     * The data needed to create a Emergency.
     */
    data: XOR<EmergencyCreateInput, EmergencyUncheckedCreateInput>
  }

  /**
   * Emergency createMany
   */
  export type EmergencyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Emergencies.
     */
    data: EmergencyCreateManyInput | EmergencyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Emergency createManyAndReturn
   */
  export type EmergencyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emergency
     */
    select?: EmergencySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Emergencies.
     */
    data: EmergencyCreateManyInput | EmergencyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Emergency update
   */
  export type EmergencyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emergency
     */
    select?: EmergencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyInclude<ExtArgs> | null
    /**
     * The data needed to update a Emergency.
     */
    data: XOR<EmergencyUpdateInput, EmergencyUncheckedUpdateInput>
    /**
     * Choose, which Emergency to update.
     */
    where: EmergencyWhereUniqueInput
  }

  /**
   * Emergency updateMany
   */
  export type EmergencyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Emergencies.
     */
    data: XOR<EmergencyUpdateManyMutationInput, EmergencyUncheckedUpdateManyInput>
    /**
     * Filter which Emergencies to update
     */
    where?: EmergencyWhereInput
  }

  /**
   * Emergency upsert
   */
  export type EmergencyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emergency
     */
    select?: EmergencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyInclude<ExtArgs> | null
    /**
     * The filter to search for the Emergency to update in case it exists.
     */
    where: EmergencyWhereUniqueInput
    /**
     * In case the Emergency found by the `where` argument doesn't exist, create a new Emergency with this data.
     */
    create: XOR<EmergencyCreateInput, EmergencyUncheckedCreateInput>
    /**
     * In case the Emergency was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmergencyUpdateInput, EmergencyUncheckedUpdateInput>
  }

  /**
   * Emergency delete
   */
  export type EmergencyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emergency
     */
    select?: EmergencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyInclude<ExtArgs> | null
    /**
     * Filter which Emergency to delete.
     */
    where: EmergencyWhereUniqueInput
  }

  /**
   * Emergency deleteMany
   */
  export type EmergencyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Emergencies to delete
     */
    where?: EmergencyWhereInput
  }

  /**
   * Emergency.responder
   */
  export type Emergency$responderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Emergency without action
   */
  export type EmergencyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Emergency
     */
    select?: EmergencySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmergencyInclude<ExtArgs> | null
  }


  /**
   * Model Sensor
   */

  export type AggregateSensor = {
    _count: SensorCountAggregateOutputType | null
    _min: SensorMinAggregateOutputType | null
    _max: SensorMaxAggregateOutputType | null
  }

  export type SensorMinAggregateOutputType = {
    id: string | null
    type: $Enums.SensorType | null
    status: $Enums.SensorStatus | null
    zoneId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    lastReading: Date | null
  }

  export type SensorMaxAggregateOutputType = {
    id: string | null
    type: $Enums.SensorType | null
    status: $Enums.SensorStatus | null
    zoneId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    lastReading: Date | null
  }

  export type SensorCountAggregateOutputType = {
    id: number
    type: number
    status: number
    zoneId: number
    data: number
    metadata: number
    createdAt: number
    updatedAt: number
    lastReading: number
    _all: number
  }


  export type SensorMinAggregateInputType = {
    id?: true
    type?: true
    status?: true
    zoneId?: true
    createdAt?: true
    updatedAt?: true
    lastReading?: true
  }

  export type SensorMaxAggregateInputType = {
    id?: true
    type?: true
    status?: true
    zoneId?: true
    createdAt?: true
    updatedAt?: true
    lastReading?: true
  }

  export type SensorCountAggregateInputType = {
    id?: true
    type?: true
    status?: true
    zoneId?: true
    data?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    lastReading?: true
    _all?: true
  }

  export type SensorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sensor to aggregate.
     */
    where?: SensorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sensors to fetch.
     */
    orderBy?: SensorOrderByWithRelationInput | SensorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SensorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sensors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sensors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sensors
    **/
    _count?: true | SensorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SensorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SensorMaxAggregateInputType
  }

  export type GetSensorAggregateType<T extends SensorAggregateArgs> = {
        [P in keyof T & keyof AggregateSensor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSensor[P]>
      : GetScalarType<T[P], AggregateSensor[P]>
  }




  export type SensorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SensorWhereInput
    orderBy?: SensorOrderByWithAggregationInput | SensorOrderByWithAggregationInput[]
    by: SensorScalarFieldEnum[] | SensorScalarFieldEnum
    having?: SensorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SensorCountAggregateInputType | true
    _min?: SensorMinAggregateInputType
    _max?: SensorMaxAggregateInputType
  }

  export type SensorGroupByOutputType = {
    id: string
    type: $Enums.SensorType
    status: $Enums.SensorStatus
    zoneId: string
    data: JsonValue | null
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    lastReading: Date | null
    _count: SensorCountAggregateOutputType | null
    _min: SensorMinAggregateOutputType | null
    _max: SensorMaxAggregateOutputType | null
  }

  type GetSensorGroupByPayload<T extends SensorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SensorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SensorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SensorGroupByOutputType[P]>
            : GetScalarType<T[P], SensorGroupByOutputType[P]>
        }
      >
    >


  export type SensorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    status?: boolean
    zoneId?: boolean
    data?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastReading?: boolean
    zone?: boolean | ZoneDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sensor"]>

  export type SensorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    status?: boolean
    zoneId?: boolean
    data?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastReading?: boolean
    zone?: boolean | ZoneDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sensor"]>

  export type SensorSelectScalar = {
    id?: boolean
    type?: boolean
    status?: boolean
    zoneId?: boolean
    data?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastReading?: boolean
  }

  export type SensorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    zone?: boolean | ZoneDefaultArgs<ExtArgs>
  }
  export type SensorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    zone?: boolean | ZoneDefaultArgs<ExtArgs>
  }

  export type $SensorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Sensor"
    objects: {
      zone: Prisma.$ZonePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: $Enums.SensorType
      status: $Enums.SensorStatus
      zoneId: string
      data: Prisma.JsonValue | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
      lastReading: Date | null
    }, ExtArgs["result"]["sensor"]>
    composites: {}
  }

  type SensorGetPayload<S extends boolean | null | undefined | SensorDefaultArgs> = $Result.GetResult<Prisma.$SensorPayload, S>

  type SensorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SensorFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SensorCountAggregateInputType | true
    }

  export interface SensorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Sensor'], meta: { name: 'Sensor' } }
    /**
     * Find zero or one Sensor that matches the filter.
     * @param {SensorFindUniqueArgs} args - Arguments to find a Sensor
     * @example
     * // Get one Sensor
     * const sensor = await prisma.sensor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SensorFindUniqueArgs>(args: SelectSubset<T, SensorFindUniqueArgs<ExtArgs>>): Prisma__SensorClient<$Result.GetResult<Prisma.$SensorPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Sensor that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SensorFindUniqueOrThrowArgs} args - Arguments to find a Sensor
     * @example
     * // Get one Sensor
     * const sensor = await prisma.sensor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SensorFindUniqueOrThrowArgs>(args: SelectSubset<T, SensorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SensorClient<$Result.GetResult<Prisma.$SensorPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Sensor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SensorFindFirstArgs} args - Arguments to find a Sensor
     * @example
     * // Get one Sensor
     * const sensor = await prisma.sensor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SensorFindFirstArgs>(args?: SelectSubset<T, SensorFindFirstArgs<ExtArgs>>): Prisma__SensorClient<$Result.GetResult<Prisma.$SensorPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Sensor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SensorFindFirstOrThrowArgs} args - Arguments to find a Sensor
     * @example
     * // Get one Sensor
     * const sensor = await prisma.sensor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SensorFindFirstOrThrowArgs>(args?: SelectSubset<T, SensorFindFirstOrThrowArgs<ExtArgs>>): Prisma__SensorClient<$Result.GetResult<Prisma.$SensorPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Sensors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SensorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sensors
     * const sensors = await prisma.sensor.findMany()
     * 
     * // Get first 10 Sensors
     * const sensors = await prisma.sensor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sensorWithIdOnly = await prisma.sensor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SensorFindManyArgs>(args?: SelectSubset<T, SensorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SensorPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Sensor.
     * @param {SensorCreateArgs} args - Arguments to create a Sensor.
     * @example
     * // Create one Sensor
     * const Sensor = await prisma.sensor.create({
     *   data: {
     *     // ... data to create a Sensor
     *   }
     * })
     * 
     */
    create<T extends SensorCreateArgs>(args: SelectSubset<T, SensorCreateArgs<ExtArgs>>): Prisma__SensorClient<$Result.GetResult<Prisma.$SensorPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Sensors.
     * @param {SensorCreateManyArgs} args - Arguments to create many Sensors.
     * @example
     * // Create many Sensors
     * const sensor = await prisma.sensor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SensorCreateManyArgs>(args?: SelectSubset<T, SensorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sensors and returns the data saved in the database.
     * @param {SensorCreateManyAndReturnArgs} args - Arguments to create many Sensors.
     * @example
     * // Create many Sensors
     * const sensor = await prisma.sensor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sensors and only return the `id`
     * const sensorWithIdOnly = await prisma.sensor.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SensorCreateManyAndReturnArgs>(args?: SelectSubset<T, SensorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SensorPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Sensor.
     * @param {SensorDeleteArgs} args - Arguments to delete one Sensor.
     * @example
     * // Delete one Sensor
     * const Sensor = await prisma.sensor.delete({
     *   where: {
     *     // ... filter to delete one Sensor
     *   }
     * })
     * 
     */
    delete<T extends SensorDeleteArgs>(args: SelectSubset<T, SensorDeleteArgs<ExtArgs>>): Prisma__SensorClient<$Result.GetResult<Prisma.$SensorPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Sensor.
     * @param {SensorUpdateArgs} args - Arguments to update one Sensor.
     * @example
     * // Update one Sensor
     * const sensor = await prisma.sensor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SensorUpdateArgs>(args: SelectSubset<T, SensorUpdateArgs<ExtArgs>>): Prisma__SensorClient<$Result.GetResult<Prisma.$SensorPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Sensors.
     * @param {SensorDeleteManyArgs} args - Arguments to filter Sensors to delete.
     * @example
     * // Delete a few Sensors
     * const { count } = await prisma.sensor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SensorDeleteManyArgs>(args?: SelectSubset<T, SensorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sensors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SensorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sensors
     * const sensor = await prisma.sensor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SensorUpdateManyArgs>(args: SelectSubset<T, SensorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Sensor.
     * @param {SensorUpsertArgs} args - Arguments to update or create a Sensor.
     * @example
     * // Update or create a Sensor
     * const sensor = await prisma.sensor.upsert({
     *   create: {
     *     // ... data to create a Sensor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sensor we want to update
     *   }
     * })
     */
    upsert<T extends SensorUpsertArgs>(args: SelectSubset<T, SensorUpsertArgs<ExtArgs>>): Prisma__SensorClient<$Result.GetResult<Prisma.$SensorPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Sensors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SensorCountArgs} args - Arguments to filter Sensors to count.
     * @example
     * // Count the number of Sensors
     * const count = await prisma.sensor.count({
     *   where: {
     *     // ... the filter for the Sensors we want to count
     *   }
     * })
    **/
    count<T extends SensorCountArgs>(
      args?: Subset<T, SensorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SensorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sensor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SensorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SensorAggregateArgs>(args: Subset<T, SensorAggregateArgs>): Prisma.PrismaPromise<GetSensorAggregateType<T>>

    /**
     * Group by Sensor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SensorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SensorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SensorGroupByArgs['orderBy'] }
        : { orderBy?: SensorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SensorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSensorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Sensor model
   */
  readonly fields: SensorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Sensor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SensorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    zone<T extends ZoneDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ZoneDefaultArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Sensor model
   */ 
  interface SensorFieldRefs {
    readonly id: FieldRef<"Sensor", 'String'>
    readonly type: FieldRef<"Sensor", 'SensorType'>
    readonly status: FieldRef<"Sensor", 'SensorStatus'>
    readonly zoneId: FieldRef<"Sensor", 'String'>
    readonly data: FieldRef<"Sensor", 'Json'>
    readonly metadata: FieldRef<"Sensor", 'Json'>
    readonly createdAt: FieldRef<"Sensor", 'DateTime'>
    readonly updatedAt: FieldRef<"Sensor", 'DateTime'>
    readonly lastReading: FieldRef<"Sensor", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Sensor findUnique
   */
  export type SensorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sensor
     */
    select?: SensorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SensorInclude<ExtArgs> | null
    /**
     * Filter, which Sensor to fetch.
     */
    where: SensorWhereUniqueInput
  }

  /**
   * Sensor findUniqueOrThrow
   */
  export type SensorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sensor
     */
    select?: SensorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SensorInclude<ExtArgs> | null
    /**
     * Filter, which Sensor to fetch.
     */
    where: SensorWhereUniqueInput
  }

  /**
   * Sensor findFirst
   */
  export type SensorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sensor
     */
    select?: SensorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SensorInclude<ExtArgs> | null
    /**
     * Filter, which Sensor to fetch.
     */
    where?: SensorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sensors to fetch.
     */
    orderBy?: SensorOrderByWithRelationInput | SensorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sensors.
     */
    cursor?: SensorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sensors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sensors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sensors.
     */
    distinct?: SensorScalarFieldEnum | SensorScalarFieldEnum[]
  }

  /**
   * Sensor findFirstOrThrow
   */
  export type SensorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sensor
     */
    select?: SensorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SensorInclude<ExtArgs> | null
    /**
     * Filter, which Sensor to fetch.
     */
    where?: SensorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sensors to fetch.
     */
    orderBy?: SensorOrderByWithRelationInput | SensorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sensors.
     */
    cursor?: SensorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sensors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sensors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sensors.
     */
    distinct?: SensorScalarFieldEnum | SensorScalarFieldEnum[]
  }

  /**
   * Sensor findMany
   */
  export type SensorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sensor
     */
    select?: SensorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SensorInclude<ExtArgs> | null
    /**
     * Filter, which Sensors to fetch.
     */
    where?: SensorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sensors to fetch.
     */
    orderBy?: SensorOrderByWithRelationInput | SensorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sensors.
     */
    cursor?: SensorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sensors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sensors.
     */
    skip?: number
    distinct?: SensorScalarFieldEnum | SensorScalarFieldEnum[]
  }

  /**
   * Sensor create
   */
  export type SensorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sensor
     */
    select?: SensorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SensorInclude<ExtArgs> | null
    /**
     * The data needed to create a Sensor.
     */
    data: XOR<SensorCreateInput, SensorUncheckedCreateInput>
  }

  /**
   * Sensor createMany
   */
  export type SensorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sensors.
     */
    data: SensorCreateManyInput | SensorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Sensor createManyAndReturn
   */
  export type SensorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sensor
     */
    select?: SensorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Sensors.
     */
    data: SensorCreateManyInput | SensorCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SensorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Sensor update
   */
  export type SensorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sensor
     */
    select?: SensorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SensorInclude<ExtArgs> | null
    /**
     * The data needed to update a Sensor.
     */
    data: XOR<SensorUpdateInput, SensorUncheckedUpdateInput>
    /**
     * Choose, which Sensor to update.
     */
    where: SensorWhereUniqueInput
  }

  /**
   * Sensor updateMany
   */
  export type SensorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sensors.
     */
    data: XOR<SensorUpdateManyMutationInput, SensorUncheckedUpdateManyInput>
    /**
     * Filter which Sensors to update
     */
    where?: SensorWhereInput
  }

  /**
   * Sensor upsert
   */
  export type SensorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sensor
     */
    select?: SensorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SensorInclude<ExtArgs> | null
    /**
     * The filter to search for the Sensor to update in case it exists.
     */
    where: SensorWhereUniqueInput
    /**
     * In case the Sensor found by the `where` argument doesn't exist, create a new Sensor with this data.
     */
    create: XOR<SensorCreateInput, SensorUncheckedCreateInput>
    /**
     * In case the Sensor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SensorUpdateInput, SensorUncheckedUpdateInput>
  }

  /**
   * Sensor delete
   */
  export type SensorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sensor
     */
    select?: SensorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SensorInclude<ExtArgs> | null
    /**
     * Filter which Sensor to delete.
     */
    where: SensorWhereUniqueInput
  }

  /**
   * Sensor deleteMany
   */
  export type SensorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sensors to delete
     */
    where?: SensorWhereInput
  }

  /**
   * Sensor without action
   */
  export type SensorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sensor
     */
    select?: SensorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SensorInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    action: string | null
    entityType: string | null
    entityId: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    action: string | null
    entityType: string | null
    entityId: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    action: number
    entityType: number
    entityId: number
    userId: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    action?: true
    entityType?: true
    entityId?: true
    userId?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    action?: true
    entityType?: true
    entityId?: true
    userId?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    action?: true
    entityType?: true
    entityId?: true
    userId?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    action: string
    entityType: string
    entityId: string
    userId: string | null
    metadata: JsonValue | null
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    userId?: boolean
    metadata?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    userId?: boolean
    metadata?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    userId?: boolean
    metadata?: boolean
    createdAt?: boolean
  }


  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      action: string
      entityType: string
      entityId: string
      userId: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */ 
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly entityType: FieldRef<"AuditLog", 'String'>
    readonly entityId: FieldRef<"AuditLog", 'String'>
    readonly userId: FieldRef<"AuditLog", 'String'>
    readonly metadata: FieldRef<"AuditLog", 'Json'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
  }


  /**
   * Model AnalyticsReport
   */

  export type AggregateAnalyticsReport = {
    _count: AnalyticsReportCountAggregateOutputType | null
    _min: AnalyticsReportMinAggregateOutputType | null
    _max: AnalyticsReportMaxAggregateOutputType | null
  }

  export type AnalyticsReportMinAggregateOutputType = {
    id: string | null
    nightclubId: string | null
    type: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AnalyticsReportMaxAggregateOutputType = {
    id: string | null
    nightclubId: string | null
    type: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AnalyticsReportCountAggregateOutputType = {
    id: number
    nightclubId: number
    type: number
    report: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AnalyticsReportMinAggregateInputType = {
    id?: true
    nightclubId?: true
    type?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AnalyticsReportMaxAggregateInputType = {
    id?: true
    nightclubId?: true
    type?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AnalyticsReportCountAggregateInputType = {
    id?: true
    nightclubId?: true
    type?: true
    report?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AnalyticsReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnalyticsReport to aggregate.
     */
    where?: AnalyticsReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticsReports to fetch.
     */
    orderBy?: AnalyticsReportOrderByWithRelationInput | AnalyticsReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnalyticsReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticsReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticsReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AnalyticsReports
    **/
    _count?: true | AnalyticsReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnalyticsReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnalyticsReportMaxAggregateInputType
  }

  export type GetAnalyticsReportAggregateType<T extends AnalyticsReportAggregateArgs> = {
        [P in keyof T & keyof AggregateAnalyticsReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnalyticsReport[P]>
      : GetScalarType<T[P], AggregateAnalyticsReport[P]>
  }




  export type AnalyticsReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnalyticsReportWhereInput
    orderBy?: AnalyticsReportOrderByWithAggregationInput | AnalyticsReportOrderByWithAggregationInput[]
    by: AnalyticsReportScalarFieldEnum[] | AnalyticsReportScalarFieldEnum
    having?: AnalyticsReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnalyticsReportCountAggregateInputType | true
    _min?: AnalyticsReportMinAggregateInputType
    _max?: AnalyticsReportMaxAggregateInputType
  }

  export type AnalyticsReportGroupByOutputType = {
    id: string
    nightclubId: string
    type: string
    report: JsonValue
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: AnalyticsReportCountAggregateOutputType | null
    _min: AnalyticsReportMinAggregateOutputType | null
    _max: AnalyticsReportMaxAggregateOutputType | null
  }

  type GetAnalyticsReportGroupByPayload<T extends AnalyticsReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnalyticsReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnalyticsReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnalyticsReportGroupByOutputType[P]>
            : GetScalarType<T[P], AnalyticsReportGroupByOutputType[P]>
        }
      >
    >


  export type AnalyticsReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nightclubId?: boolean
    type?: boolean
    report?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    nightclub?: boolean | NightclubDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["analyticsReport"]>

  export type AnalyticsReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nightclubId?: boolean
    type?: boolean
    report?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    nightclub?: boolean | NightclubDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["analyticsReport"]>

  export type AnalyticsReportSelectScalar = {
    id?: boolean
    nightclubId?: boolean
    type?: boolean
    report?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AnalyticsReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    nightclub?: boolean | NightclubDefaultArgs<ExtArgs>
  }
  export type AnalyticsReportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    nightclub?: boolean | NightclubDefaultArgs<ExtArgs>
  }

  export type $AnalyticsReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AnalyticsReport"
    objects: {
      nightclub: Prisma.$NightclubPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nightclubId: string
      type: string
      report: Prisma.JsonValue
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["analyticsReport"]>
    composites: {}
  }

  type AnalyticsReportGetPayload<S extends boolean | null | undefined | AnalyticsReportDefaultArgs> = $Result.GetResult<Prisma.$AnalyticsReportPayload, S>

  type AnalyticsReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AnalyticsReportFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AnalyticsReportCountAggregateInputType | true
    }

  export interface AnalyticsReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AnalyticsReport'], meta: { name: 'AnalyticsReport' } }
    /**
     * Find zero or one AnalyticsReport that matches the filter.
     * @param {AnalyticsReportFindUniqueArgs} args - Arguments to find a AnalyticsReport
     * @example
     * // Get one AnalyticsReport
     * const analyticsReport = await prisma.analyticsReport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AnalyticsReportFindUniqueArgs>(args: SelectSubset<T, AnalyticsReportFindUniqueArgs<ExtArgs>>): Prisma__AnalyticsReportClient<$Result.GetResult<Prisma.$AnalyticsReportPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AnalyticsReport that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AnalyticsReportFindUniqueOrThrowArgs} args - Arguments to find a AnalyticsReport
     * @example
     * // Get one AnalyticsReport
     * const analyticsReport = await prisma.analyticsReport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AnalyticsReportFindUniqueOrThrowArgs>(args: SelectSubset<T, AnalyticsReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AnalyticsReportClient<$Result.GetResult<Prisma.$AnalyticsReportPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AnalyticsReport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsReportFindFirstArgs} args - Arguments to find a AnalyticsReport
     * @example
     * // Get one AnalyticsReport
     * const analyticsReport = await prisma.analyticsReport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AnalyticsReportFindFirstArgs>(args?: SelectSubset<T, AnalyticsReportFindFirstArgs<ExtArgs>>): Prisma__AnalyticsReportClient<$Result.GetResult<Prisma.$AnalyticsReportPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AnalyticsReport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsReportFindFirstOrThrowArgs} args - Arguments to find a AnalyticsReport
     * @example
     * // Get one AnalyticsReport
     * const analyticsReport = await prisma.analyticsReport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AnalyticsReportFindFirstOrThrowArgs>(args?: SelectSubset<T, AnalyticsReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__AnalyticsReportClient<$Result.GetResult<Prisma.$AnalyticsReportPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AnalyticsReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AnalyticsReports
     * const analyticsReports = await prisma.analyticsReport.findMany()
     * 
     * // Get first 10 AnalyticsReports
     * const analyticsReports = await prisma.analyticsReport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const analyticsReportWithIdOnly = await prisma.analyticsReport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AnalyticsReportFindManyArgs>(args?: SelectSubset<T, AnalyticsReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalyticsReportPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AnalyticsReport.
     * @param {AnalyticsReportCreateArgs} args - Arguments to create a AnalyticsReport.
     * @example
     * // Create one AnalyticsReport
     * const AnalyticsReport = await prisma.analyticsReport.create({
     *   data: {
     *     // ... data to create a AnalyticsReport
     *   }
     * })
     * 
     */
    create<T extends AnalyticsReportCreateArgs>(args: SelectSubset<T, AnalyticsReportCreateArgs<ExtArgs>>): Prisma__AnalyticsReportClient<$Result.GetResult<Prisma.$AnalyticsReportPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AnalyticsReports.
     * @param {AnalyticsReportCreateManyArgs} args - Arguments to create many AnalyticsReports.
     * @example
     * // Create many AnalyticsReports
     * const analyticsReport = await prisma.analyticsReport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AnalyticsReportCreateManyArgs>(args?: SelectSubset<T, AnalyticsReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AnalyticsReports and returns the data saved in the database.
     * @param {AnalyticsReportCreateManyAndReturnArgs} args - Arguments to create many AnalyticsReports.
     * @example
     * // Create many AnalyticsReports
     * const analyticsReport = await prisma.analyticsReport.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AnalyticsReports and only return the `id`
     * const analyticsReportWithIdOnly = await prisma.analyticsReport.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AnalyticsReportCreateManyAndReturnArgs>(args?: SelectSubset<T, AnalyticsReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnalyticsReportPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AnalyticsReport.
     * @param {AnalyticsReportDeleteArgs} args - Arguments to delete one AnalyticsReport.
     * @example
     * // Delete one AnalyticsReport
     * const AnalyticsReport = await prisma.analyticsReport.delete({
     *   where: {
     *     // ... filter to delete one AnalyticsReport
     *   }
     * })
     * 
     */
    delete<T extends AnalyticsReportDeleteArgs>(args: SelectSubset<T, AnalyticsReportDeleteArgs<ExtArgs>>): Prisma__AnalyticsReportClient<$Result.GetResult<Prisma.$AnalyticsReportPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AnalyticsReport.
     * @param {AnalyticsReportUpdateArgs} args - Arguments to update one AnalyticsReport.
     * @example
     * // Update one AnalyticsReport
     * const analyticsReport = await prisma.analyticsReport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AnalyticsReportUpdateArgs>(args: SelectSubset<T, AnalyticsReportUpdateArgs<ExtArgs>>): Prisma__AnalyticsReportClient<$Result.GetResult<Prisma.$AnalyticsReportPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AnalyticsReports.
     * @param {AnalyticsReportDeleteManyArgs} args - Arguments to filter AnalyticsReports to delete.
     * @example
     * // Delete a few AnalyticsReports
     * const { count } = await prisma.analyticsReport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AnalyticsReportDeleteManyArgs>(args?: SelectSubset<T, AnalyticsReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AnalyticsReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AnalyticsReports
     * const analyticsReport = await prisma.analyticsReport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AnalyticsReportUpdateManyArgs>(args: SelectSubset<T, AnalyticsReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AnalyticsReport.
     * @param {AnalyticsReportUpsertArgs} args - Arguments to update or create a AnalyticsReport.
     * @example
     * // Update or create a AnalyticsReport
     * const analyticsReport = await prisma.analyticsReport.upsert({
     *   create: {
     *     // ... data to create a AnalyticsReport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AnalyticsReport we want to update
     *   }
     * })
     */
    upsert<T extends AnalyticsReportUpsertArgs>(args: SelectSubset<T, AnalyticsReportUpsertArgs<ExtArgs>>): Prisma__AnalyticsReportClient<$Result.GetResult<Prisma.$AnalyticsReportPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AnalyticsReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsReportCountArgs} args - Arguments to filter AnalyticsReports to count.
     * @example
     * // Count the number of AnalyticsReports
     * const count = await prisma.analyticsReport.count({
     *   where: {
     *     // ... the filter for the AnalyticsReports we want to count
     *   }
     * })
    **/
    count<T extends AnalyticsReportCountArgs>(
      args?: Subset<T, AnalyticsReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnalyticsReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AnalyticsReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnalyticsReportAggregateArgs>(args: Subset<T, AnalyticsReportAggregateArgs>): Prisma.PrismaPromise<GetAnalyticsReportAggregateType<T>>

    /**
     * Group by AnalyticsReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnalyticsReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnalyticsReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnalyticsReportGroupByArgs['orderBy'] }
        : { orderBy?: AnalyticsReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnalyticsReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnalyticsReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AnalyticsReport model
   */
  readonly fields: AnalyticsReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AnalyticsReport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnalyticsReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    nightclub<T extends NightclubDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NightclubDefaultArgs<ExtArgs>>): Prisma__NightclubClient<$Result.GetResult<Prisma.$NightclubPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AnalyticsReport model
   */ 
  interface AnalyticsReportFieldRefs {
    readonly id: FieldRef<"AnalyticsReport", 'String'>
    readonly nightclubId: FieldRef<"AnalyticsReport", 'String'>
    readonly type: FieldRef<"AnalyticsReport", 'String'>
    readonly report: FieldRef<"AnalyticsReport", 'Json'>
    readonly metadata: FieldRef<"AnalyticsReport", 'Json'>
    readonly createdAt: FieldRef<"AnalyticsReport", 'DateTime'>
    readonly updatedAt: FieldRef<"AnalyticsReport", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AnalyticsReport findUnique
   */
  export type AnalyticsReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsReport
     */
    select?: AnalyticsReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsReportInclude<ExtArgs> | null
    /**
     * Filter, which AnalyticsReport to fetch.
     */
    where: AnalyticsReportWhereUniqueInput
  }

  /**
   * AnalyticsReport findUniqueOrThrow
   */
  export type AnalyticsReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsReport
     */
    select?: AnalyticsReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsReportInclude<ExtArgs> | null
    /**
     * Filter, which AnalyticsReport to fetch.
     */
    where: AnalyticsReportWhereUniqueInput
  }

  /**
   * AnalyticsReport findFirst
   */
  export type AnalyticsReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsReport
     */
    select?: AnalyticsReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsReportInclude<ExtArgs> | null
    /**
     * Filter, which AnalyticsReport to fetch.
     */
    where?: AnalyticsReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticsReports to fetch.
     */
    orderBy?: AnalyticsReportOrderByWithRelationInput | AnalyticsReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnalyticsReports.
     */
    cursor?: AnalyticsReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticsReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticsReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnalyticsReports.
     */
    distinct?: AnalyticsReportScalarFieldEnum | AnalyticsReportScalarFieldEnum[]
  }

  /**
   * AnalyticsReport findFirstOrThrow
   */
  export type AnalyticsReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsReport
     */
    select?: AnalyticsReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsReportInclude<ExtArgs> | null
    /**
     * Filter, which AnalyticsReport to fetch.
     */
    where?: AnalyticsReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticsReports to fetch.
     */
    orderBy?: AnalyticsReportOrderByWithRelationInput | AnalyticsReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AnalyticsReports.
     */
    cursor?: AnalyticsReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticsReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticsReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AnalyticsReports.
     */
    distinct?: AnalyticsReportScalarFieldEnum | AnalyticsReportScalarFieldEnum[]
  }

  /**
   * AnalyticsReport findMany
   */
  export type AnalyticsReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsReport
     */
    select?: AnalyticsReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsReportInclude<ExtArgs> | null
    /**
     * Filter, which AnalyticsReports to fetch.
     */
    where?: AnalyticsReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AnalyticsReports to fetch.
     */
    orderBy?: AnalyticsReportOrderByWithRelationInput | AnalyticsReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AnalyticsReports.
     */
    cursor?: AnalyticsReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AnalyticsReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AnalyticsReports.
     */
    skip?: number
    distinct?: AnalyticsReportScalarFieldEnum | AnalyticsReportScalarFieldEnum[]
  }

  /**
   * AnalyticsReport create
   */
  export type AnalyticsReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsReport
     */
    select?: AnalyticsReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsReportInclude<ExtArgs> | null
    /**
     * The data needed to create a AnalyticsReport.
     */
    data: XOR<AnalyticsReportCreateInput, AnalyticsReportUncheckedCreateInput>
  }

  /**
   * AnalyticsReport createMany
   */
  export type AnalyticsReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AnalyticsReports.
     */
    data: AnalyticsReportCreateManyInput | AnalyticsReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AnalyticsReport createManyAndReturn
   */
  export type AnalyticsReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsReport
     */
    select?: AnalyticsReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AnalyticsReports.
     */
    data: AnalyticsReportCreateManyInput | AnalyticsReportCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsReportIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AnalyticsReport update
   */
  export type AnalyticsReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsReport
     */
    select?: AnalyticsReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsReportInclude<ExtArgs> | null
    /**
     * The data needed to update a AnalyticsReport.
     */
    data: XOR<AnalyticsReportUpdateInput, AnalyticsReportUncheckedUpdateInput>
    /**
     * Choose, which AnalyticsReport to update.
     */
    where: AnalyticsReportWhereUniqueInput
  }

  /**
   * AnalyticsReport updateMany
   */
  export type AnalyticsReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AnalyticsReports.
     */
    data: XOR<AnalyticsReportUpdateManyMutationInput, AnalyticsReportUncheckedUpdateManyInput>
    /**
     * Filter which AnalyticsReports to update
     */
    where?: AnalyticsReportWhereInput
  }

  /**
   * AnalyticsReport upsert
   */
  export type AnalyticsReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsReport
     */
    select?: AnalyticsReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsReportInclude<ExtArgs> | null
    /**
     * The filter to search for the AnalyticsReport to update in case it exists.
     */
    where: AnalyticsReportWhereUniqueInput
    /**
     * In case the AnalyticsReport found by the `where` argument doesn't exist, create a new AnalyticsReport with this data.
     */
    create: XOR<AnalyticsReportCreateInput, AnalyticsReportUncheckedCreateInput>
    /**
     * In case the AnalyticsReport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnalyticsReportUpdateInput, AnalyticsReportUncheckedUpdateInput>
  }

  /**
   * AnalyticsReport delete
   */
  export type AnalyticsReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsReport
     */
    select?: AnalyticsReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsReportInclude<ExtArgs> | null
    /**
     * Filter which AnalyticsReport to delete.
     */
    where: AnalyticsReportWhereUniqueInput
  }

  /**
   * AnalyticsReport deleteMany
   */
  export type AnalyticsReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AnalyticsReports to delete
     */
    where?: AnalyticsReportWhereInput
  }

  /**
   * AnalyticsReport without action
   */
  export type AnalyticsReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnalyticsReport
     */
    select?: AnalyticsReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnalyticsReportInclude<ExtArgs> | null
  }


  /**
   * Model AIModel
   */

  export type AggregateAIModel = {
    _count: AIModelCountAggregateOutputType | null
    _min: AIModelMinAggregateOutputType | null
    _max: AIModelMaxAggregateOutputType | null
  }

  export type AIModelMinAggregateOutputType = {
    id: string | null
    type: string | null
    name: string | null
    version: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AIModelMaxAggregateOutputType = {
    id: string | null
    type: string | null
    name: string | null
    version: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AIModelCountAggregateOutputType = {
    id: number
    type: number
    name: number
    version: number
    status: number
    config: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AIModelMinAggregateInputType = {
    id?: true
    type?: true
    name?: true
    version?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AIModelMaxAggregateInputType = {
    id?: true
    type?: true
    name?: true
    version?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AIModelCountAggregateInputType = {
    id?: true
    type?: true
    name?: true
    version?: true
    status?: true
    config?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AIModelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIModel to aggregate.
     */
    where?: AIModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIModels to fetch.
     */
    orderBy?: AIModelOrderByWithRelationInput | AIModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AIModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AIModels
    **/
    _count?: true | AIModelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AIModelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AIModelMaxAggregateInputType
  }

  export type GetAIModelAggregateType<T extends AIModelAggregateArgs> = {
        [P in keyof T & keyof AggregateAIModel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAIModel[P]>
      : GetScalarType<T[P], AggregateAIModel[P]>
  }




  export type AIModelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AIModelWhereInput
    orderBy?: AIModelOrderByWithAggregationInput | AIModelOrderByWithAggregationInput[]
    by: AIModelScalarFieldEnum[] | AIModelScalarFieldEnum
    having?: AIModelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AIModelCountAggregateInputType | true
    _min?: AIModelMinAggregateInputType
    _max?: AIModelMaxAggregateInputType
  }

  export type AIModelGroupByOutputType = {
    id: string
    type: string
    name: string
    version: string
    status: string
    config: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: AIModelCountAggregateOutputType | null
    _min: AIModelMinAggregateOutputType | null
    _max: AIModelMaxAggregateOutputType | null
  }

  type GetAIModelGroupByPayload<T extends AIModelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AIModelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AIModelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AIModelGroupByOutputType[P]>
            : GetScalarType<T[P], AIModelGroupByOutputType[P]>
        }
      >
    >


  export type AIModelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    name?: boolean
    version?: boolean
    status?: boolean
    config?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    predictions?: boolean | AIModel$predictionsArgs<ExtArgs>
    anomalies?: boolean | AIModel$anomaliesArgs<ExtArgs>
    behaviorAnalyses?: boolean | AIModel$behaviorAnalysesArgs<ExtArgs>
    _count?: boolean | AIModelCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["aIModel"]>

  export type AIModelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    name?: boolean
    version?: boolean
    status?: boolean
    config?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["aIModel"]>

  export type AIModelSelectScalar = {
    id?: boolean
    type?: boolean
    name?: boolean
    version?: boolean
    status?: boolean
    config?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AIModelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    predictions?: boolean | AIModel$predictionsArgs<ExtArgs>
    anomalies?: boolean | AIModel$anomaliesArgs<ExtArgs>
    behaviorAnalyses?: boolean | AIModel$behaviorAnalysesArgs<ExtArgs>
    _count?: boolean | AIModelCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AIModelIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AIModelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AIModel"
    objects: {
      predictions: Prisma.$PredictionPayload<ExtArgs>[]
      anomalies: Prisma.$AnomalyPayload<ExtArgs>[]
      behaviorAnalyses: Prisma.$BehaviorAnalysisPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: string
      name: string
      version: string
      status: string
      config: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["aIModel"]>
    composites: {}
  }

  type AIModelGetPayload<S extends boolean | null | undefined | AIModelDefaultArgs> = $Result.GetResult<Prisma.$AIModelPayload, S>

  type AIModelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AIModelFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AIModelCountAggregateInputType | true
    }

  export interface AIModelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AIModel'], meta: { name: 'AIModel' } }
    /**
     * Find zero or one AIModel that matches the filter.
     * @param {AIModelFindUniqueArgs} args - Arguments to find a AIModel
     * @example
     * // Get one AIModel
     * const aIModel = await prisma.aIModel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AIModelFindUniqueArgs>(args: SelectSubset<T, AIModelFindUniqueArgs<ExtArgs>>): Prisma__AIModelClient<$Result.GetResult<Prisma.$AIModelPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AIModel that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AIModelFindUniqueOrThrowArgs} args - Arguments to find a AIModel
     * @example
     * // Get one AIModel
     * const aIModel = await prisma.aIModel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AIModelFindUniqueOrThrowArgs>(args: SelectSubset<T, AIModelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AIModelClient<$Result.GetResult<Prisma.$AIModelPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AIModel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIModelFindFirstArgs} args - Arguments to find a AIModel
     * @example
     * // Get one AIModel
     * const aIModel = await prisma.aIModel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AIModelFindFirstArgs>(args?: SelectSubset<T, AIModelFindFirstArgs<ExtArgs>>): Prisma__AIModelClient<$Result.GetResult<Prisma.$AIModelPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AIModel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIModelFindFirstOrThrowArgs} args - Arguments to find a AIModel
     * @example
     * // Get one AIModel
     * const aIModel = await prisma.aIModel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AIModelFindFirstOrThrowArgs>(args?: SelectSubset<T, AIModelFindFirstOrThrowArgs<ExtArgs>>): Prisma__AIModelClient<$Result.GetResult<Prisma.$AIModelPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AIModels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIModelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AIModels
     * const aIModels = await prisma.aIModel.findMany()
     * 
     * // Get first 10 AIModels
     * const aIModels = await prisma.aIModel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aIModelWithIdOnly = await prisma.aIModel.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AIModelFindManyArgs>(args?: SelectSubset<T, AIModelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIModelPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AIModel.
     * @param {AIModelCreateArgs} args - Arguments to create a AIModel.
     * @example
     * // Create one AIModel
     * const AIModel = await prisma.aIModel.create({
     *   data: {
     *     // ... data to create a AIModel
     *   }
     * })
     * 
     */
    create<T extends AIModelCreateArgs>(args: SelectSubset<T, AIModelCreateArgs<ExtArgs>>): Prisma__AIModelClient<$Result.GetResult<Prisma.$AIModelPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AIModels.
     * @param {AIModelCreateManyArgs} args - Arguments to create many AIModels.
     * @example
     * // Create many AIModels
     * const aIModel = await prisma.aIModel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AIModelCreateManyArgs>(args?: SelectSubset<T, AIModelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AIModels and returns the data saved in the database.
     * @param {AIModelCreateManyAndReturnArgs} args - Arguments to create many AIModels.
     * @example
     * // Create many AIModels
     * const aIModel = await prisma.aIModel.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AIModels and only return the `id`
     * const aIModelWithIdOnly = await prisma.aIModel.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AIModelCreateManyAndReturnArgs>(args?: SelectSubset<T, AIModelCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AIModelPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AIModel.
     * @param {AIModelDeleteArgs} args - Arguments to delete one AIModel.
     * @example
     * // Delete one AIModel
     * const AIModel = await prisma.aIModel.delete({
     *   where: {
     *     // ... filter to delete one AIModel
     *   }
     * })
     * 
     */
    delete<T extends AIModelDeleteArgs>(args: SelectSubset<T, AIModelDeleteArgs<ExtArgs>>): Prisma__AIModelClient<$Result.GetResult<Prisma.$AIModelPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AIModel.
     * @param {AIModelUpdateArgs} args - Arguments to update one AIModel.
     * @example
     * // Update one AIModel
     * const aIModel = await prisma.aIModel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AIModelUpdateArgs>(args: SelectSubset<T, AIModelUpdateArgs<ExtArgs>>): Prisma__AIModelClient<$Result.GetResult<Prisma.$AIModelPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AIModels.
     * @param {AIModelDeleteManyArgs} args - Arguments to filter AIModels to delete.
     * @example
     * // Delete a few AIModels
     * const { count } = await prisma.aIModel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AIModelDeleteManyArgs>(args?: SelectSubset<T, AIModelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AIModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIModelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AIModels
     * const aIModel = await prisma.aIModel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AIModelUpdateManyArgs>(args: SelectSubset<T, AIModelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AIModel.
     * @param {AIModelUpsertArgs} args - Arguments to update or create a AIModel.
     * @example
     * // Update or create a AIModel
     * const aIModel = await prisma.aIModel.upsert({
     *   create: {
     *     // ... data to create a AIModel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AIModel we want to update
     *   }
     * })
     */
    upsert<T extends AIModelUpsertArgs>(args: SelectSubset<T, AIModelUpsertArgs<ExtArgs>>): Prisma__AIModelClient<$Result.GetResult<Prisma.$AIModelPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AIModels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIModelCountArgs} args - Arguments to filter AIModels to count.
     * @example
     * // Count the number of AIModels
     * const count = await prisma.aIModel.count({
     *   where: {
     *     // ... the filter for the AIModels we want to count
     *   }
     * })
    **/
    count<T extends AIModelCountArgs>(
      args?: Subset<T, AIModelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AIModelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AIModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIModelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AIModelAggregateArgs>(args: Subset<T, AIModelAggregateArgs>): Prisma.PrismaPromise<GetAIModelAggregateType<T>>

    /**
     * Group by AIModel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AIModelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AIModelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AIModelGroupByArgs['orderBy'] }
        : { orderBy?: AIModelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AIModelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAIModelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AIModel model
   */
  readonly fields: AIModelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AIModel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AIModelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    predictions<T extends AIModel$predictionsArgs<ExtArgs> = {}>(args?: Subset<T, AIModel$predictionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PredictionPayload<ExtArgs>, T, "findMany"> | Null>
    anomalies<T extends AIModel$anomaliesArgs<ExtArgs> = {}>(args?: Subset<T, AIModel$anomaliesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnomalyPayload<ExtArgs>, T, "findMany"> | Null>
    behaviorAnalyses<T extends AIModel$behaviorAnalysesArgs<ExtArgs> = {}>(args?: Subset<T, AIModel$behaviorAnalysesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BehaviorAnalysisPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AIModel model
   */ 
  interface AIModelFieldRefs {
    readonly id: FieldRef<"AIModel", 'String'>
    readonly type: FieldRef<"AIModel", 'String'>
    readonly name: FieldRef<"AIModel", 'String'>
    readonly version: FieldRef<"AIModel", 'String'>
    readonly status: FieldRef<"AIModel", 'String'>
    readonly config: FieldRef<"AIModel", 'Json'>
    readonly createdAt: FieldRef<"AIModel", 'DateTime'>
    readonly updatedAt: FieldRef<"AIModel", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AIModel findUnique
   */
  export type AIModelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIModel
     */
    select?: AIModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIModelInclude<ExtArgs> | null
    /**
     * Filter, which AIModel to fetch.
     */
    where: AIModelWhereUniqueInput
  }

  /**
   * AIModel findUniqueOrThrow
   */
  export type AIModelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIModel
     */
    select?: AIModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIModelInclude<ExtArgs> | null
    /**
     * Filter, which AIModel to fetch.
     */
    where: AIModelWhereUniqueInput
  }

  /**
   * AIModel findFirst
   */
  export type AIModelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIModel
     */
    select?: AIModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIModelInclude<ExtArgs> | null
    /**
     * Filter, which AIModel to fetch.
     */
    where?: AIModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIModels to fetch.
     */
    orderBy?: AIModelOrderByWithRelationInput | AIModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIModels.
     */
    cursor?: AIModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIModels.
     */
    distinct?: AIModelScalarFieldEnum | AIModelScalarFieldEnum[]
  }

  /**
   * AIModel findFirstOrThrow
   */
  export type AIModelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIModel
     */
    select?: AIModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIModelInclude<ExtArgs> | null
    /**
     * Filter, which AIModel to fetch.
     */
    where?: AIModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIModels to fetch.
     */
    orderBy?: AIModelOrderByWithRelationInput | AIModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AIModels.
     */
    cursor?: AIModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIModels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AIModels.
     */
    distinct?: AIModelScalarFieldEnum | AIModelScalarFieldEnum[]
  }

  /**
   * AIModel findMany
   */
  export type AIModelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIModel
     */
    select?: AIModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIModelInclude<ExtArgs> | null
    /**
     * Filter, which AIModels to fetch.
     */
    where?: AIModelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AIModels to fetch.
     */
    orderBy?: AIModelOrderByWithRelationInput | AIModelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AIModels.
     */
    cursor?: AIModelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AIModels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AIModels.
     */
    skip?: number
    distinct?: AIModelScalarFieldEnum | AIModelScalarFieldEnum[]
  }

  /**
   * AIModel create
   */
  export type AIModelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIModel
     */
    select?: AIModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIModelInclude<ExtArgs> | null
    /**
     * The data needed to create a AIModel.
     */
    data: XOR<AIModelCreateInput, AIModelUncheckedCreateInput>
  }

  /**
   * AIModel createMany
   */
  export type AIModelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AIModels.
     */
    data: AIModelCreateManyInput | AIModelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AIModel createManyAndReturn
   */
  export type AIModelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIModel
     */
    select?: AIModelSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AIModels.
     */
    data: AIModelCreateManyInput | AIModelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AIModel update
   */
  export type AIModelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIModel
     */
    select?: AIModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIModelInclude<ExtArgs> | null
    /**
     * The data needed to update a AIModel.
     */
    data: XOR<AIModelUpdateInput, AIModelUncheckedUpdateInput>
    /**
     * Choose, which AIModel to update.
     */
    where: AIModelWhereUniqueInput
  }

  /**
   * AIModel updateMany
   */
  export type AIModelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AIModels.
     */
    data: XOR<AIModelUpdateManyMutationInput, AIModelUncheckedUpdateManyInput>
    /**
     * Filter which AIModels to update
     */
    where?: AIModelWhereInput
  }

  /**
   * AIModel upsert
   */
  export type AIModelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIModel
     */
    select?: AIModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIModelInclude<ExtArgs> | null
    /**
     * The filter to search for the AIModel to update in case it exists.
     */
    where: AIModelWhereUniqueInput
    /**
     * In case the AIModel found by the `where` argument doesn't exist, create a new AIModel with this data.
     */
    create: XOR<AIModelCreateInput, AIModelUncheckedCreateInput>
    /**
     * In case the AIModel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AIModelUpdateInput, AIModelUncheckedUpdateInput>
  }

  /**
   * AIModel delete
   */
  export type AIModelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIModel
     */
    select?: AIModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIModelInclude<ExtArgs> | null
    /**
     * Filter which AIModel to delete.
     */
    where: AIModelWhereUniqueInput
  }

  /**
   * AIModel deleteMany
   */
  export type AIModelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AIModels to delete
     */
    where?: AIModelWhereInput
  }

  /**
   * AIModel.predictions
   */
  export type AIModel$predictionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prediction
     */
    select?: PredictionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PredictionInclude<ExtArgs> | null
    where?: PredictionWhereInput
    orderBy?: PredictionOrderByWithRelationInput | PredictionOrderByWithRelationInput[]
    cursor?: PredictionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PredictionScalarFieldEnum | PredictionScalarFieldEnum[]
  }

  /**
   * AIModel.anomalies
   */
  export type AIModel$anomaliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Anomaly
     */
    select?: AnomalySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnomalyInclude<ExtArgs> | null
    where?: AnomalyWhereInput
    orderBy?: AnomalyOrderByWithRelationInput | AnomalyOrderByWithRelationInput[]
    cursor?: AnomalyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnomalyScalarFieldEnum | AnomalyScalarFieldEnum[]
  }

  /**
   * AIModel.behaviorAnalyses
   */
  export type AIModel$behaviorAnalysesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BehaviorAnalysis
     */
    select?: BehaviorAnalysisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BehaviorAnalysisInclude<ExtArgs> | null
    where?: BehaviorAnalysisWhereInput
    orderBy?: BehaviorAnalysisOrderByWithRelationInput | BehaviorAnalysisOrderByWithRelationInput[]
    cursor?: BehaviorAnalysisWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BehaviorAnalysisScalarFieldEnum | BehaviorAnalysisScalarFieldEnum[]
  }

  /**
   * AIModel without action
   */
  export type AIModelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AIModel
     */
    select?: AIModelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AIModelInclude<ExtArgs> | null
  }


  /**
   * Model Prediction
   */

  export type AggregatePrediction = {
    _count: PredictionCountAggregateOutputType | null
    _avg: PredictionAvgAggregateOutputType | null
    _sum: PredictionSumAggregateOutputType | null
    _min: PredictionMinAggregateOutputType | null
    _max: PredictionMaxAggregateOutputType | null
  }

  export type PredictionAvgAggregateOutputType = {
    value: number | null
    confidence: number | null
  }

  export type PredictionSumAggregateOutputType = {
    value: number | null
    confidence: number | null
  }

  export type PredictionMinAggregateOutputType = {
    id: string | null
    type: string | null
    timestamp: Date | null
    value: number | null
    confidence: number | null
    nightclubId: string | null
    zoneId: string | null
    modelId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PredictionMaxAggregateOutputType = {
    id: string | null
    type: string | null
    timestamp: Date | null
    value: number | null
    confidence: number | null
    nightclubId: string | null
    zoneId: string | null
    modelId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PredictionCountAggregateOutputType = {
    id: number
    type: number
    timestamp: number
    value: number
    confidence: number
    metadata: number
    nightclubId: number
    zoneId: number
    modelId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PredictionAvgAggregateInputType = {
    value?: true
    confidence?: true
  }

  export type PredictionSumAggregateInputType = {
    value?: true
    confidence?: true
  }

  export type PredictionMinAggregateInputType = {
    id?: true
    type?: true
    timestamp?: true
    value?: true
    confidence?: true
    nightclubId?: true
    zoneId?: true
    modelId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PredictionMaxAggregateInputType = {
    id?: true
    type?: true
    timestamp?: true
    value?: true
    confidence?: true
    nightclubId?: true
    zoneId?: true
    modelId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PredictionCountAggregateInputType = {
    id?: true
    type?: true
    timestamp?: true
    value?: true
    confidence?: true
    metadata?: true
    nightclubId?: true
    zoneId?: true
    modelId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PredictionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Prediction to aggregate.
     */
    where?: PredictionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Predictions to fetch.
     */
    orderBy?: PredictionOrderByWithRelationInput | PredictionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PredictionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Predictions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Predictions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Predictions
    **/
    _count?: true | PredictionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PredictionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PredictionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PredictionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PredictionMaxAggregateInputType
  }

  export type GetPredictionAggregateType<T extends PredictionAggregateArgs> = {
        [P in keyof T & keyof AggregatePrediction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrediction[P]>
      : GetScalarType<T[P], AggregatePrediction[P]>
  }




  export type PredictionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PredictionWhereInput
    orderBy?: PredictionOrderByWithAggregationInput | PredictionOrderByWithAggregationInput[]
    by: PredictionScalarFieldEnum[] | PredictionScalarFieldEnum
    having?: PredictionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PredictionCountAggregateInputType | true
    _avg?: PredictionAvgAggregateInputType
    _sum?: PredictionSumAggregateInputType
    _min?: PredictionMinAggregateInputType
    _max?: PredictionMaxAggregateInputType
  }

  export type PredictionGroupByOutputType = {
    id: string
    type: string
    timestamp: Date
    value: number
    confidence: number
    metadata: JsonValue | null
    nightclubId: string
    zoneId: string | null
    modelId: string
    createdAt: Date
    updatedAt: Date
    _count: PredictionCountAggregateOutputType | null
    _avg: PredictionAvgAggregateOutputType | null
    _sum: PredictionSumAggregateOutputType | null
    _min: PredictionMinAggregateOutputType | null
    _max: PredictionMaxAggregateOutputType | null
  }

  type GetPredictionGroupByPayload<T extends PredictionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PredictionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PredictionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PredictionGroupByOutputType[P]>
            : GetScalarType<T[P], PredictionGroupByOutputType[P]>
        }
      >
    >


  export type PredictionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    timestamp?: boolean
    value?: boolean
    confidence?: boolean
    metadata?: boolean
    nightclubId?: boolean
    zoneId?: boolean
    modelId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    nightclub?: boolean | NightclubDefaultArgs<ExtArgs>
    zone?: boolean | Prediction$zoneArgs<ExtArgs>
    model?: boolean | AIModelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["prediction"]>

  export type PredictionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    timestamp?: boolean
    value?: boolean
    confidence?: boolean
    metadata?: boolean
    nightclubId?: boolean
    zoneId?: boolean
    modelId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    nightclub?: boolean | NightclubDefaultArgs<ExtArgs>
    zone?: boolean | Prediction$zoneArgs<ExtArgs>
    model?: boolean | AIModelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["prediction"]>

  export type PredictionSelectScalar = {
    id?: boolean
    type?: boolean
    timestamp?: boolean
    value?: boolean
    confidence?: boolean
    metadata?: boolean
    nightclubId?: boolean
    zoneId?: boolean
    modelId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PredictionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    nightclub?: boolean | NightclubDefaultArgs<ExtArgs>
    zone?: boolean | Prediction$zoneArgs<ExtArgs>
    model?: boolean | AIModelDefaultArgs<ExtArgs>
  }
  export type PredictionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    nightclub?: boolean | NightclubDefaultArgs<ExtArgs>
    zone?: boolean | Prediction$zoneArgs<ExtArgs>
    model?: boolean | AIModelDefaultArgs<ExtArgs>
  }

  export type $PredictionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Prediction"
    objects: {
      nightclub: Prisma.$NightclubPayload<ExtArgs>
      zone: Prisma.$ZonePayload<ExtArgs> | null
      model: Prisma.$AIModelPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: string
      timestamp: Date
      value: number
      confidence: number
      metadata: Prisma.JsonValue | null
      nightclubId: string
      zoneId: string | null
      modelId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["prediction"]>
    composites: {}
  }

  type PredictionGetPayload<S extends boolean | null | undefined | PredictionDefaultArgs> = $Result.GetResult<Prisma.$PredictionPayload, S>

  type PredictionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PredictionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PredictionCountAggregateInputType | true
    }

  export interface PredictionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Prediction'], meta: { name: 'Prediction' } }
    /**
     * Find zero or one Prediction that matches the filter.
     * @param {PredictionFindUniqueArgs} args - Arguments to find a Prediction
     * @example
     * // Get one Prediction
     * const prediction = await prisma.prediction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PredictionFindUniqueArgs>(args: SelectSubset<T, PredictionFindUniqueArgs<ExtArgs>>): Prisma__PredictionClient<$Result.GetResult<Prisma.$PredictionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Prediction that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PredictionFindUniqueOrThrowArgs} args - Arguments to find a Prediction
     * @example
     * // Get one Prediction
     * const prediction = await prisma.prediction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PredictionFindUniqueOrThrowArgs>(args: SelectSubset<T, PredictionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PredictionClient<$Result.GetResult<Prisma.$PredictionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Prediction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PredictionFindFirstArgs} args - Arguments to find a Prediction
     * @example
     * // Get one Prediction
     * const prediction = await prisma.prediction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PredictionFindFirstArgs>(args?: SelectSubset<T, PredictionFindFirstArgs<ExtArgs>>): Prisma__PredictionClient<$Result.GetResult<Prisma.$PredictionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Prediction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PredictionFindFirstOrThrowArgs} args - Arguments to find a Prediction
     * @example
     * // Get one Prediction
     * const prediction = await prisma.prediction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PredictionFindFirstOrThrowArgs>(args?: SelectSubset<T, PredictionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PredictionClient<$Result.GetResult<Prisma.$PredictionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Predictions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PredictionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Predictions
     * const predictions = await prisma.prediction.findMany()
     * 
     * // Get first 10 Predictions
     * const predictions = await prisma.prediction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const predictionWithIdOnly = await prisma.prediction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PredictionFindManyArgs>(args?: SelectSubset<T, PredictionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PredictionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Prediction.
     * @param {PredictionCreateArgs} args - Arguments to create a Prediction.
     * @example
     * // Create one Prediction
     * const Prediction = await prisma.prediction.create({
     *   data: {
     *     // ... data to create a Prediction
     *   }
     * })
     * 
     */
    create<T extends PredictionCreateArgs>(args: SelectSubset<T, PredictionCreateArgs<ExtArgs>>): Prisma__PredictionClient<$Result.GetResult<Prisma.$PredictionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Predictions.
     * @param {PredictionCreateManyArgs} args - Arguments to create many Predictions.
     * @example
     * // Create many Predictions
     * const prediction = await prisma.prediction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PredictionCreateManyArgs>(args?: SelectSubset<T, PredictionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Predictions and returns the data saved in the database.
     * @param {PredictionCreateManyAndReturnArgs} args - Arguments to create many Predictions.
     * @example
     * // Create many Predictions
     * const prediction = await prisma.prediction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Predictions and only return the `id`
     * const predictionWithIdOnly = await prisma.prediction.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PredictionCreateManyAndReturnArgs>(args?: SelectSubset<T, PredictionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PredictionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Prediction.
     * @param {PredictionDeleteArgs} args - Arguments to delete one Prediction.
     * @example
     * // Delete one Prediction
     * const Prediction = await prisma.prediction.delete({
     *   where: {
     *     // ... filter to delete one Prediction
     *   }
     * })
     * 
     */
    delete<T extends PredictionDeleteArgs>(args: SelectSubset<T, PredictionDeleteArgs<ExtArgs>>): Prisma__PredictionClient<$Result.GetResult<Prisma.$PredictionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Prediction.
     * @param {PredictionUpdateArgs} args - Arguments to update one Prediction.
     * @example
     * // Update one Prediction
     * const prediction = await prisma.prediction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PredictionUpdateArgs>(args: SelectSubset<T, PredictionUpdateArgs<ExtArgs>>): Prisma__PredictionClient<$Result.GetResult<Prisma.$PredictionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Predictions.
     * @param {PredictionDeleteManyArgs} args - Arguments to filter Predictions to delete.
     * @example
     * // Delete a few Predictions
     * const { count } = await prisma.prediction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PredictionDeleteManyArgs>(args?: SelectSubset<T, PredictionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Predictions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PredictionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Predictions
     * const prediction = await prisma.prediction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PredictionUpdateManyArgs>(args: SelectSubset<T, PredictionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Prediction.
     * @param {PredictionUpsertArgs} args - Arguments to update or create a Prediction.
     * @example
     * // Update or create a Prediction
     * const prediction = await prisma.prediction.upsert({
     *   create: {
     *     // ... data to create a Prediction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Prediction we want to update
     *   }
     * })
     */
    upsert<T extends PredictionUpsertArgs>(args: SelectSubset<T, PredictionUpsertArgs<ExtArgs>>): Prisma__PredictionClient<$Result.GetResult<Prisma.$PredictionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Predictions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PredictionCountArgs} args - Arguments to filter Predictions to count.
     * @example
     * // Count the number of Predictions
     * const count = await prisma.prediction.count({
     *   where: {
     *     // ... the filter for the Predictions we want to count
     *   }
     * })
    **/
    count<T extends PredictionCountArgs>(
      args?: Subset<T, PredictionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PredictionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Prediction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PredictionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PredictionAggregateArgs>(args: Subset<T, PredictionAggregateArgs>): Prisma.PrismaPromise<GetPredictionAggregateType<T>>

    /**
     * Group by Prediction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PredictionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PredictionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PredictionGroupByArgs['orderBy'] }
        : { orderBy?: PredictionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PredictionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPredictionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Prediction model
   */
  readonly fields: PredictionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Prediction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PredictionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    nightclub<T extends NightclubDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NightclubDefaultArgs<ExtArgs>>): Prisma__NightclubClient<$Result.GetResult<Prisma.$NightclubPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    zone<T extends Prediction$zoneArgs<ExtArgs> = {}>(args?: Subset<T, Prediction$zoneArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    model<T extends AIModelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AIModelDefaultArgs<ExtArgs>>): Prisma__AIModelClient<$Result.GetResult<Prisma.$AIModelPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Prediction model
   */ 
  interface PredictionFieldRefs {
    readonly id: FieldRef<"Prediction", 'String'>
    readonly type: FieldRef<"Prediction", 'String'>
    readonly timestamp: FieldRef<"Prediction", 'DateTime'>
    readonly value: FieldRef<"Prediction", 'Float'>
    readonly confidence: FieldRef<"Prediction", 'Float'>
    readonly metadata: FieldRef<"Prediction", 'Json'>
    readonly nightclubId: FieldRef<"Prediction", 'String'>
    readonly zoneId: FieldRef<"Prediction", 'String'>
    readonly modelId: FieldRef<"Prediction", 'String'>
    readonly createdAt: FieldRef<"Prediction", 'DateTime'>
    readonly updatedAt: FieldRef<"Prediction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Prediction findUnique
   */
  export type PredictionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prediction
     */
    select?: PredictionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PredictionInclude<ExtArgs> | null
    /**
     * Filter, which Prediction to fetch.
     */
    where: PredictionWhereUniqueInput
  }

  /**
   * Prediction findUniqueOrThrow
   */
  export type PredictionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prediction
     */
    select?: PredictionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PredictionInclude<ExtArgs> | null
    /**
     * Filter, which Prediction to fetch.
     */
    where: PredictionWhereUniqueInput
  }

  /**
   * Prediction findFirst
   */
  export type PredictionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prediction
     */
    select?: PredictionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PredictionInclude<ExtArgs> | null
    /**
     * Filter, which Prediction to fetch.
     */
    where?: PredictionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Predictions to fetch.
     */
    orderBy?: PredictionOrderByWithRelationInput | PredictionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Predictions.
     */
    cursor?: PredictionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Predictions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Predictions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Predictions.
     */
    distinct?: PredictionScalarFieldEnum | PredictionScalarFieldEnum[]
  }

  /**
   * Prediction findFirstOrThrow
   */
  export type PredictionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prediction
     */
    select?: PredictionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PredictionInclude<ExtArgs> | null
    /**
     * Filter, which Prediction to fetch.
     */
    where?: PredictionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Predictions to fetch.
     */
    orderBy?: PredictionOrderByWithRelationInput | PredictionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Predictions.
     */
    cursor?: PredictionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Predictions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Predictions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Predictions.
     */
    distinct?: PredictionScalarFieldEnum | PredictionScalarFieldEnum[]
  }

  /**
   * Prediction findMany
   */
  export type PredictionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prediction
     */
    select?: PredictionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PredictionInclude<ExtArgs> | null
    /**
     * Filter, which Predictions to fetch.
     */
    where?: PredictionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Predictions to fetch.
     */
    orderBy?: PredictionOrderByWithRelationInput | PredictionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Predictions.
     */
    cursor?: PredictionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Predictions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Predictions.
     */
    skip?: number
    distinct?: PredictionScalarFieldEnum | PredictionScalarFieldEnum[]
  }

  /**
   * Prediction create
   */
  export type PredictionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prediction
     */
    select?: PredictionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PredictionInclude<ExtArgs> | null
    /**
     * The data needed to create a Prediction.
     */
    data: XOR<PredictionCreateInput, PredictionUncheckedCreateInput>
  }

  /**
   * Prediction createMany
   */
  export type PredictionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Predictions.
     */
    data: PredictionCreateManyInput | PredictionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Prediction createManyAndReturn
   */
  export type PredictionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prediction
     */
    select?: PredictionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Predictions.
     */
    data: PredictionCreateManyInput | PredictionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PredictionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Prediction update
   */
  export type PredictionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prediction
     */
    select?: PredictionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PredictionInclude<ExtArgs> | null
    /**
     * The data needed to update a Prediction.
     */
    data: XOR<PredictionUpdateInput, PredictionUncheckedUpdateInput>
    /**
     * Choose, which Prediction to update.
     */
    where: PredictionWhereUniqueInput
  }

  /**
   * Prediction updateMany
   */
  export type PredictionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Predictions.
     */
    data: XOR<PredictionUpdateManyMutationInput, PredictionUncheckedUpdateManyInput>
    /**
     * Filter which Predictions to update
     */
    where?: PredictionWhereInput
  }

  /**
   * Prediction upsert
   */
  export type PredictionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prediction
     */
    select?: PredictionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PredictionInclude<ExtArgs> | null
    /**
     * The filter to search for the Prediction to update in case it exists.
     */
    where: PredictionWhereUniqueInput
    /**
     * In case the Prediction found by the `where` argument doesn't exist, create a new Prediction with this data.
     */
    create: XOR<PredictionCreateInput, PredictionUncheckedCreateInput>
    /**
     * In case the Prediction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PredictionUpdateInput, PredictionUncheckedUpdateInput>
  }

  /**
   * Prediction delete
   */
  export type PredictionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prediction
     */
    select?: PredictionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PredictionInclude<ExtArgs> | null
    /**
     * Filter which Prediction to delete.
     */
    where: PredictionWhereUniqueInput
  }

  /**
   * Prediction deleteMany
   */
  export type PredictionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Predictions to delete
     */
    where?: PredictionWhereInput
  }

  /**
   * Prediction.zone
   */
  export type Prediction$zoneArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    where?: ZoneWhereInput
  }

  /**
   * Prediction without action
   */
  export type PredictionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prediction
     */
    select?: PredictionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PredictionInclude<ExtArgs> | null
  }


  /**
   * Model Anomaly
   */

  export type AggregateAnomaly = {
    _count: AnomalyCountAggregateOutputType | null
    _min: AnomalyMinAggregateOutputType | null
    _max: AnomalyMaxAggregateOutputType | null
  }

  export type AnomalyMinAggregateOutputType = {
    id: string | null
    type: string | null
    severity: string | null
    status: string | null
    description: string | null
    timestamp: Date | null
    nightclubId: string | null
    zoneId: string | null
    modelId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AnomalyMaxAggregateOutputType = {
    id: string | null
    type: string | null
    severity: string | null
    status: string | null
    description: string | null
    timestamp: Date | null
    nightclubId: string | null
    zoneId: string | null
    modelId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AnomalyCountAggregateOutputType = {
    id: number
    type: number
    severity: number
    status: number
    description: number
    timestamp: number
    metadata: number
    nightclubId: number
    zoneId: number
    modelId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AnomalyMinAggregateInputType = {
    id?: true
    type?: true
    severity?: true
    status?: true
    description?: true
    timestamp?: true
    nightclubId?: true
    zoneId?: true
    modelId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AnomalyMaxAggregateInputType = {
    id?: true
    type?: true
    severity?: true
    status?: true
    description?: true
    timestamp?: true
    nightclubId?: true
    zoneId?: true
    modelId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AnomalyCountAggregateInputType = {
    id?: true
    type?: true
    severity?: true
    status?: true
    description?: true
    timestamp?: true
    metadata?: true
    nightclubId?: true
    zoneId?: true
    modelId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AnomalyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Anomaly to aggregate.
     */
    where?: AnomalyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Anomalies to fetch.
     */
    orderBy?: AnomalyOrderByWithRelationInput | AnomalyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AnomalyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Anomalies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Anomalies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Anomalies
    **/
    _count?: true | AnomalyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnomalyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnomalyMaxAggregateInputType
  }

  export type GetAnomalyAggregateType<T extends AnomalyAggregateArgs> = {
        [P in keyof T & keyof AggregateAnomaly]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnomaly[P]>
      : GetScalarType<T[P], AggregateAnomaly[P]>
  }




  export type AnomalyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AnomalyWhereInput
    orderBy?: AnomalyOrderByWithAggregationInput | AnomalyOrderByWithAggregationInput[]
    by: AnomalyScalarFieldEnum[] | AnomalyScalarFieldEnum
    having?: AnomalyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnomalyCountAggregateInputType | true
    _min?: AnomalyMinAggregateInputType
    _max?: AnomalyMaxAggregateInputType
  }

  export type AnomalyGroupByOutputType = {
    id: string
    type: string
    severity: string
    status: string
    description: string
    timestamp: Date
    metadata: JsonValue | null
    nightclubId: string
    zoneId: string | null
    modelId: string
    createdAt: Date
    updatedAt: Date
    _count: AnomalyCountAggregateOutputType | null
    _min: AnomalyMinAggregateOutputType | null
    _max: AnomalyMaxAggregateOutputType | null
  }

  type GetAnomalyGroupByPayload<T extends AnomalyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnomalyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnomalyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnomalyGroupByOutputType[P]>
            : GetScalarType<T[P], AnomalyGroupByOutputType[P]>
        }
      >
    >


  export type AnomalySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    severity?: boolean
    status?: boolean
    description?: boolean
    timestamp?: boolean
    metadata?: boolean
    nightclubId?: boolean
    zoneId?: boolean
    modelId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    nightclub?: boolean | NightclubDefaultArgs<ExtArgs>
    zone?: boolean | Anomaly$zoneArgs<ExtArgs>
    model?: boolean | AIModelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["anomaly"]>

  export type AnomalySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    severity?: boolean
    status?: boolean
    description?: boolean
    timestamp?: boolean
    metadata?: boolean
    nightclubId?: boolean
    zoneId?: boolean
    modelId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    nightclub?: boolean | NightclubDefaultArgs<ExtArgs>
    zone?: boolean | Anomaly$zoneArgs<ExtArgs>
    model?: boolean | AIModelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["anomaly"]>

  export type AnomalySelectScalar = {
    id?: boolean
    type?: boolean
    severity?: boolean
    status?: boolean
    description?: boolean
    timestamp?: boolean
    metadata?: boolean
    nightclubId?: boolean
    zoneId?: boolean
    modelId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AnomalyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    nightclub?: boolean | NightclubDefaultArgs<ExtArgs>
    zone?: boolean | Anomaly$zoneArgs<ExtArgs>
    model?: boolean | AIModelDefaultArgs<ExtArgs>
  }
  export type AnomalyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    nightclub?: boolean | NightclubDefaultArgs<ExtArgs>
    zone?: boolean | Anomaly$zoneArgs<ExtArgs>
    model?: boolean | AIModelDefaultArgs<ExtArgs>
  }

  export type $AnomalyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Anomaly"
    objects: {
      nightclub: Prisma.$NightclubPayload<ExtArgs>
      zone: Prisma.$ZonePayload<ExtArgs> | null
      model: Prisma.$AIModelPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: string
      severity: string
      status: string
      description: string
      timestamp: Date
      metadata: Prisma.JsonValue | null
      nightclubId: string
      zoneId: string | null
      modelId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["anomaly"]>
    composites: {}
  }

  type AnomalyGetPayload<S extends boolean | null | undefined | AnomalyDefaultArgs> = $Result.GetResult<Prisma.$AnomalyPayload, S>

  type AnomalyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AnomalyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AnomalyCountAggregateInputType | true
    }

  export interface AnomalyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Anomaly'], meta: { name: 'Anomaly' } }
    /**
     * Find zero or one Anomaly that matches the filter.
     * @param {AnomalyFindUniqueArgs} args - Arguments to find a Anomaly
     * @example
     * // Get one Anomaly
     * const anomaly = await prisma.anomaly.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AnomalyFindUniqueArgs>(args: SelectSubset<T, AnomalyFindUniqueArgs<ExtArgs>>): Prisma__AnomalyClient<$Result.GetResult<Prisma.$AnomalyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Anomaly that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AnomalyFindUniqueOrThrowArgs} args - Arguments to find a Anomaly
     * @example
     * // Get one Anomaly
     * const anomaly = await prisma.anomaly.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AnomalyFindUniqueOrThrowArgs>(args: SelectSubset<T, AnomalyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AnomalyClient<$Result.GetResult<Prisma.$AnomalyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Anomaly that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnomalyFindFirstArgs} args - Arguments to find a Anomaly
     * @example
     * // Get one Anomaly
     * const anomaly = await prisma.anomaly.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AnomalyFindFirstArgs>(args?: SelectSubset<T, AnomalyFindFirstArgs<ExtArgs>>): Prisma__AnomalyClient<$Result.GetResult<Prisma.$AnomalyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Anomaly that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnomalyFindFirstOrThrowArgs} args - Arguments to find a Anomaly
     * @example
     * // Get one Anomaly
     * const anomaly = await prisma.anomaly.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AnomalyFindFirstOrThrowArgs>(args?: SelectSubset<T, AnomalyFindFirstOrThrowArgs<ExtArgs>>): Prisma__AnomalyClient<$Result.GetResult<Prisma.$AnomalyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Anomalies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnomalyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Anomalies
     * const anomalies = await prisma.anomaly.findMany()
     * 
     * // Get first 10 Anomalies
     * const anomalies = await prisma.anomaly.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const anomalyWithIdOnly = await prisma.anomaly.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AnomalyFindManyArgs>(args?: SelectSubset<T, AnomalyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnomalyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Anomaly.
     * @param {AnomalyCreateArgs} args - Arguments to create a Anomaly.
     * @example
     * // Create one Anomaly
     * const Anomaly = await prisma.anomaly.create({
     *   data: {
     *     // ... data to create a Anomaly
     *   }
     * })
     * 
     */
    create<T extends AnomalyCreateArgs>(args: SelectSubset<T, AnomalyCreateArgs<ExtArgs>>): Prisma__AnomalyClient<$Result.GetResult<Prisma.$AnomalyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Anomalies.
     * @param {AnomalyCreateManyArgs} args - Arguments to create many Anomalies.
     * @example
     * // Create many Anomalies
     * const anomaly = await prisma.anomaly.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AnomalyCreateManyArgs>(args?: SelectSubset<T, AnomalyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Anomalies and returns the data saved in the database.
     * @param {AnomalyCreateManyAndReturnArgs} args - Arguments to create many Anomalies.
     * @example
     * // Create many Anomalies
     * const anomaly = await prisma.anomaly.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Anomalies and only return the `id`
     * const anomalyWithIdOnly = await prisma.anomaly.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AnomalyCreateManyAndReturnArgs>(args?: SelectSubset<T, AnomalyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AnomalyPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Anomaly.
     * @param {AnomalyDeleteArgs} args - Arguments to delete one Anomaly.
     * @example
     * // Delete one Anomaly
     * const Anomaly = await prisma.anomaly.delete({
     *   where: {
     *     // ... filter to delete one Anomaly
     *   }
     * })
     * 
     */
    delete<T extends AnomalyDeleteArgs>(args: SelectSubset<T, AnomalyDeleteArgs<ExtArgs>>): Prisma__AnomalyClient<$Result.GetResult<Prisma.$AnomalyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Anomaly.
     * @param {AnomalyUpdateArgs} args - Arguments to update one Anomaly.
     * @example
     * // Update one Anomaly
     * const anomaly = await prisma.anomaly.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AnomalyUpdateArgs>(args: SelectSubset<T, AnomalyUpdateArgs<ExtArgs>>): Prisma__AnomalyClient<$Result.GetResult<Prisma.$AnomalyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Anomalies.
     * @param {AnomalyDeleteManyArgs} args - Arguments to filter Anomalies to delete.
     * @example
     * // Delete a few Anomalies
     * const { count } = await prisma.anomaly.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AnomalyDeleteManyArgs>(args?: SelectSubset<T, AnomalyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Anomalies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnomalyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Anomalies
     * const anomaly = await prisma.anomaly.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AnomalyUpdateManyArgs>(args: SelectSubset<T, AnomalyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Anomaly.
     * @param {AnomalyUpsertArgs} args - Arguments to update or create a Anomaly.
     * @example
     * // Update or create a Anomaly
     * const anomaly = await prisma.anomaly.upsert({
     *   create: {
     *     // ... data to create a Anomaly
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Anomaly we want to update
     *   }
     * })
     */
    upsert<T extends AnomalyUpsertArgs>(args: SelectSubset<T, AnomalyUpsertArgs<ExtArgs>>): Prisma__AnomalyClient<$Result.GetResult<Prisma.$AnomalyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Anomalies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnomalyCountArgs} args - Arguments to filter Anomalies to count.
     * @example
     * // Count the number of Anomalies
     * const count = await prisma.anomaly.count({
     *   where: {
     *     // ... the filter for the Anomalies we want to count
     *   }
     * })
    **/
    count<T extends AnomalyCountArgs>(
      args?: Subset<T, AnomalyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnomalyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Anomaly.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnomalyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnomalyAggregateArgs>(args: Subset<T, AnomalyAggregateArgs>): Prisma.PrismaPromise<GetAnomalyAggregateType<T>>

    /**
     * Group by Anomaly.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnomalyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AnomalyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnomalyGroupByArgs['orderBy'] }
        : { orderBy?: AnomalyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AnomalyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnomalyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Anomaly model
   */
  readonly fields: AnomalyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Anomaly.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnomalyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    nightclub<T extends NightclubDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NightclubDefaultArgs<ExtArgs>>): Prisma__NightclubClient<$Result.GetResult<Prisma.$NightclubPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    zone<T extends Anomaly$zoneArgs<ExtArgs> = {}>(args?: Subset<T, Anomaly$zoneArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    model<T extends AIModelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AIModelDefaultArgs<ExtArgs>>): Prisma__AIModelClient<$Result.GetResult<Prisma.$AIModelPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Anomaly model
   */ 
  interface AnomalyFieldRefs {
    readonly id: FieldRef<"Anomaly", 'String'>
    readonly type: FieldRef<"Anomaly", 'String'>
    readonly severity: FieldRef<"Anomaly", 'String'>
    readonly status: FieldRef<"Anomaly", 'String'>
    readonly description: FieldRef<"Anomaly", 'String'>
    readonly timestamp: FieldRef<"Anomaly", 'DateTime'>
    readonly metadata: FieldRef<"Anomaly", 'Json'>
    readonly nightclubId: FieldRef<"Anomaly", 'String'>
    readonly zoneId: FieldRef<"Anomaly", 'String'>
    readonly modelId: FieldRef<"Anomaly", 'String'>
    readonly createdAt: FieldRef<"Anomaly", 'DateTime'>
    readonly updatedAt: FieldRef<"Anomaly", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Anomaly findUnique
   */
  export type AnomalyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Anomaly
     */
    select?: AnomalySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnomalyInclude<ExtArgs> | null
    /**
     * Filter, which Anomaly to fetch.
     */
    where: AnomalyWhereUniqueInput
  }

  /**
   * Anomaly findUniqueOrThrow
   */
  export type AnomalyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Anomaly
     */
    select?: AnomalySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnomalyInclude<ExtArgs> | null
    /**
     * Filter, which Anomaly to fetch.
     */
    where: AnomalyWhereUniqueInput
  }

  /**
   * Anomaly findFirst
   */
  export type AnomalyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Anomaly
     */
    select?: AnomalySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnomalyInclude<ExtArgs> | null
    /**
     * Filter, which Anomaly to fetch.
     */
    where?: AnomalyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Anomalies to fetch.
     */
    orderBy?: AnomalyOrderByWithRelationInput | AnomalyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Anomalies.
     */
    cursor?: AnomalyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Anomalies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Anomalies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Anomalies.
     */
    distinct?: AnomalyScalarFieldEnum | AnomalyScalarFieldEnum[]
  }

  /**
   * Anomaly findFirstOrThrow
   */
  export type AnomalyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Anomaly
     */
    select?: AnomalySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnomalyInclude<ExtArgs> | null
    /**
     * Filter, which Anomaly to fetch.
     */
    where?: AnomalyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Anomalies to fetch.
     */
    orderBy?: AnomalyOrderByWithRelationInput | AnomalyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Anomalies.
     */
    cursor?: AnomalyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Anomalies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Anomalies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Anomalies.
     */
    distinct?: AnomalyScalarFieldEnum | AnomalyScalarFieldEnum[]
  }

  /**
   * Anomaly findMany
   */
  export type AnomalyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Anomaly
     */
    select?: AnomalySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnomalyInclude<ExtArgs> | null
    /**
     * Filter, which Anomalies to fetch.
     */
    where?: AnomalyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Anomalies to fetch.
     */
    orderBy?: AnomalyOrderByWithRelationInput | AnomalyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Anomalies.
     */
    cursor?: AnomalyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Anomalies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Anomalies.
     */
    skip?: number
    distinct?: AnomalyScalarFieldEnum | AnomalyScalarFieldEnum[]
  }

  /**
   * Anomaly create
   */
  export type AnomalyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Anomaly
     */
    select?: AnomalySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnomalyInclude<ExtArgs> | null
    /**
     * The data needed to create a Anomaly.
     */
    data: XOR<AnomalyCreateInput, AnomalyUncheckedCreateInput>
  }

  /**
   * Anomaly createMany
   */
  export type AnomalyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Anomalies.
     */
    data: AnomalyCreateManyInput | AnomalyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Anomaly createManyAndReturn
   */
  export type AnomalyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Anomaly
     */
    select?: AnomalySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Anomalies.
     */
    data: AnomalyCreateManyInput | AnomalyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnomalyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Anomaly update
   */
  export type AnomalyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Anomaly
     */
    select?: AnomalySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnomalyInclude<ExtArgs> | null
    /**
     * The data needed to update a Anomaly.
     */
    data: XOR<AnomalyUpdateInput, AnomalyUncheckedUpdateInput>
    /**
     * Choose, which Anomaly to update.
     */
    where: AnomalyWhereUniqueInput
  }

  /**
   * Anomaly updateMany
   */
  export type AnomalyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Anomalies.
     */
    data: XOR<AnomalyUpdateManyMutationInput, AnomalyUncheckedUpdateManyInput>
    /**
     * Filter which Anomalies to update
     */
    where?: AnomalyWhereInput
  }

  /**
   * Anomaly upsert
   */
  export type AnomalyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Anomaly
     */
    select?: AnomalySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnomalyInclude<ExtArgs> | null
    /**
     * The filter to search for the Anomaly to update in case it exists.
     */
    where: AnomalyWhereUniqueInput
    /**
     * In case the Anomaly found by the `where` argument doesn't exist, create a new Anomaly with this data.
     */
    create: XOR<AnomalyCreateInput, AnomalyUncheckedCreateInput>
    /**
     * In case the Anomaly was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnomalyUpdateInput, AnomalyUncheckedUpdateInput>
  }

  /**
   * Anomaly delete
   */
  export type AnomalyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Anomaly
     */
    select?: AnomalySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnomalyInclude<ExtArgs> | null
    /**
     * Filter which Anomaly to delete.
     */
    where: AnomalyWhereUniqueInput
  }

  /**
   * Anomaly deleteMany
   */
  export type AnomalyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Anomalies to delete
     */
    where?: AnomalyWhereInput
  }

  /**
   * Anomaly.zone
   */
  export type Anomaly$zoneArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    where?: ZoneWhereInput
  }

  /**
   * Anomaly without action
   */
  export type AnomalyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Anomaly
     */
    select?: AnomalySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnomalyInclude<ExtArgs> | null
  }


  /**
   * Model BehaviorAnalysis
   */

  export type AggregateBehaviorAnalysis = {
    _count: BehaviorAnalysisCountAggregateOutputType | null
    _min: BehaviorAnalysisMinAggregateOutputType | null
    _max: BehaviorAnalysisMaxAggregateOutputType | null
  }

  export type BehaviorAnalysisMinAggregateOutputType = {
    id: string | null
    type: string | null
    timestamp: Date | null
    nightclubId: string | null
    zoneId: string | null
    modelId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BehaviorAnalysisMaxAggregateOutputType = {
    id: string | null
    type: string | null
    timestamp: Date | null
    nightclubId: string | null
    zoneId: string | null
    modelId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BehaviorAnalysisCountAggregateOutputType = {
    id: number
    type: number
    timestamp: number
    insights: number
    metadata: number
    nightclubId: number
    zoneId: number
    modelId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BehaviorAnalysisMinAggregateInputType = {
    id?: true
    type?: true
    timestamp?: true
    nightclubId?: true
    zoneId?: true
    modelId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BehaviorAnalysisMaxAggregateInputType = {
    id?: true
    type?: true
    timestamp?: true
    nightclubId?: true
    zoneId?: true
    modelId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BehaviorAnalysisCountAggregateInputType = {
    id?: true
    type?: true
    timestamp?: true
    insights?: true
    metadata?: true
    nightclubId?: true
    zoneId?: true
    modelId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BehaviorAnalysisAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BehaviorAnalysis to aggregate.
     */
    where?: BehaviorAnalysisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BehaviorAnalyses to fetch.
     */
    orderBy?: BehaviorAnalysisOrderByWithRelationInput | BehaviorAnalysisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BehaviorAnalysisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BehaviorAnalyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BehaviorAnalyses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BehaviorAnalyses
    **/
    _count?: true | BehaviorAnalysisCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BehaviorAnalysisMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BehaviorAnalysisMaxAggregateInputType
  }

  export type GetBehaviorAnalysisAggregateType<T extends BehaviorAnalysisAggregateArgs> = {
        [P in keyof T & keyof AggregateBehaviorAnalysis]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBehaviorAnalysis[P]>
      : GetScalarType<T[P], AggregateBehaviorAnalysis[P]>
  }




  export type BehaviorAnalysisGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BehaviorAnalysisWhereInput
    orderBy?: BehaviorAnalysisOrderByWithAggregationInput | BehaviorAnalysisOrderByWithAggregationInput[]
    by: BehaviorAnalysisScalarFieldEnum[] | BehaviorAnalysisScalarFieldEnum
    having?: BehaviorAnalysisScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BehaviorAnalysisCountAggregateInputType | true
    _min?: BehaviorAnalysisMinAggregateInputType
    _max?: BehaviorAnalysisMaxAggregateInputType
  }

  export type BehaviorAnalysisGroupByOutputType = {
    id: string
    type: string
    timestamp: Date
    insights: JsonValue
    metadata: JsonValue | null
    nightclubId: string
    zoneId: string | null
    modelId: string
    createdAt: Date
    updatedAt: Date
    _count: BehaviorAnalysisCountAggregateOutputType | null
    _min: BehaviorAnalysisMinAggregateOutputType | null
    _max: BehaviorAnalysisMaxAggregateOutputType | null
  }

  type GetBehaviorAnalysisGroupByPayload<T extends BehaviorAnalysisGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BehaviorAnalysisGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BehaviorAnalysisGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BehaviorAnalysisGroupByOutputType[P]>
            : GetScalarType<T[P], BehaviorAnalysisGroupByOutputType[P]>
        }
      >
    >


  export type BehaviorAnalysisSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    timestamp?: boolean
    insights?: boolean
    metadata?: boolean
    nightclubId?: boolean
    zoneId?: boolean
    modelId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    nightclub?: boolean | NightclubDefaultArgs<ExtArgs>
    zone?: boolean | BehaviorAnalysis$zoneArgs<ExtArgs>
    model?: boolean | AIModelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["behaviorAnalysis"]>

  export type BehaviorAnalysisSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    timestamp?: boolean
    insights?: boolean
    metadata?: boolean
    nightclubId?: boolean
    zoneId?: boolean
    modelId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    nightclub?: boolean | NightclubDefaultArgs<ExtArgs>
    zone?: boolean | BehaviorAnalysis$zoneArgs<ExtArgs>
    model?: boolean | AIModelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["behaviorAnalysis"]>

  export type BehaviorAnalysisSelectScalar = {
    id?: boolean
    type?: boolean
    timestamp?: boolean
    insights?: boolean
    metadata?: boolean
    nightclubId?: boolean
    zoneId?: boolean
    modelId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BehaviorAnalysisInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    nightclub?: boolean | NightclubDefaultArgs<ExtArgs>
    zone?: boolean | BehaviorAnalysis$zoneArgs<ExtArgs>
    model?: boolean | AIModelDefaultArgs<ExtArgs>
  }
  export type BehaviorAnalysisIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    nightclub?: boolean | NightclubDefaultArgs<ExtArgs>
    zone?: boolean | BehaviorAnalysis$zoneArgs<ExtArgs>
    model?: boolean | AIModelDefaultArgs<ExtArgs>
  }

  export type $BehaviorAnalysisPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BehaviorAnalysis"
    objects: {
      nightclub: Prisma.$NightclubPayload<ExtArgs>
      zone: Prisma.$ZonePayload<ExtArgs> | null
      model: Prisma.$AIModelPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: string
      timestamp: Date
      insights: Prisma.JsonValue
      metadata: Prisma.JsonValue | null
      nightclubId: string
      zoneId: string | null
      modelId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["behaviorAnalysis"]>
    composites: {}
  }

  type BehaviorAnalysisGetPayload<S extends boolean | null | undefined | BehaviorAnalysisDefaultArgs> = $Result.GetResult<Prisma.$BehaviorAnalysisPayload, S>

  type BehaviorAnalysisCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BehaviorAnalysisFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BehaviorAnalysisCountAggregateInputType | true
    }

  export interface BehaviorAnalysisDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BehaviorAnalysis'], meta: { name: 'BehaviorAnalysis' } }
    /**
     * Find zero or one BehaviorAnalysis that matches the filter.
     * @param {BehaviorAnalysisFindUniqueArgs} args - Arguments to find a BehaviorAnalysis
     * @example
     * // Get one BehaviorAnalysis
     * const behaviorAnalysis = await prisma.behaviorAnalysis.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BehaviorAnalysisFindUniqueArgs>(args: SelectSubset<T, BehaviorAnalysisFindUniqueArgs<ExtArgs>>): Prisma__BehaviorAnalysisClient<$Result.GetResult<Prisma.$BehaviorAnalysisPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BehaviorAnalysis that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BehaviorAnalysisFindUniqueOrThrowArgs} args - Arguments to find a BehaviorAnalysis
     * @example
     * // Get one BehaviorAnalysis
     * const behaviorAnalysis = await prisma.behaviorAnalysis.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BehaviorAnalysisFindUniqueOrThrowArgs>(args: SelectSubset<T, BehaviorAnalysisFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BehaviorAnalysisClient<$Result.GetResult<Prisma.$BehaviorAnalysisPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BehaviorAnalysis that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BehaviorAnalysisFindFirstArgs} args - Arguments to find a BehaviorAnalysis
     * @example
     * // Get one BehaviorAnalysis
     * const behaviorAnalysis = await prisma.behaviorAnalysis.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BehaviorAnalysisFindFirstArgs>(args?: SelectSubset<T, BehaviorAnalysisFindFirstArgs<ExtArgs>>): Prisma__BehaviorAnalysisClient<$Result.GetResult<Prisma.$BehaviorAnalysisPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BehaviorAnalysis that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BehaviorAnalysisFindFirstOrThrowArgs} args - Arguments to find a BehaviorAnalysis
     * @example
     * // Get one BehaviorAnalysis
     * const behaviorAnalysis = await prisma.behaviorAnalysis.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BehaviorAnalysisFindFirstOrThrowArgs>(args?: SelectSubset<T, BehaviorAnalysisFindFirstOrThrowArgs<ExtArgs>>): Prisma__BehaviorAnalysisClient<$Result.GetResult<Prisma.$BehaviorAnalysisPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BehaviorAnalyses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BehaviorAnalysisFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BehaviorAnalyses
     * const behaviorAnalyses = await prisma.behaviorAnalysis.findMany()
     * 
     * // Get first 10 BehaviorAnalyses
     * const behaviorAnalyses = await prisma.behaviorAnalysis.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const behaviorAnalysisWithIdOnly = await prisma.behaviorAnalysis.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BehaviorAnalysisFindManyArgs>(args?: SelectSubset<T, BehaviorAnalysisFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BehaviorAnalysisPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BehaviorAnalysis.
     * @param {BehaviorAnalysisCreateArgs} args - Arguments to create a BehaviorAnalysis.
     * @example
     * // Create one BehaviorAnalysis
     * const BehaviorAnalysis = await prisma.behaviorAnalysis.create({
     *   data: {
     *     // ... data to create a BehaviorAnalysis
     *   }
     * })
     * 
     */
    create<T extends BehaviorAnalysisCreateArgs>(args: SelectSubset<T, BehaviorAnalysisCreateArgs<ExtArgs>>): Prisma__BehaviorAnalysisClient<$Result.GetResult<Prisma.$BehaviorAnalysisPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BehaviorAnalyses.
     * @param {BehaviorAnalysisCreateManyArgs} args - Arguments to create many BehaviorAnalyses.
     * @example
     * // Create many BehaviorAnalyses
     * const behaviorAnalysis = await prisma.behaviorAnalysis.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BehaviorAnalysisCreateManyArgs>(args?: SelectSubset<T, BehaviorAnalysisCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BehaviorAnalyses and returns the data saved in the database.
     * @param {BehaviorAnalysisCreateManyAndReturnArgs} args - Arguments to create many BehaviorAnalyses.
     * @example
     * // Create many BehaviorAnalyses
     * const behaviorAnalysis = await prisma.behaviorAnalysis.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BehaviorAnalyses and only return the `id`
     * const behaviorAnalysisWithIdOnly = await prisma.behaviorAnalysis.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BehaviorAnalysisCreateManyAndReturnArgs>(args?: SelectSubset<T, BehaviorAnalysisCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BehaviorAnalysisPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BehaviorAnalysis.
     * @param {BehaviorAnalysisDeleteArgs} args - Arguments to delete one BehaviorAnalysis.
     * @example
     * // Delete one BehaviorAnalysis
     * const BehaviorAnalysis = await prisma.behaviorAnalysis.delete({
     *   where: {
     *     // ... filter to delete one BehaviorAnalysis
     *   }
     * })
     * 
     */
    delete<T extends BehaviorAnalysisDeleteArgs>(args: SelectSubset<T, BehaviorAnalysisDeleteArgs<ExtArgs>>): Prisma__BehaviorAnalysisClient<$Result.GetResult<Prisma.$BehaviorAnalysisPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BehaviorAnalysis.
     * @param {BehaviorAnalysisUpdateArgs} args - Arguments to update one BehaviorAnalysis.
     * @example
     * // Update one BehaviorAnalysis
     * const behaviorAnalysis = await prisma.behaviorAnalysis.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BehaviorAnalysisUpdateArgs>(args: SelectSubset<T, BehaviorAnalysisUpdateArgs<ExtArgs>>): Prisma__BehaviorAnalysisClient<$Result.GetResult<Prisma.$BehaviorAnalysisPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BehaviorAnalyses.
     * @param {BehaviorAnalysisDeleteManyArgs} args - Arguments to filter BehaviorAnalyses to delete.
     * @example
     * // Delete a few BehaviorAnalyses
     * const { count } = await prisma.behaviorAnalysis.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BehaviorAnalysisDeleteManyArgs>(args?: SelectSubset<T, BehaviorAnalysisDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BehaviorAnalyses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BehaviorAnalysisUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BehaviorAnalyses
     * const behaviorAnalysis = await prisma.behaviorAnalysis.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BehaviorAnalysisUpdateManyArgs>(args: SelectSubset<T, BehaviorAnalysisUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BehaviorAnalysis.
     * @param {BehaviorAnalysisUpsertArgs} args - Arguments to update or create a BehaviorAnalysis.
     * @example
     * // Update or create a BehaviorAnalysis
     * const behaviorAnalysis = await prisma.behaviorAnalysis.upsert({
     *   create: {
     *     // ... data to create a BehaviorAnalysis
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BehaviorAnalysis we want to update
     *   }
     * })
     */
    upsert<T extends BehaviorAnalysisUpsertArgs>(args: SelectSubset<T, BehaviorAnalysisUpsertArgs<ExtArgs>>): Prisma__BehaviorAnalysisClient<$Result.GetResult<Prisma.$BehaviorAnalysisPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BehaviorAnalyses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BehaviorAnalysisCountArgs} args - Arguments to filter BehaviorAnalyses to count.
     * @example
     * // Count the number of BehaviorAnalyses
     * const count = await prisma.behaviorAnalysis.count({
     *   where: {
     *     // ... the filter for the BehaviorAnalyses we want to count
     *   }
     * })
    **/
    count<T extends BehaviorAnalysisCountArgs>(
      args?: Subset<T, BehaviorAnalysisCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BehaviorAnalysisCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BehaviorAnalysis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BehaviorAnalysisAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BehaviorAnalysisAggregateArgs>(args: Subset<T, BehaviorAnalysisAggregateArgs>): Prisma.PrismaPromise<GetBehaviorAnalysisAggregateType<T>>

    /**
     * Group by BehaviorAnalysis.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BehaviorAnalysisGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BehaviorAnalysisGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BehaviorAnalysisGroupByArgs['orderBy'] }
        : { orderBy?: BehaviorAnalysisGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BehaviorAnalysisGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBehaviorAnalysisGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BehaviorAnalysis model
   */
  readonly fields: BehaviorAnalysisFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BehaviorAnalysis.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BehaviorAnalysisClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    nightclub<T extends NightclubDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NightclubDefaultArgs<ExtArgs>>): Prisma__NightclubClient<$Result.GetResult<Prisma.$NightclubPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    zone<T extends BehaviorAnalysis$zoneArgs<ExtArgs> = {}>(args?: Subset<T, BehaviorAnalysis$zoneArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    model<T extends AIModelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AIModelDefaultArgs<ExtArgs>>): Prisma__AIModelClient<$Result.GetResult<Prisma.$AIModelPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BehaviorAnalysis model
   */ 
  interface BehaviorAnalysisFieldRefs {
    readonly id: FieldRef<"BehaviorAnalysis", 'String'>
    readonly type: FieldRef<"BehaviorAnalysis", 'String'>
    readonly timestamp: FieldRef<"BehaviorAnalysis", 'DateTime'>
    readonly insights: FieldRef<"BehaviorAnalysis", 'Json'>
    readonly metadata: FieldRef<"BehaviorAnalysis", 'Json'>
    readonly nightclubId: FieldRef<"BehaviorAnalysis", 'String'>
    readonly zoneId: FieldRef<"BehaviorAnalysis", 'String'>
    readonly modelId: FieldRef<"BehaviorAnalysis", 'String'>
    readonly createdAt: FieldRef<"BehaviorAnalysis", 'DateTime'>
    readonly updatedAt: FieldRef<"BehaviorAnalysis", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BehaviorAnalysis findUnique
   */
  export type BehaviorAnalysisFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BehaviorAnalysis
     */
    select?: BehaviorAnalysisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BehaviorAnalysisInclude<ExtArgs> | null
    /**
     * Filter, which BehaviorAnalysis to fetch.
     */
    where: BehaviorAnalysisWhereUniqueInput
  }

  /**
   * BehaviorAnalysis findUniqueOrThrow
   */
  export type BehaviorAnalysisFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BehaviorAnalysis
     */
    select?: BehaviorAnalysisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BehaviorAnalysisInclude<ExtArgs> | null
    /**
     * Filter, which BehaviorAnalysis to fetch.
     */
    where: BehaviorAnalysisWhereUniqueInput
  }

  /**
   * BehaviorAnalysis findFirst
   */
  export type BehaviorAnalysisFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BehaviorAnalysis
     */
    select?: BehaviorAnalysisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BehaviorAnalysisInclude<ExtArgs> | null
    /**
     * Filter, which BehaviorAnalysis to fetch.
     */
    where?: BehaviorAnalysisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BehaviorAnalyses to fetch.
     */
    orderBy?: BehaviorAnalysisOrderByWithRelationInput | BehaviorAnalysisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BehaviorAnalyses.
     */
    cursor?: BehaviorAnalysisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BehaviorAnalyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BehaviorAnalyses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BehaviorAnalyses.
     */
    distinct?: BehaviorAnalysisScalarFieldEnum | BehaviorAnalysisScalarFieldEnum[]
  }

  /**
   * BehaviorAnalysis findFirstOrThrow
   */
  export type BehaviorAnalysisFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BehaviorAnalysis
     */
    select?: BehaviorAnalysisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BehaviorAnalysisInclude<ExtArgs> | null
    /**
     * Filter, which BehaviorAnalysis to fetch.
     */
    where?: BehaviorAnalysisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BehaviorAnalyses to fetch.
     */
    orderBy?: BehaviorAnalysisOrderByWithRelationInput | BehaviorAnalysisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BehaviorAnalyses.
     */
    cursor?: BehaviorAnalysisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BehaviorAnalyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BehaviorAnalyses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BehaviorAnalyses.
     */
    distinct?: BehaviorAnalysisScalarFieldEnum | BehaviorAnalysisScalarFieldEnum[]
  }

  /**
   * BehaviorAnalysis findMany
   */
  export type BehaviorAnalysisFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BehaviorAnalysis
     */
    select?: BehaviorAnalysisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BehaviorAnalysisInclude<ExtArgs> | null
    /**
     * Filter, which BehaviorAnalyses to fetch.
     */
    where?: BehaviorAnalysisWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BehaviorAnalyses to fetch.
     */
    orderBy?: BehaviorAnalysisOrderByWithRelationInput | BehaviorAnalysisOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BehaviorAnalyses.
     */
    cursor?: BehaviorAnalysisWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BehaviorAnalyses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BehaviorAnalyses.
     */
    skip?: number
    distinct?: BehaviorAnalysisScalarFieldEnum | BehaviorAnalysisScalarFieldEnum[]
  }

  /**
   * BehaviorAnalysis create
   */
  export type BehaviorAnalysisCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BehaviorAnalysis
     */
    select?: BehaviorAnalysisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BehaviorAnalysisInclude<ExtArgs> | null
    /**
     * The data needed to create a BehaviorAnalysis.
     */
    data: XOR<BehaviorAnalysisCreateInput, BehaviorAnalysisUncheckedCreateInput>
  }

  /**
   * BehaviorAnalysis createMany
   */
  export type BehaviorAnalysisCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BehaviorAnalyses.
     */
    data: BehaviorAnalysisCreateManyInput | BehaviorAnalysisCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BehaviorAnalysis createManyAndReturn
   */
  export type BehaviorAnalysisCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BehaviorAnalysis
     */
    select?: BehaviorAnalysisSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BehaviorAnalyses.
     */
    data: BehaviorAnalysisCreateManyInput | BehaviorAnalysisCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BehaviorAnalysisIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BehaviorAnalysis update
   */
  export type BehaviorAnalysisUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BehaviorAnalysis
     */
    select?: BehaviorAnalysisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BehaviorAnalysisInclude<ExtArgs> | null
    /**
     * The data needed to update a BehaviorAnalysis.
     */
    data: XOR<BehaviorAnalysisUpdateInput, BehaviorAnalysisUncheckedUpdateInput>
    /**
     * Choose, which BehaviorAnalysis to update.
     */
    where: BehaviorAnalysisWhereUniqueInput
  }

  /**
   * BehaviorAnalysis updateMany
   */
  export type BehaviorAnalysisUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BehaviorAnalyses.
     */
    data: XOR<BehaviorAnalysisUpdateManyMutationInput, BehaviorAnalysisUncheckedUpdateManyInput>
    /**
     * Filter which BehaviorAnalyses to update
     */
    where?: BehaviorAnalysisWhereInput
  }

  /**
   * BehaviorAnalysis upsert
   */
  export type BehaviorAnalysisUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BehaviorAnalysis
     */
    select?: BehaviorAnalysisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BehaviorAnalysisInclude<ExtArgs> | null
    /**
     * The filter to search for the BehaviorAnalysis to update in case it exists.
     */
    where: BehaviorAnalysisWhereUniqueInput
    /**
     * In case the BehaviorAnalysis found by the `where` argument doesn't exist, create a new BehaviorAnalysis with this data.
     */
    create: XOR<BehaviorAnalysisCreateInput, BehaviorAnalysisUncheckedCreateInput>
    /**
     * In case the BehaviorAnalysis was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BehaviorAnalysisUpdateInput, BehaviorAnalysisUncheckedUpdateInput>
  }

  /**
   * BehaviorAnalysis delete
   */
  export type BehaviorAnalysisDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BehaviorAnalysis
     */
    select?: BehaviorAnalysisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BehaviorAnalysisInclude<ExtArgs> | null
    /**
     * Filter which BehaviorAnalysis to delete.
     */
    where: BehaviorAnalysisWhereUniqueInput
  }

  /**
   * BehaviorAnalysis deleteMany
   */
  export type BehaviorAnalysisDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BehaviorAnalyses to delete
     */
    where?: BehaviorAnalysisWhereInput
  }

  /**
   * BehaviorAnalysis.zone
   */
  export type BehaviorAnalysis$zoneArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    where?: ZoneWhereInput
  }

  /**
   * BehaviorAnalysis without action
   */
  export type BehaviorAnalysisDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BehaviorAnalysis
     */
    select?: BehaviorAnalysisSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BehaviorAnalysisInclude<ExtArgs> | null
  }


  /**
   * Model RealTimeMetric
   */

  export type AggregateRealTimeMetric = {
    _count: RealTimeMetricCountAggregateOutputType | null
    _avg: RealTimeMetricAvgAggregateOutputType | null
    _sum: RealTimeMetricSumAggregateOutputType | null
    _min: RealTimeMetricMinAggregateOutputType | null
    _max: RealTimeMetricMaxAggregateOutputType | null
  }

  export type RealTimeMetricAvgAggregateOutputType = {
    value: number | null
  }

  export type RealTimeMetricSumAggregateOutputType = {
    value: number | null
  }

  export type RealTimeMetricMinAggregateOutputType = {
    id: string | null
    type: string | null
    value: number | null
    timestamp: Date | null
    nightclubId: string | null
    zoneId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RealTimeMetricMaxAggregateOutputType = {
    id: string | null
    type: string | null
    value: number | null
    timestamp: Date | null
    nightclubId: string | null
    zoneId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RealTimeMetricCountAggregateOutputType = {
    id: number
    type: number
    value: number
    timestamp: number
    metadata: number
    nightclubId: number
    zoneId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RealTimeMetricAvgAggregateInputType = {
    value?: true
  }

  export type RealTimeMetricSumAggregateInputType = {
    value?: true
  }

  export type RealTimeMetricMinAggregateInputType = {
    id?: true
    type?: true
    value?: true
    timestamp?: true
    nightclubId?: true
    zoneId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RealTimeMetricMaxAggregateInputType = {
    id?: true
    type?: true
    value?: true
    timestamp?: true
    nightclubId?: true
    zoneId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RealTimeMetricCountAggregateInputType = {
    id?: true
    type?: true
    value?: true
    timestamp?: true
    metadata?: true
    nightclubId?: true
    zoneId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RealTimeMetricAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RealTimeMetric to aggregate.
     */
    where?: RealTimeMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RealTimeMetrics to fetch.
     */
    orderBy?: RealTimeMetricOrderByWithRelationInput | RealTimeMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RealTimeMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RealTimeMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RealTimeMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RealTimeMetrics
    **/
    _count?: true | RealTimeMetricCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RealTimeMetricAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RealTimeMetricSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RealTimeMetricMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RealTimeMetricMaxAggregateInputType
  }

  export type GetRealTimeMetricAggregateType<T extends RealTimeMetricAggregateArgs> = {
        [P in keyof T & keyof AggregateRealTimeMetric]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRealTimeMetric[P]>
      : GetScalarType<T[P], AggregateRealTimeMetric[P]>
  }




  export type RealTimeMetricGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RealTimeMetricWhereInput
    orderBy?: RealTimeMetricOrderByWithAggregationInput | RealTimeMetricOrderByWithAggregationInput[]
    by: RealTimeMetricScalarFieldEnum[] | RealTimeMetricScalarFieldEnum
    having?: RealTimeMetricScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RealTimeMetricCountAggregateInputType | true
    _avg?: RealTimeMetricAvgAggregateInputType
    _sum?: RealTimeMetricSumAggregateInputType
    _min?: RealTimeMetricMinAggregateInputType
    _max?: RealTimeMetricMaxAggregateInputType
  }

  export type RealTimeMetricGroupByOutputType = {
    id: string
    type: string
    value: number
    timestamp: Date
    metadata: JsonValue | null
    nightclubId: string
    zoneId: string | null
    createdAt: Date
    updatedAt: Date
    _count: RealTimeMetricCountAggregateOutputType | null
    _avg: RealTimeMetricAvgAggregateOutputType | null
    _sum: RealTimeMetricSumAggregateOutputType | null
    _min: RealTimeMetricMinAggregateOutputType | null
    _max: RealTimeMetricMaxAggregateOutputType | null
  }

  type GetRealTimeMetricGroupByPayload<T extends RealTimeMetricGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RealTimeMetricGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RealTimeMetricGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RealTimeMetricGroupByOutputType[P]>
            : GetScalarType<T[P], RealTimeMetricGroupByOutputType[P]>
        }
      >
    >


  export type RealTimeMetricSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    value?: boolean
    timestamp?: boolean
    metadata?: boolean
    nightclubId?: boolean
    zoneId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    nightclub?: boolean | NightclubDefaultArgs<ExtArgs>
    zone?: boolean | RealTimeMetric$zoneArgs<ExtArgs>
  }, ExtArgs["result"]["realTimeMetric"]>

  export type RealTimeMetricSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    value?: boolean
    timestamp?: boolean
    metadata?: boolean
    nightclubId?: boolean
    zoneId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    nightclub?: boolean | NightclubDefaultArgs<ExtArgs>
    zone?: boolean | RealTimeMetric$zoneArgs<ExtArgs>
  }, ExtArgs["result"]["realTimeMetric"]>

  export type RealTimeMetricSelectScalar = {
    id?: boolean
    type?: boolean
    value?: boolean
    timestamp?: boolean
    metadata?: boolean
    nightclubId?: boolean
    zoneId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RealTimeMetricInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    nightclub?: boolean | NightclubDefaultArgs<ExtArgs>
    zone?: boolean | RealTimeMetric$zoneArgs<ExtArgs>
  }
  export type RealTimeMetricIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    nightclub?: boolean | NightclubDefaultArgs<ExtArgs>
    zone?: boolean | RealTimeMetric$zoneArgs<ExtArgs>
  }

  export type $RealTimeMetricPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RealTimeMetric"
    objects: {
      nightclub: Prisma.$NightclubPayload<ExtArgs>
      zone: Prisma.$ZonePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: string
      value: number
      timestamp: Date
      metadata: Prisma.JsonValue | null
      nightclubId: string
      zoneId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["realTimeMetric"]>
    composites: {}
  }

  type RealTimeMetricGetPayload<S extends boolean | null | undefined | RealTimeMetricDefaultArgs> = $Result.GetResult<Prisma.$RealTimeMetricPayload, S>

  type RealTimeMetricCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RealTimeMetricFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RealTimeMetricCountAggregateInputType | true
    }

  export interface RealTimeMetricDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RealTimeMetric'], meta: { name: 'RealTimeMetric' } }
    /**
     * Find zero or one RealTimeMetric that matches the filter.
     * @param {RealTimeMetricFindUniqueArgs} args - Arguments to find a RealTimeMetric
     * @example
     * // Get one RealTimeMetric
     * const realTimeMetric = await prisma.realTimeMetric.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RealTimeMetricFindUniqueArgs>(args: SelectSubset<T, RealTimeMetricFindUniqueArgs<ExtArgs>>): Prisma__RealTimeMetricClient<$Result.GetResult<Prisma.$RealTimeMetricPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RealTimeMetric that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RealTimeMetricFindUniqueOrThrowArgs} args - Arguments to find a RealTimeMetric
     * @example
     * // Get one RealTimeMetric
     * const realTimeMetric = await prisma.realTimeMetric.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RealTimeMetricFindUniqueOrThrowArgs>(args: SelectSubset<T, RealTimeMetricFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RealTimeMetricClient<$Result.GetResult<Prisma.$RealTimeMetricPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RealTimeMetric that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RealTimeMetricFindFirstArgs} args - Arguments to find a RealTimeMetric
     * @example
     * // Get one RealTimeMetric
     * const realTimeMetric = await prisma.realTimeMetric.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RealTimeMetricFindFirstArgs>(args?: SelectSubset<T, RealTimeMetricFindFirstArgs<ExtArgs>>): Prisma__RealTimeMetricClient<$Result.GetResult<Prisma.$RealTimeMetricPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RealTimeMetric that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RealTimeMetricFindFirstOrThrowArgs} args - Arguments to find a RealTimeMetric
     * @example
     * // Get one RealTimeMetric
     * const realTimeMetric = await prisma.realTimeMetric.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RealTimeMetricFindFirstOrThrowArgs>(args?: SelectSubset<T, RealTimeMetricFindFirstOrThrowArgs<ExtArgs>>): Prisma__RealTimeMetricClient<$Result.GetResult<Prisma.$RealTimeMetricPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RealTimeMetrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RealTimeMetricFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RealTimeMetrics
     * const realTimeMetrics = await prisma.realTimeMetric.findMany()
     * 
     * // Get first 10 RealTimeMetrics
     * const realTimeMetrics = await prisma.realTimeMetric.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const realTimeMetricWithIdOnly = await prisma.realTimeMetric.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RealTimeMetricFindManyArgs>(args?: SelectSubset<T, RealTimeMetricFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RealTimeMetricPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RealTimeMetric.
     * @param {RealTimeMetricCreateArgs} args - Arguments to create a RealTimeMetric.
     * @example
     * // Create one RealTimeMetric
     * const RealTimeMetric = await prisma.realTimeMetric.create({
     *   data: {
     *     // ... data to create a RealTimeMetric
     *   }
     * })
     * 
     */
    create<T extends RealTimeMetricCreateArgs>(args: SelectSubset<T, RealTimeMetricCreateArgs<ExtArgs>>): Prisma__RealTimeMetricClient<$Result.GetResult<Prisma.$RealTimeMetricPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RealTimeMetrics.
     * @param {RealTimeMetricCreateManyArgs} args - Arguments to create many RealTimeMetrics.
     * @example
     * // Create many RealTimeMetrics
     * const realTimeMetric = await prisma.realTimeMetric.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RealTimeMetricCreateManyArgs>(args?: SelectSubset<T, RealTimeMetricCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RealTimeMetrics and returns the data saved in the database.
     * @param {RealTimeMetricCreateManyAndReturnArgs} args - Arguments to create many RealTimeMetrics.
     * @example
     * // Create many RealTimeMetrics
     * const realTimeMetric = await prisma.realTimeMetric.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RealTimeMetrics and only return the `id`
     * const realTimeMetricWithIdOnly = await prisma.realTimeMetric.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RealTimeMetricCreateManyAndReturnArgs>(args?: SelectSubset<T, RealTimeMetricCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RealTimeMetricPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RealTimeMetric.
     * @param {RealTimeMetricDeleteArgs} args - Arguments to delete one RealTimeMetric.
     * @example
     * // Delete one RealTimeMetric
     * const RealTimeMetric = await prisma.realTimeMetric.delete({
     *   where: {
     *     // ... filter to delete one RealTimeMetric
     *   }
     * })
     * 
     */
    delete<T extends RealTimeMetricDeleteArgs>(args: SelectSubset<T, RealTimeMetricDeleteArgs<ExtArgs>>): Prisma__RealTimeMetricClient<$Result.GetResult<Prisma.$RealTimeMetricPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RealTimeMetric.
     * @param {RealTimeMetricUpdateArgs} args - Arguments to update one RealTimeMetric.
     * @example
     * // Update one RealTimeMetric
     * const realTimeMetric = await prisma.realTimeMetric.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RealTimeMetricUpdateArgs>(args: SelectSubset<T, RealTimeMetricUpdateArgs<ExtArgs>>): Prisma__RealTimeMetricClient<$Result.GetResult<Prisma.$RealTimeMetricPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RealTimeMetrics.
     * @param {RealTimeMetricDeleteManyArgs} args - Arguments to filter RealTimeMetrics to delete.
     * @example
     * // Delete a few RealTimeMetrics
     * const { count } = await prisma.realTimeMetric.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RealTimeMetricDeleteManyArgs>(args?: SelectSubset<T, RealTimeMetricDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RealTimeMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RealTimeMetricUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RealTimeMetrics
     * const realTimeMetric = await prisma.realTimeMetric.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RealTimeMetricUpdateManyArgs>(args: SelectSubset<T, RealTimeMetricUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RealTimeMetric.
     * @param {RealTimeMetricUpsertArgs} args - Arguments to update or create a RealTimeMetric.
     * @example
     * // Update or create a RealTimeMetric
     * const realTimeMetric = await prisma.realTimeMetric.upsert({
     *   create: {
     *     // ... data to create a RealTimeMetric
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RealTimeMetric we want to update
     *   }
     * })
     */
    upsert<T extends RealTimeMetricUpsertArgs>(args: SelectSubset<T, RealTimeMetricUpsertArgs<ExtArgs>>): Prisma__RealTimeMetricClient<$Result.GetResult<Prisma.$RealTimeMetricPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RealTimeMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RealTimeMetricCountArgs} args - Arguments to filter RealTimeMetrics to count.
     * @example
     * // Count the number of RealTimeMetrics
     * const count = await prisma.realTimeMetric.count({
     *   where: {
     *     // ... the filter for the RealTimeMetrics we want to count
     *   }
     * })
    **/
    count<T extends RealTimeMetricCountArgs>(
      args?: Subset<T, RealTimeMetricCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RealTimeMetricCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RealTimeMetric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RealTimeMetricAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RealTimeMetricAggregateArgs>(args: Subset<T, RealTimeMetricAggregateArgs>): Prisma.PrismaPromise<GetRealTimeMetricAggregateType<T>>

    /**
     * Group by RealTimeMetric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RealTimeMetricGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RealTimeMetricGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RealTimeMetricGroupByArgs['orderBy'] }
        : { orderBy?: RealTimeMetricGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RealTimeMetricGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRealTimeMetricGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RealTimeMetric model
   */
  readonly fields: RealTimeMetricFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RealTimeMetric.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RealTimeMetricClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    nightclub<T extends NightclubDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NightclubDefaultArgs<ExtArgs>>): Prisma__NightclubClient<$Result.GetResult<Prisma.$NightclubPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    zone<T extends RealTimeMetric$zoneArgs<ExtArgs> = {}>(args?: Subset<T, RealTimeMetric$zoneArgs<ExtArgs>>): Prisma__ZoneClient<$Result.GetResult<Prisma.$ZonePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RealTimeMetric model
   */ 
  interface RealTimeMetricFieldRefs {
    readonly id: FieldRef<"RealTimeMetric", 'String'>
    readonly type: FieldRef<"RealTimeMetric", 'String'>
    readonly value: FieldRef<"RealTimeMetric", 'Float'>
    readonly timestamp: FieldRef<"RealTimeMetric", 'DateTime'>
    readonly metadata: FieldRef<"RealTimeMetric", 'Json'>
    readonly nightclubId: FieldRef<"RealTimeMetric", 'String'>
    readonly zoneId: FieldRef<"RealTimeMetric", 'String'>
    readonly createdAt: FieldRef<"RealTimeMetric", 'DateTime'>
    readonly updatedAt: FieldRef<"RealTimeMetric", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RealTimeMetric findUnique
   */
  export type RealTimeMetricFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RealTimeMetric
     */
    select?: RealTimeMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RealTimeMetricInclude<ExtArgs> | null
    /**
     * Filter, which RealTimeMetric to fetch.
     */
    where: RealTimeMetricWhereUniqueInput
  }

  /**
   * RealTimeMetric findUniqueOrThrow
   */
  export type RealTimeMetricFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RealTimeMetric
     */
    select?: RealTimeMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RealTimeMetricInclude<ExtArgs> | null
    /**
     * Filter, which RealTimeMetric to fetch.
     */
    where: RealTimeMetricWhereUniqueInput
  }

  /**
   * RealTimeMetric findFirst
   */
  export type RealTimeMetricFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RealTimeMetric
     */
    select?: RealTimeMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RealTimeMetricInclude<ExtArgs> | null
    /**
     * Filter, which RealTimeMetric to fetch.
     */
    where?: RealTimeMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RealTimeMetrics to fetch.
     */
    orderBy?: RealTimeMetricOrderByWithRelationInput | RealTimeMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RealTimeMetrics.
     */
    cursor?: RealTimeMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RealTimeMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RealTimeMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RealTimeMetrics.
     */
    distinct?: RealTimeMetricScalarFieldEnum | RealTimeMetricScalarFieldEnum[]
  }

  /**
   * RealTimeMetric findFirstOrThrow
   */
  export type RealTimeMetricFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RealTimeMetric
     */
    select?: RealTimeMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RealTimeMetricInclude<ExtArgs> | null
    /**
     * Filter, which RealTimeMetric to fetch.
     */
    where?: RealTimeMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RealTimeMetrics to fetch.
     */
    orderBy?: RealTimeMetricOrderByWithRelationInput | RealTimeMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RealTimeMetrics.
     */
    cursor?: RealTimeMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RealTimeMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RealTimeMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RealTimeMetrics.
     */
    distinct?: RealTimeMetricScalarFieldEnum | RealTimeMetricScalarFieldEnum[]
  }

  /**
   * RealTimeMetric findMany
   */
  export type RealTimeMetricFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RealTimeMetric
     */
    select?: RealTimeMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RealTimeMetricInclude<ExtArgs> | null
    /**
     * Filter, which RealTimeMetrics to fetch.
     */
    where?: RealTimeMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RealTimeMetrics to fetch.
     */
    orderBy?: RealTimeMetricOrderByWithRelationInput | RealTimeMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RealTimeMetrics.
     */
    cursor?: RealTimeMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RealTimeMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RealTimeMetrics.
     */
    skip?: number
    distinct?: RealTimeMetricScalarFieldEnum | RealTimeMetricScalarFieldEnum[]
  }

  /**
   * RealTimeMetric create
   */
  export type RealTimeMetricCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RealTimeMetric
     */
    select?: RealTimeMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RealTimeMetricInclude<ExtArgs> | null
    /**
     * The data needed to create a RealTimeMetric.
     */
    data: XOR<RealTimeMetricCreateInput, RealTimeMetricUncheckedCreateInput>
  }

  /**
   * RealTimeMetric createMany
   */
  export type RealTimeMetricCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RealTimeMetrics.
     */
    data: RealTimeMetricCreateManyInput | RealTimeMetricCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RealTimeMetric createManyAndReturn
   */
  export type RealTimeMetricCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RealTimeMetric
     */
    select?: RealTimeMetricSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RealTimeMetrics.
     */
    data: RealTimeMetricCreateManyInput | RealTimeMetricCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RealTimeMetricIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RealTimeMetric update
   */
  export type RealTimeMetricUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RealTimeMetric
     */
    select?: RealTimeMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RealTimeMetricInclude<ExtArgs> | null
    /**
     * The data needed to update a RealTimeMetric.
     */
    data: XOR<RealTimeMetricUpdateInput, RealTimeMetricUncheckedUpdateInput>
    /**
     * Choose, which RealTimeMetric to update.
     */
    where: RealTimeMetricWhereUniqueInput
  }

  /**
   * RealTimeMetric updateMany
   */
  export type RealTimeMetricUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RealTimeMetrics.
     */
    data: XOR<RealTimeMetricUpdateManyMutationInput, RealTimeMetricUncheckedUpdateManyInput>
    /**
     * Filter which RealTimeMetrics to update
     */
    where?: RealTimeMetricWhereInput
  }

  /**
   * RealTimeMetric upsert
   */
  export type RealTimeMetricUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RealTimeMetric
     */
    select?: RealTimeMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RealTimeMetricInclude<ExtArgs> | null
    /**
     * The filter to search for the RealTimeMetric to update in case it exists.
     */
    where: RealTimeMetricWhereUniqueInput
    /**
     * In case the RealTimeMetric found by the `where` argument doesn't exist, create a new RealTimeMetric with this data.
     */
    create: XOR<RealTimeMetricCreateInput, RealTimeMetricUncheckedCreateInput>
    /**
     * In case the RealTimeMetric was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RealTimeMetricUpdateInput, RealTimeMetricUncheckedUpdateInput>
  }

  /**
   * RealTimeMetric delete
   */
  export type RealTimeMetricDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RealTimeMetric
     */
    select?: RealTimeMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RealTimeMetricInclude<ExtArgs> | null
    /**
     * Filter which RealTimeMetric to delete.
     */
    where: RealTimeMetricWhereUniqueInput
  }

  /**
   * RealTimeMetric deleteMany
   */
  export type RealTimeMetricDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RealTimeMetrics to delete
     */
    where?: RealTimeMetricWhereInput
  }

  /**
   * RealTimeMetric.zone
   */
  export type RealTimeMetric$zoneArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Zone
     */
    select?: ZoneSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZoneInclude<ExtArgs> | null
    where?: ZoneWhereInput
  }

  /**
   * RealTimeMetric without action
   */
  export type RealTimeMetricDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RealTimeMetric
     */
    select?: RealTimeMetricSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RealTimeMetricInclude<ExtArgs> | null
  }


  /**
   * Model DataStream
   */

  export type AggregateDataStream = {
    _count: DataStreamCountAggregateOutputType | null
    _min: DataStreamMinAggregateOutputType | null
    _max: DataStreamMaxAggregateOutputType | null
  }

  export type DataStreamMinAggregateOutputType = {
    id: string | null
    type: string | null
    status: string | null
    lastUpdate: Date | null
    nightclubId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DataStreamMaxAggregateOutputType = {
    id: string | null
    type: string | null
    status: string | null
    lastUpdate: Date | null
    nightclubId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DataStreamCountAggregateOutputType = {
    id: number
    type: number
    status: number
    lastUpdate: number
    metadata: number
    nightclubId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DataStreamMinAggregateInputType = {
    id?: true
    type?: true
    status?: true
    lastUpdate?: true
    nightclubId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DataStreamMaxAggregateInputType = {
    id?: true
    type?: true
    status?: true
    lastUpdate?: true
    nightclubId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DataStreamCountAggregateInputType = {
    id?: true
    type?: true
    status?: true
    lastUpdate?: true
    metadata?: true
    nightclubId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DataStreamAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DataStream to aggregate.
     */
    where?: DataStreamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataStreams to fetch.
     */
    orderBy?: DataStreamOrderByWithRelationInput | DataStreamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DataStreamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataStreams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataStreams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DataStreams
    **/
    _count?: true | DataStreamCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DataStreamMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DataStreamMaxAggregateInputType
  }

  export type GetDataStreamAggregateType<T extends DataStreamAggregateArgs> = {
        [P in keyof T & keyof AggregateDataStream]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDataStream[P]>
      : GetScalarType<T[P], AggregateDataStream[P]>
  }




  export type DataStreamGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DataStreamWhereInput
    orderBy?: DataStreamOrderByWithAggregationInput | DataStreamOrderByWithAggregationInput[]
    by: DataStreamScalarFieldEnum[] | DataStreamScalarFieldEnum
    having?: DataStreamScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DataStreamCountAggregateInputType | true
    _min?: DataStreamMinAggregateInputType
    _max?: DataStreamMaxAggregateInputType
  }

  export type DataStreamGroupByOutputType = {
    id: string
    type: string
    status: string
    lastUpdate: Date
    metadata: JsonValue | null
    nightclubId: string
    createdAt: Date
    updatedAt: Date
    _count: DataStreamCountAggregateOutputType | null
    _min: DataStreamMinAggregateOutputType | null
    _max: DataStreamMaxAggregateOutputType | null
  }

  type GetDataStreamGroupByPayload<T extends DataStreamGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DataStreamGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DataStreamGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DataStreamGroupByOutputType[P]>
            : GetScalarType<T[P], DataStreamGroupByOutputType[P]>
        }
      >
    >


  export type DataStreamSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    status?: boolean
    lastUpdate?: boolean
    metadata?: boolean
    nightclubId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    nightclub?: boolean | NightclubDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dataStream"]>

  export type DataStreamSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    status?: boolean
    lastUpdate?: boolean
    metadata?: boolean
    nightclubId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    nightclub?: boolean | NightclubDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dataStream"]>

  export type DataStreamSelectScalar = {
    id?: boolean
    type?: boolean
    status?: boolean
    lastUpdate?: boolean
    metadata?: boolean
    nightclubId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DataStreamInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    nightclub?: boolean | NightclubDefaultArgs<ExtArgs>
  }
  export type DataStreamIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    nightclub?: boolean | NightclubDefaultArgs<ExtArgs>
  }

  export type $DataStreamPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DataStream"
    objects: {
      nightclub: Prisma.$NightclubPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: string
      status: string
      lastUpdate: Date
      metadata: Prisma.JsonValue | null
      nightclubId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["dataStream"]>
    composites: {}
  }

  type DataStreamGetPayload<S extends boolean | null | undefined | DataStreamDefaultArgs> = $Result.GetResult<Prisma.$DataStreamPayload, S>

  type DataStreamCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DataStreamFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DataStreamCountAggregateInputType | true
    }

  export interface DataStreamDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DataStream'], meta: { name: 'DataStream' } }
    /**
     * Find zero or one DataStream that matches the filter.
     * @param {DataStreamFindUniqueArgs} args - Arguments to find a DataStream
     * @example
     * // Get one DataStream
     * const dataStream = await prisma.dataStream.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DataStreamFindUniqueArgs>(args: SelectSubset<T, DataStreamFindUniqueArgs<ExtArgs>>): Prisma__DataStreamClient<$Result.GetResult<Prisma.$DataStreamPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DataStream that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DataStreamFindUniqueOrThrowArgs} args - Arguments to find a DataStream
     * @example
     * // Get one DataStream
     * const dataStream = await prisma.dataStream.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DataStreamFindUniqueOrThrowArgs>(args: SelectSubset<T, DataStreamFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DataStreamClient<$Result.GetResult<Prisma.$DataStreamPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DataStream that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataStreamFindFirstArgs} args - Arguments to find a DataStream
     * @example
     * // Get one DataStream
     * const dataStream = await prisma.dataStream.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DataStreamFindFirstArgs>(args?: SelectSubset<T, DataStreamFindFirstArgs<ExtArgs>>): Prisma__DataStreamClient<$Result.GetResult<Prisma.$DataStreamPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DataStream that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataStreamFindFirstOrThrowArgs} args - Arguments to find a DataStream
     * @example
     * // Get one DataStream
     * const dataStream = await prisma.dataStream.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DataStreamFindFirstOrThrowArgs>(args?: SelectSubset<T, DataStreamFindFirstOrThrowArgs<ExtArgs>>): Prisma__DataStreamClient<$Result.GetResult<Prisma.$DataStreamPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DataStreams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataStreamFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DataStreams
     * const dataStreams = await prisma.dataStream.findMany()
     * 
     * // Get first 10 DataStreams
     * const dataStreams = await prisma.dataStream.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dataStreamWithIdOnly = await prisma.dataStream.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DataStreamFindManyArgs>(args?: SelectSubset<T, DataStreamFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DataStreamPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DataStream.
     * @param {DataStreamCreateArgs} args - Arguments to create a DataStream.
     * @example
     * // Create one DataStream
     * const DataStream = await prisma.dataStream.create({
     *   data: {
     *     // ... data to create a DataStream
     *   }
     * })
     * 
     */
    create<T extends DataStreamCreateArgs>(args: SelectSubset<T, DataStreamCreateArgs<ExtArgs>>): Prisma__DataStreamClient<$Result.GetResult<Prisma.$DataStreamPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DataStreams.
     * @param {DataStreamCreateManyArgs} args - Arguments to create many DataStreams.
     * @example
     * // Create many DataStreams
     * const dataStream = await prisma.dataStream.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DataStreamCreateManyArgs>(args?: SelectSubset<T, DataStreamCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DataStreams and returns the data saved in the database.
     * @param {DataStreamCreateManyAndReturnArgs} args - Arguments to create many DataStreams.
     * @example
     * // Create many DataStreams
     * const dataStream = await prisma.dataStream.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DataStreams and only return the `id`
     * const dataStreamWithIdOnly = await prisma.dataStream.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DataStreamCreateManyAndReturnArgs>(args?: SelectSubset<T, DataStreamCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DataStreamPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DataStream.
     * @param {DataStreamDeleteArgs} args - Arguments to delete one DataStream.
     * @example
     * // Delete one DataStream
     * const DataStream = await prisma.dataStream.delete({
     *   where: {
     *     // ... filter to delete one DataStream
     *   }
     * })
     * 
     */
    delete<T extends DataStreamDeleteArgs>(args: SelectSubset<T, DataStreamDeleteArgs<ExtArgs>>): Prisma__DataStreamClient<$Result.GetResult<Prisma.$DataStreamPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DataStream.
     * @param {DataStreamUpdateArgs} args - Arguments to update one DataStream.
     * @example
     * // Update one DataStream
     * const dataStream = await prisma.dataStream.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DataStreamUpdateArgs>(args: SelectSubset<T, DataStreamUpdateArgs<ExtArgs>>): Prisma__DataStreamClient<$Result.GetResult<Prisma.$DataStreamPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DataStreams.
     * @param {DataStreamDeleteManyArgs} args - Arguments to filter DataStreams to delete.
     * @example
     * // Delete a few DataStreams
     * const { count } = await prisma.dataStream.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DataStreamDeleteManyArgs>(args?: SelectSubset<T, DataStreamDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DataStreams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataStreamUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DataStreams
     * const dataStream = await prisma.dataStream.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DataStreamUpdateManyArgs>(args: SelectSubset<T, DataStreamUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DataStream.
     * @param {DataStreamUpsertArgs} args - Arguments to update or create a DataStream.
     * @example
     * // Update or create a DataStream
     * const dataStream = await prisma.dataStream.upsert({
     *   create: {
     *     // ... data to create a DataStream
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DataStream we want to update
     *   }
     * })
     */
    upsert<T extends DataStreamUpsertArgs>(args: SelectSubset<T, DataStreamUpsertArgs<ExtArgs>>): Prisma__DataStreamClient<$Result.GetResult<Prisma.$DataStreamPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DataStreams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataStreamCountArgs} args - Arguments to filter DataStreams to count.
     * @example
     * // Count the number of DataStreams
     * const count = await prisma.dataStream.count({
     *   where: {
     *     // ... the filter for the DataStreams we want to count
     *   }
     * })
    **/
    count<T extends DataStreamCountArgs>(
      args?: Subset<T, DataStreamCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DataStreamCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DataStream.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataStreamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DataStreamAggregateArgs>(args: Subset<T, DataStreamAggregateArgs>): Prisma.PrismaPromise<GetDataStreamAggregateType<T>>

    /**
     * Group by DataStream.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DataStreamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DataStreamGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DataStreamGroupByArgs['orderBy'] }
        : { orderBy?: DataStreamGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DataStreamGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDataStreamGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DataStream model
   */
  readonly fields: DataStreamFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DataStream.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DataStreamClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    nightclub<T extends NightclubDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NightclubDefaultArgs<ExtArgs>>): Prisma__NightclubClient<$Result.GetResult<Prisma.$NightclubPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DataStream model
   */ 
  interface DataStreamFieldRefs {
    readonly id: FieldRef<"DataStream", 'String'>
    readonly type: FieldRef<"DataStream", 'String'>
    readonly status: FieldRef<"DataStream", 'String'>
    readonly lastUpdate: FieldRef<"DataStream", 'DateTime'>
    readonly metadata: FieldRef<"DataStream", 'Json'>
    readonly nightclubId: FieldRef<"DataStream", 'String'>
    readonly createdAt: FieldRef<"DataStream", 'DateTime'>
    readonly updatedAt: FieldRef<"DataStream", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DataStream findUnique
   */
  export type DataStreamFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataStream
     */
    select?: DataStreamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataStreamInclude<ExtArgs> | null
    /**
     * Filter, which DataStream to fetch.
     */
    where: DataStreamWhereUniqueInput
  }

  /**
   * DataStream findUniqueOrThrow
   */
  export type DataStreamFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataStream
     */
    select?: DataStreamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataStreamInclude<ExtArgs> | null
    /**
     * Filter, which DataStream to fetch.
     */
    where: DataStreamWhereUniqueInput
  }

  /**
   * DataStream findFirst
   */
  export type DataStreamFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataStream
     */
    select?: DataStreamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataStreamInclude<ExtArgs> | null
    /**
     * Filter, which DataStream to fetch.
     */
    where?: DataStreamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataStreams to fetch.
     */
    orderBy?: DataStreamOrderByWithRelationInput | DataStreamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DataStreams.
     */
    cursor?: DataStreamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataStreams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataStreams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DataStreams.
     */
    distinct?: DataStreamScalarFieldEnum | DataStreamScalarFieldEnum[]
  }

  /**
   * DataStream findFirstOrThrow
   */
  export type DataStreamFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataStream
     */
    select?: DataStreamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataStreamInclude<ExtArgs> | null
    /**
     * Filter, which DataStream to fetch.
     */
    where?: DataStreamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataStreams to fetch.
     */
    orderBy?: DataStreamOrderByWithRelationInput | DataStreamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DataStreams.
     */
    cursor?: DataStreamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataStreams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataStreams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DataStreams.
     */
    distinct?: DataStreamScalarFieldEnum | DataStreamScalarFieldEnum[]
  }

  /**
   * DataStream findMany
   */
  export type DataStreamFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataStream
     */
    select?: DataStreamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataStreamInclude<ExtArgs> | null
    /**
     * Filter, which DataStreams to fetch.
     */
    where?: DataStreamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DataStreams to fetch.
     */
    orderBy?: DataStreamOrderByWithRelationInput | DataStreamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DataStreams.
     */
    cursor?: DataStreamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DataStreams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DataStreams.
     */
    skip?: number
    distinct?: DataStreamScalarFieldEnum | DataStreamScalarFieldEnum[]
  }

  /**
   * DataStream create
   */
  export type DataStreamCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataStream
     */
    select?: DataStreamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataStreamInclude<ExtArgs> | null
    /**
     * The data needed to create a DataStream.
     */
    data: XOR<DataStreamCreateInput, DataStreamUncheckedCreateInput>
  }

  /**
   * DataStream createMany
   */
  export type DataStreamCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DataStreams.
     */
    data: DataStreamCreateManyInput | DataStreamCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DataStream createManyAndReturn
   */
  export type DataStreamCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataStream
     */
    select?: DataStreamSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DataStreams.
     */
    data: DataStreamCreateManyInput | DataStreamCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataStreamIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DataStream update
   */
  export type DataStreamUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataStream
     */
    select?: DataStreamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataStreamInclude<ExtArgs> | null
    /**
     * The data needed to update a DataStream.
     */
    data: XOR<DataStreamUpdateInput, DataStreamUncheckedUpdateInput>
    /**
     * Choose, which DataStream to update.
     */
    where: DataStreamWhereUniqueInput
  }

  /**
   * DataStream updateMany
   */
  export type DataStreamUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DataStreams.
     */
    data: XOR<DataStreamUpdateManyMutationInput, DataStreamUncheckedUpdateManyInput>
    /**
     * Filter which DataStreams to update
     */
    where?: DataStreamWhereInput
  }

  /**
   * DataStream upsert
   */
  export type DataStreamUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataStream
     */
    select?: DataStreamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataStreamInclude<ExtArgs> | null
    /**
     * The filter to search for the DataStream to update in case it exists.
     */
    where: DataStreamWhereUniqueInput
    /**
     * In case the DataStream found by the `where` argument doesn't exist, create a new DataStream with this data.
     */
    create: XOR<DataStreamCreateInput, DataStreamUncheckedCreateInput>
    /**
     * In case the DataStream was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DataStreamUpdateInput, DataStreamUncheckedUpdateInput>
  }

  /**
   * DataStream delete
   */
  export type DataStreamDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataStream
     */
    select?: DataStreamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataStreamInclude<ExtArgs> | null
    /**
     * Filter which DataStream to delete.
     */
    where: DataStreamWhereUniqueInput
  }

  /**
   * DataStream deleteMany
   */
  export type DataStreamDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DataStreams to delete
     */
    where?: DataStreamWhereInput
  }

  /**
   * DataStream without action
   */
  export type DataStreamDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DataStream
     */
    select?: DataStreamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DataStreamInclude<ExtArgs> | null
  }


  /**
   * Model CacheEntry
   */

  export type AggregateCacheEntry = {
    _count: CacheEntryCountAggregateOutputType | null
    _min: CacheEntryMinAggregateOutputType | null
    _max: CacheEntryMaxAggregateOutputType | null
  }

  export type CacheEntryMinAggregateOutputType = {
    id: string | null
    key: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    nightclubId: string | null
  }

  export type CacheEntryMaxAggregateOutputType = {
    id: string | null
    key: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    nightclubId: string | null
  }

  export type CacheEntryCountAggregateOutputType = {
    id: number
    key: number
    value: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    nightclubId: number
    _all: number
  }


  export type CacheEntryMinAggregateInputType = {
    id?: true
    key?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    nightclubId?: true
  }

  export type CacheEntryMaxAggregateInputType = {
    id?: true
    key?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    nightclubId?: true
  }

  export type CacheEntryCountAggregateInputType = {
    id?: true
    key?: true
    value?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    nightclubId?: true
    _all?: true
  }

  export type CacheEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CacheEntry to aggregate.
     */
    where?: CacheEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CacheEntries to fetch.
     */
    orderBy?: CacheEntryOrderByWithRelationInput | CacheEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CacheEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CacheEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CacheEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CacheEntries
    **/
    _count?: true | CacheEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CacheEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CacheEntryMaxAggregateInputType
  }

  export type GetCacheEntryAggregateType<T extends CacheEntryAggregateArgs> = {
        [P in keyof T & keyof AggregateCacheEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCacheEntry[P]>
      : GetScalarType<T[P], AggregateCacheEntry[P]>
  }




  export type CacheEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CacheEntryWhereInput
    orderBy?: CacheEntryOrderByWithAggregationInput | CacheEntryOrderByWithAggregationInput[]
    by: CacheEntryScalarFieldEnum[] | CacheEntryScalarFieldEnum
    having?: CacheEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CacheEntryCountAggregateInputType | true
    _min?: CacheEntryMinAggregateInputType
    _max?: CacheEntryMaxAggregateInputType
  }

  export type CacheEntryGroupByOutputType = {
    id: string
    key: string
    value: JsonValue
    expiresAt: Date | null
    createdAt: Date
    updatedAt: Date
    nightclubId: string
    _count: CacheEntryCountAggregateOutputType | null
    _min: CacheEntryMinAggregateOutputType | null
    _max: CacheEntryMaxAggregateOutputType | null
  }

  type GetCacheEntryGroupByPayload<T extends CacheEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CacheEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CacheEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CacheEntryGroupByOutputType[P]>
            : GetScalarType<T[P], CacheEntryGroupByOutputType[P]>
        }
      >
    >


  export type CacheEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    nightclubId?: boolean
    nightclub?: boolean | NightclubDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cacheEntry"]>

  export type CacheEntrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    nightclubId?: boolean
    nightclub?: boolean | NightclubDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cacheEntry"]>

  export type CacheEntrySelectScalar = {
    id?: boolean
    key?: boolean
    value?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    nightclubId?: boolean
  }

  export type CacheEntryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    nightclub?: boolean | NightclubDefaultArgs<ExtArgs>
  }
  export type CacheEntryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    nightclub?: boolean | NightclubDefaultArgs<ExtArgs>
  }

  export type $CacheEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CacheEntry"
    objects: {
      nightclub: Prisma.$NightclubPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      key: string
      value: Prisma.JsonValue
      expiresAt: Date | null
      createdAt: Date
      updatedAt: Date
      nightclubId: string
    }, ExtArgs["result"]["cacheEntry"]>
    composites: {}
  }

  type CacheEntryGetPayload<S extends boolean | null | undefined | CacheEntryDefaultArgs> = $Result.GetResult<Prisma.$CacheEntryPayload, S>

  type CacheEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CacheEntryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CacheEntryCountAggregateInputType | true
    }

  export interface CacheEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CacheEntry'], meta: { name: 'CacheEntry' } }
    /**
     * Find zero or one CacheEntry that matches the filter.
     * @param {CacheEntryFindUniqueArgs} args - Arguments to find a CacheEntry
     * @example
     * // Get one CacheEntry
     * const cacheEntry = await prisma.cacheEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CacheEntryFindUniqueArgs>(args: SelectSubset<T, CacheEntryFindUniqueArgs<ExtArgs>>): Prisma__CacheEntryClient<$Result.GetResult<Prisma.$CacheEntryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CacheEntry that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CacheEntryFindUniqueOrThrowArgs} args - Arguments to find a CacheEntry
     * @example
     * // Get one CacheEntry
     * const cacheEntry = await prisma.cacheEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CacheEntryFindUniqueOrThrowArgs>(args: SelectSubset<T, CacheEntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CacheEntryClient<$Result.GetResult<Prisma.$CacheEntryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CacheEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CacheEntryFindFirstArgs} args - Arguments to find a CacheEntry
     * @example
     * // Get one CacheEntry
     * const cacheEntry = await prisma.cacheEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CacheEntryFindFirstArgs>(args?: SelectSubset<T, CacheEntryFindFirstArgs<ExtArgs>>): Prisma__CacheEntryClient<$Result.GetResult<Prisma.$CacheEntryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CacheEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CacheEntryFindFirstOrThrowArgs} args - Arguments to find a CacheEntry
     * @example
     * // Get one CacheEntry
     * const cacheEntry = await prisma.cacheEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CacheEntryFindFirstOrThrowArgs>(args?: SelectSubset<T, CacheEntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CacheEntryClient<$Result.GetResult<Prisma.$CacheEntryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CacheEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CacheEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CacheEntries
     * const cacheEntries = await prisma.cacheEntry.findMany()
     * 
     * // Get first 10 CacheEntries
     * const cacheEntries = await prisma.cacheEntry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cacheEntryWithIdOnly = await prisma.cacheEntry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CacheEntryFindManyArgs>(args?: SelectSubset<T, CacheEntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CacheEntryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CacheEntry.
     * @param {CacheEntryCreateArgs} args - Arguments to create a CacheEntry.
     * @example
     * // Create one CacheEntry
     * const CacheEntry = await prisma.cacheEntry.create({
     *   data: {
     *     // ... data to create a CacheEntry
     *   }
     * })
     * 
     */
    create<T extends CacheEntryCreateArgs>(args: SelectSubset<T, CacheEntryCreateArgs<ExtArgs>>): Prisma__CacheEntryClient<$Result.GetResult<Prisma.$CacheEntryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CacheEntries.
     * @param {CacheEntryCreateManyArgs} args - Arguments to create many CacheEntries.
     * @example
     * // Create many CacheEntries
     * const cacheEntry = await prisma.cacheEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CacheEntryCreateManyArgs>(args?: SelectSubset<T, CacheEntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CacheEntries and returns the data saved in the database.
     * @param {CacheEntryCreateManyAndReturnArgs} args - Arguments to create many CacheEntries.
     * @example
     * // Create many CacheEntries
     * const cacheEntry = await prisma.cacheEntry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CacheEntries and only return the `id`
     * const cacheEntryWithIdOnly = await prisma.cacheEntry.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CacheEntryCreateManyAndReturnArgs>(args?: SelectSubset<T, CacheEntryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CacheEntryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CacheEntry.
     * @param {CacheEntryDeleteArgs} args - Arguments to delete one CacheEntry.
     * @example
     * // Delete one CacheEntry
     * const CacheEntry = await prisma.cacheEntry.delete({
     *   where: {
     *     // ... filter to delete one CacheEntry
     *   }
     * })
     * 
     */
    delete<T extends CacheEntryDeleteArgs>(args: SelectSubset<T, CacheEntryDeleteArgs<ExtArgs>>): Prisma__CacheEntryClient<$Result.GetResult<Prisma.$CacheEntryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CacheEntry.
     * @param {CacheEntryUpdateArgs} args - Arguments to update one CacheEntry.
     * @example
     * // Update one CacheEntry
     * const cacheEntry = await prisma.cacheEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CacheEntryUpdateArgs>(args: SelectSubset<T, CacheEntryUpdateArgs<ExtArgs>>): Prisma__CacheEntryClient<$Result.GetResult<Prisma.$CacheEntryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CacheEntries.
     * @param {CacheEntryDeleteManyArgs} args - Arguments to filter CacheEntries to delete.
     * @example
     * // Delete a few CacheEntries
     * const { count } = await prisma.cacheEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CacheEntryDeleteManyArgs>(args?: SelectSubset<T, CacheEntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CacheEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CacheEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CacheEntries
     * const cacheEntry = await prisma.cacheEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CacheEntryUpdateManyArgs>(args: SelectSubset<T, CacheEntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CacheEntry.
     * @param {CacheEntryUpsertArgs} args - Arguments to update or create a CacheEntry.
     * @example
     * // Update or create a CacheEntry
     * const cacheEntry = await prisma.cacheEntry.upsert({
     *   create: {
     *     // ... data to create a CacheEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CacheEntry we want to update
     *   }
     * })
     */
    upsert<T extends CacheEntryUpsertArgs>(args: SelectSubset<T, CacheEntryUpsertArgs<ExtArgs>>): Prisma__CacheEntryClient<$Result.GetResult<Prisma.$CacheEntryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CacheEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CacheEntryCountArgs} args - Arguments to filter CacheEntries to count.
     * @example
     * // Count the number of CacheEntries
     * const count = await prisma.cacheEntry.count({
     *   where: {
     *     // ... the filter for the CacheEntries we want to count
     *   }
     * })
    **/
    count<T extends CacheEntryCountArgs>(
      args?: Subset<T, CacheEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CacheEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CacheEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CacheEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CacheEntryAggregateArgs>(args: Subset<T, CacheEntryAggregateArgs>): Prisma.PrismaPromise<GetCacheEntryAggregateType<T>>

    /**
     * Group by CacheEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CacheEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CacheEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CacheEntryGroupByArgs['orderBy'] }
        : { orderBy?: CacheEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CacheEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCacheEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CacheEntry model
   */
  readonly fields: CacheEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CacheEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CacheEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    nightclub<T extends NightclubDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NightclubDefaultArgs<ExtArgs>>): Prisma__NightclubClient<$Result.GetResult<Prisma.$NightclubPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CacheEntry model
   */ 
  interface CacheEntryFieldRefs {
    readonly id: FieldRef<"CacheEntry", 'String'>
    readonly key: FieldRef<"CacheEntry", 'String'>
    readonly value: FieldRef<"CacheEntry", 'Json'>
    readonly expiresAt: FieldRef<"CacheEntry", 'DateTime'>
    readonly createdAt: FieldRef<"CacheEntry", 'DateTime'>
    readonly updatedAt: FieldRef<"CacheEntry", 'DateTime'>
    readonly nightclubId: FieldRef<"CacheEntry", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CacheEntry findUnique
   */
  export type CacheEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CacheEntry
     */
    select?: CacheEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CacheEntryInclude<ExtArgs> | null
    /**
     * Filter, which CacheEntry to fetch.
     */
    where: CacheEntryWhereUniqueInput
  }

  /**
   * CacheEntry findUniqueOrThrow
   */
  export type CacheEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CacheEntry
     */
    select?: CacheEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CacheEntryInclude<ExtArgs> | null
    /**
     * Filter, which CacheEntry to fetch.
     */
    where: CacheEntryWhereUniqueInput
  }

  /**
   * CacheEntry findFirst
   */
  export type CacheEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CacheEntry
     */
    select?: CacheEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CacheEntryInclude<ExtArgs> | null
    /**
     * Filter, which CacheEntry to fetch.
     */
    where?: CacheEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CacheEntries to fetch.
     */
    orderBy?: CacheEntryOrderByWithRelationInput | CacheEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CacheEntries.
     */
    cursor?: CacheEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CacheEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CacheEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CacheEntries.
     */
    distinct?: CacheEntryScalarFieldEnum | CacheEntryScalarFieldEnum[]
  }

  /**
   * CacheEntry findFirstOrThrow
   */
  export type CacheEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CacheEntry
     */
    select?: CacheEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CacheEntryInclude<ExtArgs> | null
    /**
     * Filter, which CacheEntry to fetch.
     */
    where?: CacheEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CacheEntries to fetch.
     */
    orderBy?: CacheEntryOrderByWithRelationInput | CacheEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CacheEntries.
     */
    cursor?: CacheEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CacheEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CacheEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CacheEntries.
     */
    distinct?: CacheEntryScalarFieldEnum | CacheEntryScalarFieldEnum[]
  }

  /**
   * CacheEntry findMany
   */
  export type CacheEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CacheEntry
     */
    select?: CacheEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CacheEntryInclude<ExtArgs> | null
    /**
     * Filter, which CacheEntries to fetch.
     */
    where?: CacheEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CacheEntries to fetch.
     */
    orderBy?: CacheEntryOrderByWithRelationInput | CacheEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CacheEntries.
     */
    cursor?: CacheEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CacheEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CacheEntries.
     */
    skip?: number
    distinct?: CacheEntryScalarFieldEnum | CacheEntryScalarFieldEnum[]
  }

  /**
   * CacheEntry create
   */
  export type CacheEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CacheEntry
     */
    select?: CacheEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CacheEntryInclude<ExtArgs> | null
    /**
     * The data needed to create a CacheEntry.
     */
    data: XOR<CacheEntryCreateInput, CacheEntryUncheckedCreateInput>
  }

  /**
   * CacheEntry createMany
   */
  export type CacheEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CacheEntries.
     */
    data: CacheEntryCreateManyInput | CacheEntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CacheEntry createManyAndReturn
   */
  export type CacheEntryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CacheEntry
     */
    select?: CacheEntrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CacheEntries.
     */
    data: CacheEntryCreateManyInput | CacheEntryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CacheEntryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CacheEntry update
   */
  export type CacheEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CacheEntry
     */
    select?: CacheEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CacheEntryInclude<ExtArgs> | null
    /**
     * The data needed to update a CacheEntry.
     */
    data: XOR<CacheEntryUpdateInput, CacheEntryUncheckedUpdateInput>
    /**
     * Choose, which CacheEntry to update.
     */
    where: CacheEntryWhereUniqueInput
  }

  /**
   * CacheEntry updateMany
   */
  export type CacheEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CacheEntries.
     */
    data: XOR<CacheEntryUpdateManyMutationInput, CacheEntryUncheckedUpdateManyInput>
    /**
     * Filter which CacheEntries to update
     */
    where?: CacheEntryWhereInput
  }

  /**
   * CacheEntry upsert
   */
  export type CacheEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CacheEntry
     */
    select?: CacheEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CacheEntryInclude<ExtArgs> | null
    /**
     * The filter to search for the CacheEntry to update in case it exists.
     */
    where: CacheEntryWhereUniqueInput
    /**
     * In case the CacheEntry found by the `where` argument doesn't exist, create a new CacheEntry with this data.
     */
    create: XOR<CacheEntryCreateInput, CacheEntryUncheckedCreateInput>
    /**
     * In case the CacheEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CacheEntryUpdateInput, CacheEntryUncheckedUpdateInput>
  }

  /**
   * CacheEntry delete
   */
  export type CacheEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CacheEntry
     */
    select?: CacheEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CacheEntryInclude<ExtArgs> | null
    /**
     * Filter which CacheEntry to delete.
     */
    where: CacheEntryWhereUniqueInput
  }

  /**
   * CacheEntry deleteMany
   */
  export type CacheEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CacheEntries to delete
     */
    where?: CacheEntryWhereInput
  }

  /**
   * CacheEntry without action
   */
  export type CacheEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CacheEntry
     */
    select?: CacheEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CacheEntryInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const NightclubScalarFieldEnum: {
    id: 'id',
    name: 'name',
    address: 'address',
    settings: 'settings',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NightclubScalarFieldEnum = (typeof NightclubScalarFieldEnum)[keyof typeof NightclubScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    name: 'name',
    role: 'role',
    status: 'status',
    deviceId: 'deviceId',
    nightclubId: 'nightclubId',
    resetToken: 'resetToken',
    resetTokenExpiry: 'resetTokenExpiry',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    lastLogin: 'lastLogin',
    lastLocation: 'lastLocation'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const FloorPlanScalarFieldEnum: {
    id: 'id',
    name: 'name',
    imageUrl: 'imageUrl',
    nightclubId: 'nightclubId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    metadata: 'metadata'
  };

  export type FloorPlanScalarFieldEnum = (typeof FloorPlanScalarFieldEnum)[keyof typeof FloorPlanScalarFieldEnum]


  export const ZoneScalarFieldEnum: {
    id: 'id',
    name: 'name',
    coordinates: 'coordinates',
    capacity: 'capacity',
    floorPlanId: 'floorPlanId',
    nightclubId: 'nightclubId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ZoneScalarFieldEnum = (typeof ZoneScalarFieldEnum)[keyof typeof ZoneScalarFieldEnum]


  export const BraceletScalarFieldEnum: {
    id: 'id',
    deviceId: 'deviceId',
    batteryLevel: 'batteryLevel',
    status: 'status',
    lastSeen: 'lastSeen',
    nightclubId: 'nightclubId',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BraceletScalarFieldEnum = (typeof BraceletScalarFieldEnum)[keyof typeof BraceletScalarFieldEnum]


  export const AlertScalarFieldEnum: {
    id: 'id',
    type: 'type',
    status: 'status',
    braceletId: 'braceletId',
    userId: 'userId',
    zoneId: 'zoneId',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    resolvedAt: 'resolvedAt'
  };

  export type AlertScalarFieldEnum = (typeof AlertScalarFieldEnum)[keyof typeof AlertScalarFieldEnum]


  export const EmergencyScalarFieldEnum: {
    id: 'id',
    status: 'status',
    braceletId: 'braceletId',
    zoneId: 'zoneId',
    nightclubId: 'nightclubId',
    responderId: 'responderId',
    responseTime: 'responseTime',
    escalationDetails: 'escalationDetails',
    resolutionDetails: 'resolutionDetails',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    resolvedAt: 'resolvedAt'
  };

  export type EmergencyScalarFieldEnum = (typeof EmergencyScalarFieldEnum)[keyof typeof EmergencyScalarFieldEnum]


  export const SensorScalarFieldEnum: {
    id: 'id',
    type: 'type',
    status: 'status',
    zoneId: 'zoneId',
    data: 'data',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    lastReading: 'lastReading'
  };

  export type SensorScalarFieldEnum = (typeof SensorScalarFieldEnum)[keyof typeof SensorScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    action: 'action',
    entityType: 'entityType',
    entityId: 'entityId',
    userId: 'userId',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const AnalyticsReportScalarFieldEnum: {
    id: 'id',
    nightclubId: 'nightclubId',
    type: 'type',
    report: 'report',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AnalyticsReportScalarFieldEnum = (typeof AnalyticsReportScalarFieldEnum)[keyof typeof AnalyticsReportScalarFieldEnum]


  export const AIModelScalarFieldEnum: {
    id: 'id',
    type: 'type',
    name: 'name',
    version: 'version',
    status: 'status',
    config: 'config',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AIModelScalarFieldEnum = (typeof AIModelScalarFieldEnum)[keyof typeof AIModelScalarFieldEnum]


  export const PredictionScalarFieldEnum: {
    id: 'id',
    type: 'type',
    timestamp: 'timestamp',
    value: 'value',
    confidence: 'confidence',
    metadata: 'metadata',
    nightclubId: 'nightclubId',
    zoneId: 'zoneId',
    modelId: 'modelId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PredictionScalarFieldEnum = (typeof PredictionScalarFieldEnum)[keyof typeof PredictionScalarFieldEnum]


  export const AnomalyScalarFieldEnum: {
    id: 'id',
    type: 'type',
    severity: 'severity',
    status: 'status',
    description: 'description',
    timestamp: 'timestamp',
    metadata: 'metadata',
    nightclubId: 'nightclubId',
    zoneId: 'zoneId',
    modelId: 'modelId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AnomalyScalarFieldEnum = (typeof AnomalyScalarFieldEnum)[keyof typeof AnomalyScalarFieldEnum]


  export const BehaviorAnalysisScalarFieldEnum: {
    id: 'id',
    type: 'type',
    timestamp: 'timestamp',
    insights: 'insights',
    metadata: 'metadata',
    nightclubId: 'nightclubId',
    zoneId: 'zoneId',
    modelId: 'modelId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BehaviorAnalysisScalarFieldEnum = (typeof BehaviorAnalysisScalarFieldEnum)[keyof typeof BehaviorAnalysisScalarFieldEnum]


  export const RealTimeMetricScalarFieldEnum: {
    id: 'id',
    type: 'type',
    value: 'value',
    timestamp: 'timestamp',
    metadata: 'metadata',
    nightclubId: 'nightclubId',
    zoneId: 'zoneId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RealTimeMetricScalarFieldEnum = (typeof RealTimeMetricScalarFieldEnum)[keyof typeof RealTimeMetricScalarFieldEnum]


  export const DataStreamScalarFieldEnum: {
    id: 'id',
    type: 'type',
    status: 'status',
    lastUpdate: 'lastUpdate',
    metadata: 'metadata',
    nightclubId: 'nightclubId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DataStreamScalarFieldEnum = (typeof DataStreamScalarFieldEnum)[keyof typeof DataStreamScalarFieldEnum]


  export const CacheEntryScalarFieldEnum: {
    id: 'id',
    key: 'key',
    value: 'value',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    nightclubId: 'nightclubId'
  };

  export type CacheEntryScalarFieldEnum = (typeof CacheEntryScalarFieldEnum)[keyof typeof CacheEntryScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'UserStatus'
   */
  export type EnumUserStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserStatus'>
    


  /**
   * Reference to a field of type 'UserStatus[]'
   */
  export type ListEnumUserStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserStatus[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'BraceletStatus'
   */
  export type EnumBraceletStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BraceletStatus'>
    


  /**
   * Reference to a field of type 'BraceletStatus[]'
   */
  export type ListEnumBraceletStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BraceletStatus[]'>
    


  /**
   * Reference to a field of type 'AlertType'
   */
  export type EnumAlertTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AlertType'>
    


  /**
   * Reference to a field of type 'AlertType[]'
   */
  export type ListEnumAlertTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AlertType[]'>
    


  /**
   * Reference to a field of type 'AlertStatus'
   */
  export type EnumAlertStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AlertStatus'>
    


  /**
   * Reference to a field of type 'AlertStatus[]'
   */
  export type ListEnumAlertStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AlertStatus[]'>
    


  /**
   * Reference to a field of type 'EmergencyStatus'
   */
  export type EnumEmergencyStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EmergencyStatus'>
    


  /**
   * Reference to a field of type 'EmergencyStatus[]'
   */
  export type ListEnumEmergencyStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EmergencyStatus[]'>
    


  /**
   * Reference to a field of type 'SensorType'
   */
  export type EnumSensorTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SensorType'>
    


  /**
   * Reference to a field of type 'SensorType[]'
   */
  export type ListEnumSensorTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SensorType[]'>
    


  /**
   * Reference to a field of type 'SensorStatus'
   */
  export type EnumSensorStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SensorStatus'>
    


  /**
   * Reference to a field of type 'SensorStatus[]'
   */
  export type ListEnumSensorStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SensorStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type NightclubWhereInput = {
    AND?: NightclubWhereInput | NightclubWhereInput[]
    OR?: NightclubWhereInput[]
    NOT?: NightclubWhereInput | NightclubWhereInput[]
    id?: StringFilter<"Nightclub"> | string
    name?: StringFilter<"Nightclub"> | string
    address?: StringFilter<"Nightclub"> | string
    settings?: JsonNullableFilter<"Nightclub">
    createdAt?: DateTimeFilter<"Nightclub"> | Date | string
    updatedAt?: DateTimeFilter<"Nightclub"> | Date | string
    floorPlans?: FloorPlanListRelationFilter
    users?: UserListRelationFilter
    bracelets?: BraceletListRelationFilter
    zones?: ZoneListRelationFilter
    emergencies?: EmergencyListRelationFilter
    analyticsReports?: AnalyticsReportListRelationFilter
    predictions?: PredictionListRelationFilter
    anomalies?: AnomalyListRelationFilter
    behaviors?: BehaviorAnalysisListRelationFilter
    realTimeMetrics?: RealTimeMetricListRelationFilter
    dataStreams?: DataStreamListRelationFilter
    cacheEntries?: CacheEntryListRelationFilter
  }

  export type NightclubOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    settings?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    floorPlans?: FloorPlanOrderByRelationAggregateInput
    users?: UserOrderByRelationAggregateInput
    bracelets?: BraceletOrderByRelationAggregateInput
    zones?: ZoneOrderByRelationAggregateInput
    emergencies?: EmergencyOrderByRelationAggregateInput
    analyticsReports?: AnalyticsReportOrderByRelationAggregateInput
    predictions?: PredictionOrderByRelationAggregateInput
    anomalies?: AnomalyOrderByRelationAggregateInput
    behaviors?: BehaviorAnalysisOrderByRelationAggregateInput
    realTimeMetrics?: RealTimeMetricOrderByRelationAggregateInput
    dataStreams?: DataStreamOrderByRelationAggregateInput
    cacheEntries?: CacheEntryOrderByRelationAggregateInput
  }

  export type NightclubWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NightclubWhereInput | NightclubWhereInput[]
    OR?: NightclubWhereInput[]
    NOT?: NightclubWhereInput | NightclubWhereInput[]
    name?: StringFilter<"Nightclub"> | string
    address?: StringFilter<"Nightclub"> | string
    settings?: JsonNullableFilter<"Nightclub">
    createdAt?: DateTimeFilter<"Nightclub"> | Date | string
    updatedAt?: DateTimeFilter<"Nightclub"> | Date | string
    floorPlans?: FloorPlanListRelationFilter
    users?: UserListRelationFilter
    bracelets?: BraceletListRelationFilter
    zones?: ZoneListRelationFilter
    emergencies?: EmergencyListRelationFilter
    analyticsReports?: AnalyticsReportListRelationFilter
    predictions?: PredictionListRelationFilter
    anomalies?: AnomalyListRelationFilter
    behaviors?: BehaviorAnalysisListRelationFilter
    realTimeMetrics?: RealTimeMetricListRelationFilter
    dataStreams?: DataStreamListRelationFilter
    cacheEntries?: CacheEntryListRelationFilter
  }, "id">

  export type NightclubOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    settings?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NightclubCountOrderByAggregateInput
    _max?: NightclubMaxOrderByAggregateInput
    _min?: NightclubMinOrderByAggregateInput
  }

  export type NightclubScalarWhereWithAggregatesInput = {
    AND?: NightclubScalarWhereWithAggregatesInput | NightclubScalarWhereWithAggregatesInput[]
    OR?: NightclubScalarWhereWithAggregatesInput[]
    NOT?: NightclubScalarWhereWithAggregatesInput | NightclubScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Nightclub"> | string
    name?: StringWithAggregatesFilter<"Nightclub"> | string
    address?: StringWithAggregatesFilter<"Nightclub"> | string
    settings?: JsonNullableWithAggregatesFilter<"Nightclub">
    createdAt?: DateTimeWithAggregatesFilter<"Nightclub"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Nightclub"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    status?: EnumUserStatusFilter<"User"> | $Enums.UserStatus
    deviceId?: StringNullableFilter<"User"> | string | null
    nightclubId?: StringNullableFilter<"User"> | string | null
    resetToken?: StringNullableFilter<"User"> | string | null
    resetTokenExpiry?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    lastLocation?: JsonNullableFilter<"User">
    nightclub?: XOR<NightclubNullableRelationFilter, NightclubWhereInput> | null
    alerts?: AlertListRelationFilter
    emergencies?: EmergencyListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    status?: SortOrder
    deviceId?: SortOrderInput | SortOrder
    nightclubId?: SortOrderInput | SortOrder
    resetToken?: SortOrderInput | SortOrder
    resetTokenExpiry?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLogin?: SortOrderInput | SortOrder
    lastLocation?: SortOrderInput | SortOrder
    nightclub?: NightclubOrderByWithRelationInput
    alerts?: AlertOrderByRelationAggregateInput
    emergencies?: EmergencyOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    status?: EnumUserStatusFilter<"User"> | $Enums.UserStatus
    deviceId?: StringNullableFilter<"User"> | string | null
    nightclubId?: StringNullableFilter<"User"> | string | null
    resetToken?: StringNullableFilter<"User"> | string | null
    resetTokenExpiry?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    lastLocation?: JsonNullableFilter<"User">
    nightclub?: XOR<NightclubNullableRelationFilter, NightclubWhereInput> | null
    alerts?: AlertListRelationFilter
    emergencies?: EmergencyListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    status?: SortOrder
    deviceId?: SortOrderInput | SortOrder
    nightclubId?: SortOrderInput | SortOrder
    resetToken?: SortOrderInput | SortOrder
    resetTokenExpiry?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLogin?: SortOrderInput | SortOrder
    lastLocation?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    status?: EnumUserStatusWithAggregatesFilter<"User"> | $Enums.UserStatus
    deviceId?: StringNullableWithAggregatesFilter<"User"> | string | null
    nightclubId?: StringNullableWithAggregatesFilter<"User"> | string | null
    resetToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    resetTokenExpiry?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    lastLogin?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    lastLocation?: JsonNullableWithAggregatesFilter<"User">
  }

  export type FloorPlanWhereInput = {
    AND?: FloorPlanWhereInput | FloorPlanWhereInput[]
    OR?: FloorPlanWhereInput[]
    NOT?: FloorPlanWhereInput | FloorPlanWhereInput[]
    id?: StringFilter<"FloorPlan"> | string
    name?: StringFilter<"FloorPlan"> | string
    imageUrl?: StringFilter<"FloorPlan"> | string
    nightclubId?: StringFilter<"FloorPlan"> | string
    createdAt?: DateTimeFilter<"FloorPlan"> | Date | string
    updatedAt?: DateTimeFilter<"FloorPlan"> | Date | string
    metadata?: JsonNullableFilter<"FloorPlan">
    nightclub?: XOR<NightclubRelationFilter, NightclubWhereInput>
    zones?: ZoneListRelationFilter
  }

  export type FloorPlanOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    imageUrl?: SortOrder
    nightclubId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    metadata?: SortOrderInput | SortOrder
    nightclub?: NightclubOrderByWithRelationInput
    zones?: ZoneOrderByRelationAggregateInput
  }

  export type FloorPlanWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FloorPlanWhereInput | FloorPlanWhereInput[]
    OR?: FloorPlanWhereInput[]
    NOT?: FloorPlanWhereInput | FloorPlanWhereInput[]
    name?: StringFilter<"FloorPlan"> | string
    imageUrl?: StringFilter<"FloorPlan"> | string
    nightclubId?: StringFilter<"FloorPlan"> | string
    createdAt?: DateTimeFilter<"FloorPlan"> | Date | string
    updatedAt?: DateTimeFilter<"FloorPlan"> | Date | string
    metadata?: JsonNullableFilter<"FloorPlan">
    nightclub?: XOR<NightclubRelationFilter, NightclubWhereInput>
    zones?: ZoneListRelationFilter
  }, "id">

  export type FloorPlanOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    imageUrl?: SortOrder
    nightclubId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: FloorPlanCountOrderByAggregateInput
    _max?: FloorPlanMaxOrderByAggregateInput
    _min?: FloorPlanMinOrderByAggregateInput
  }

  export type FloorPlanScalarWhereWithAggregatesInput = {
    AND?: FloorPlanScalarWhereWithAggregatesInput | FloorPlanScalarWhereWithAggregatesInput[]
    OR?: FloorPlanScalarWhereWithAggregatesInput[]
    NOT?: FloorPlanScalarWhereWithAggregatesInput | FloorPlanScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FloorPlan"> | string
    name?: StringWithAggregatesFilter<"FloorPlan"> | string
    imageUrl?: StringWithAggregatesFilter<"FloorPlan"> | string
    nightclubId?: StringWithAggregatesFilter<"FloorPlan"> | string
    createdAt?: DateTimeWithAggregatesFilter<"FloorPlan"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FloorPlan"> | Date | string
    metadata?: JsonNullableWithAggregatesFilter<"FloorPlan">
  }

  export type ZoneWhereInput = {
    AND?: ZoneWhereInput | ZoneWhereInput[]
    OR?: ZoneWhereInput[]
    NOT?: ZoneWhereInput | ZoneWhereInput[]
    id?: StringFilter<"Zone"> | string
    name?: StringFilter<"Zone"> | string
    coordinates?: JsonFilter<"Zone">
    capacity?: IntFilter<"Zone"> | number
    floorPlanId?: StringFilter<"Zone"> | string
    nightclubId?: StringFilter<"Zone"> | string
    createdAt?: DateTimeFilter<"Zone"> | Date | string
    updatedAt?: DateTimeFilter<"Zone"> | Date | string
    floorPlan?: XOR<FloorPlanRelationFilter, FloorPlanWhereInput>
    nightclub?: XOR<NightclubRelationFilter, NightclubWhereInput>
    alerts?: AlertListRelationFilter
    emergencies?: EmergencyListRelationFilter
    sensors?: SensorListRelationFilter
    anomalies?: AnomalyListRelationFilter
    behaviors?: BehaviorAnalysisListRelationFilter
    realTimeMetrics?: RealTimeMetricListRelationFilter
    predictions?: PredictionListRelationFilter
  }

  export type ZoneOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    coordinates?: SortOrder
    capacity?: SortOrder
    floorPlanId?: SortOrder
    nightclubId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    floorPlan?: FloorPlanOrderByWithRelationInput
    nightclub?: NightclubOrderByWithRelationInput
    alerts?: AlertOrderByRelationAggregateInput
    emergencies?: EmergencyOrderByRelationAggregateInput
    sensors?: SensorOrderByRelationAggregateInput
    anomalies?: AnomalyOrderByRelationAggregateInput
    behaviors?: BehaviorAnalysisOrderByRelationAggregateInput
    realTimeMetrics?: RealTimeMetricOrderByRelationAggregateInput
    predictions?: PredictionOrderByRelationAggregateInput
  }

  export type ZoneWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ZoneWhereInput | ZoneWhereInput[]
    OR?: ZoneWhereInput[]
    NOT?: ZoneWhereInput | ZoneWhereInput[]
    name?: StringFilter<"Zone"> | string
    coordinates?: JsonFilter<"Zone">
    capacity?: IntFilter<"Zone"> | number
    floorPlanId?: StringFilter<"Zone"> | string
    nightclubId?: StringFilter<"Zone"> | string
    createdAt?: DateTimeFilter<"Zone"> | Date | string
    updatedAt?: DateTimeFilter<"Zone"> | Date | string
    floorPlan?: XOR<FloorPlanRelationFilter, FloorPlanWhereInput>
    nightclub?: XOR<NightclubRelationFilter, NightclubWhereInput>
    alerts?: AlertListRelationFilter
    emergencies?: EmergencyListRelationFilter
    sensors?: SensorListRelationFilter
    anomalies?: AnomalyListRelationFilter
    behaviors?: BehaviorAnalysisListRelationFilter
    realTimeMetrics?: RealTimeMetricListRelationFilter
    predictions?: PredictionListRelationFilter
  }, "id">

  export type ZoneOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    coordinates?: SortOrder
    capacity?: SortOrder
    floorPlanId?: SortOrder
    nightclubId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ZoneCountOrderByAggregateInput
    _avg?: ZoneAvgOrderByAggregateInput
    _max?: ZoneMaxOrderByAggregateInput
    _min?: ZoneMinOrderByAggregateInput
    _sum?: ZoneSumOrderByAggregateInput
  }

  export type ZoneScalarWhereWithAggregatesInput = {
    AND?: ZoneScalarWhereWithAggregatesInput | ZoneScalarWhereWithAggregatesInput[]
    OR?: ZoneScalarWhereWithAggregatesInput[]
    NOT?: ZoneScalarWhereWithAggregatesInput | ZoneScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Zone"> | string
    name?: StringWithAggregatesFilter<"Zone"> | string
    coordinates?: JsonWithAggregatesFilter<"Zone">
    capacity?: IntWithAggregatesFilter<"Zone"> | number
    floorPlanId?: StringWithAggregatesFilter<"Zone"> | string
    nightclubId?: StringWithAggregatesFilter<"Zone"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Zone"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Zone"> | Date | string
  }

  export type BraceletWhereInput = {
    AND?: BraceletWhereInput | BraceletWhereInput[]
    OR?: BraceletWhereInput[]
    NOT?: BraceletWhereInput | BraceletWhereInput[]
    id?: StringFilter<"Bracelet"> | string
    deviceId?: StringFilter<"Bracelet"> | string
    batteryLevel?: IntNullableFilter<"Bracelet"> | number | null
    status?: EnumBraceletStatusFilter<"Bracelet"> | $Enums.BraceletStatus
    lastSeen?: DateTimeNullableFilter<"Bracelet"> | Date | string | null
    nightclubId?: StringFilter<"Bracelet"> | string
    metadata?: JsonNullableFilter<"Bracelet">
    createdAt?: DateTimeFilter<"Bracelet"> | Date | string
    updatedAt?: DateTimeFilter<"Bracelet"> | Date | string
    nightclub?: XOR<NightclubRelationFilter, NightclubWhereInput>
    alerts?: AlertListRelationFilter
    emergencies?: EmergencyListRelationFilter
  }

  export type BraceletOrderByWithRelationInput = {
    id?: SortOrder
    deviceId?: SortOrder
    batteryLevel?: SortOrderInput | SortOrder
    status?: SortOrder
    lastSeen?: SortOrderInput | SortOrder
    nightclubId?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nightclub?: NightclubOrderByWithRelationInput
    alerts?: AlertOrderByRelationAggregateInput
    emergencies?: EmergencyOrderByRelationAggregateInput
  }

  export type BraceletWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    deviceId?: string
    AND?: BraceletWhereInput | BraceletWhereInput[]
    OR?: BraceletWhereInput[]
    NOT?: BraceletWhereInput | BraceletWhereInput[]
    batteryLevel?: IntNullableFilter<"Bracelet"> | number | null
    status?: EnumBraceletStatusFilter<"Bracelet"> | $Enums.BraceletStatus
    lastSeen?: DateTimeNullableFilter<"Bracelet"> | Date | string | null
    nightclubId?: StringFilter<"Bracelet"> | string
    metadata?: JsonNullableFilter<"Bracelet">
    createdAt?: DateTimeFilter<"Bracelet"> | Date | string
    updatedAt?: DateTimeFilter<"Bracelet"> | Date | string
    nightclub?: XOR<NightclubRelationFilter, NightclubWhereInput>
    alerts?: AlertListRelationFilter
    emergencies?: EmergencyListRelationFilter
  }, "id" | "deviceId">

  export type BraceletOrderByWithAggregationInput = {
    id?: SortOrder
    deviceId?: SortOrder
    batteryLevel?: SortOrderInput | SortOrder
    status?: SortOrder
    lastSeen?: SortOrderInput | SortOrder
    nightclubId?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BraceletCountOrderByAggregateInput
    _avg?: BraceletAvgOrderByAggregateInput
    _max?: BraceletMaxOrderByAggregateInput
    _min?: BraceletMinOrderByAggregateInput
    _sum?: BraceletSumOrderByAggregateInput
  }

  export type BraceletScalarWhereWithAggregatesInput = {
    AND?: BraceletScalarWhereWithAggregatesInput | BraceletScalarWhereWithAggregatesInput[]
    OR?: BraceletScalarWhereWithAggregatesInput[]
    NOT?: BraceletScalarWhereWithAggregatesInput | BraceletScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Bracelet"> | string
    deviceId?: StringWithAggregatesFilter<"Bracelet"> | string
    batteryLevel?: IntNullableWithAggregatesFilter<"Bracelet"> | number | null
    status?: EnumBraceletStatusWithAggregatesFilter<"Bracelet"> | $Enums.BraceletStatus
    lastSeen?: DateTimeNullableWithAggregatesFilter<"Bracelet"> | Date | string | null
    nightclubId?: StringWithAggregatesFilter<"Bracelet"> | string
    metadata?: JsonNullableWithAggregatesFilter<"Bracelet">
    createdAt?: DateTimeWithAggregatesFilter<"Bracelet"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Bracelet"> | Date | string
  }

  export type AlertWhereInput = {
    AND?: AlertWhereInput | AlertWhereInput[]
    OR?: AlertWhereInput[]
    NOT?: AlertWhereInput | AlertWhereInput[]
    id?: StringFilter<"Alert"> | string
    type?: EnumAlertTypeFilter<"Alert"> | $Enums.AlertType
    status?: EnumAlertStatusFilter<"Alert"> | $Enums.AlertStatus
    braceletId?: StringFilter<"Alert"> | string
    userId?: StringFilter<"Alert"> | string
    zoneId?: StringFilter<"Alert"> | string
    metadata?: JsonNullableFilter<"Alert">
    createdAt?: DateTimeFilter<"Alert"> | Date | string
    updatedAt?: DateTimeFilter<"Alert"> | Date | string
    resolvedAt?: DateTimeNullableFilter<"Alert"> | Date | string | null
    bracelet?: XOR<BraceletRelationFilter, BraceletWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    zone?: XOR<ZoneRelationFilter, ZoneWhereInput>
  }

  export type AlertOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    braceletId?: SortOrder
    userId?: SortOrder
    zoneId?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    bracelet?: BraceletOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    zone?: ZoneOrderByWithRelationInput
  }

  export type AlertWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AlertWhereInput | AlertWhereInput[]
    OR?: AlertWhereInput[]
    NOT?: AlertWhereInput | AlertWhereInput[]
    type?: EnumAlertTypeFilter<"Alert"> | $Enums.AlertType
    status?: EnumAlertStatusFilter<"Alert"> | $Enums.AlertStatus
    braceletId?: StringFilter<"Alert"> | string
    userId?: StringFilter<"Alert"> | string
    zoneId?: StringFilter<"Alert"> | string
    metadata?: JsonNullableFilter<"Alert">
    createdAt?: DateTimeFilter<"Alert"> | Date | string
    updatedAt?: DateTimeFilter<"Alert"> | Date | string
    resolvedAt?: DateTimeNullableFilter<"Alert"> | Date | string | null
    bracelet?: XOR<BraceletRelationFilter, BraceletWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    zone?: XOR<ZoneRelationFilter, ZoneWhereInput>
  }, "id">

  export type AlertOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    braceletId?: SortOrder
    userId?: SortOrder
    zoneId?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    _count?: AlertCountOrderByAggregateInput
    _max?: AlertMaxOrderByAggregateInput
    _min?: AlertMinOrderByAggregateInput
  }

  export type AlertScalarWhereWithAggregatesInput = {
    AND?: AlertScalarWhereWithAggregatesInput | AlertScalarWhereWithAggregatesInput[]
    OR?: AlertScalarWhereWithAggregatesInput[]
    NOT?: AlertScalarWhereWithAggregatesInput | AlertScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Alert"> | string
    type?: EnumAlertTypeWithAggregatesFilter<"Alert"> | $Enums.AlertType
    status?: EnumAlertStatusWithAggregatesFilter<"Alert"> | $Enums.AlertStatus
    braceletId?: StringWithAggregatesFilter<"Alert"> | string
    userId?: StringWithAggregatesFilter<"Alert"> | string
    zoneId?: StringWithAggregatesFilter<"Alert"> | string
    metadata?: JsonNullableWithAggregatesFilter<"Alert">
    createdAt?: DateTimeWithAggregatesFilter<"Alert"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Alert"> | Date | string
    resolvedAt?: DateTimeNullableWithAggregatesFilter<"Alert"> | Date | string | null
  }

  export type EmergencyWhereInput = {
    AND?: EmergencyWhereInput | EmergencyWhereInput[]
    OR?: EmergencyWhereInput[]
    NOT?: EmergencyWhereInput | EmergencyWhereInput[]
    id?: StringFilter<"Emergency"> | string
    status?: EnumEmergencyStatusFilter<"Emergency"> | $Enums.EmergencyStatus
    braceletId?: StringFilter<"Emergency"> | string
    zoneId?: StringFilter<"Emergency"> | string
    nightclubId?: StringFilter<"Emergency"> | string
    responderId?: StringNullableFilter<"Emergency"> | string | null
    responseTime?: IntNullableFilter<"Emergency"> | number | null
    escalationDetails?: JsonNullableFilter<"Emergency">
    resolutionDetails?: JsonNullableFilter<"Emergency">
    metadata?: JsonNullableFilter<"Emergency">
    createdAt?: DateTimeFilter<"Emergency"> | Date | string
    updatedAt?: DateTimeFilter<"Emergency"> | Date | string
    resolvedAt?: DateTimeNullableFilter<"Emergency"> | Date | string | null
    bracelet?: XOR<BraceletRelationFilter, BraceletWhereInput>
    zone?: XOR<ZoneRelationFilter, ZoneWhereInput>
    nightclub?: XOR<NightclubRelationFilter, NightclubWhereInput>
    responder?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type EmergencyOrderByWithRelationInput = {
    id?: SortOrder
    status?: SortOrder
    braceletId?: SortOrder
    zoneId?: SortOrder
    nightclubId?: SortOrder
    responderId?: SortOrderInput | SortOrder
    responseTime?: SortOrderInput | SortOrder
    escalationDetails?: SortOrderInput | SortOrder
    resolutionDetails?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    bracelet?: BraceletOrderByWithRelationInput
    zone?: ZoneOrderByWithRelationInput
    nightclub?: NightclubOrderByWithRelationInput
    responder?: UserOrderByWithRelationInput
  }

  export type EmergencyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EmergencyWhereInput | EmergencyWhereInput[]
    OR?: EmergencyWhereInput[]
    NOT?: EmergencyWhereInput | EmergencyWhereInput[]
    status?: EnumEmergencyStatusFilter<"Emergency"> | $Enums.EmergencyStatus
    braceletId?: StringFilter<"Emergency"> | string
    zoneId?: StringFilter<"Emergency"> | string
    nightclubId?: StringFilter<"Emergency"> | string
    responderId?: StringNullableFilter<"Emergency"> | string | null
    responseTime?: IntNullableFilter<"Emergency"> | number | null
    escalationDetails?: JsonNullableFilter<"Emergency">
    resolutionDetails?: JsonNullableFilter<"Emergency">
    metadata?: JsonNullableFilter<"Emergency">
    createdAt?: DateTimeFilter<"Emergency"> | Date | string
    updatedAt?: DateTimeFilter<"Emergency"> | Date | string
    resolvedAt?: DateTimeNullableFilter<"Emergency"> | Date | string | null
    bracelet?: XOR<BraceletRelationFilter, BraceletWhereInput>
    zone?: XOR<ZoneRelationFilter, ZoneWhereInput>
    nightclub?: XOR<NightclubRelationFilter, NightclubWhereInput>
    responder?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type EmergencyOrderByWithAggregationInput = {
    id?: SortOrder
    status?: SortOrder
    braceletId?: SortOrder
    zoneId?: SortOrder
    nightclubId?: SortOrder
    responderId?: SortOrderInput | SortOrder
    responseTime?: SortOrderInput | SortOrder
    escalationDetails?: SortOrderInput | SortOrder
    resolutionDetails?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    _count?: EmergencyCountOrderByAggregateInput
    _avg?: EmergencyAvgOrderByAggregateInput
    _max?: EmergencyMaxOrderByAggregateInput
    _min?: EmergencyMinOrderByAggregateInput
    _sum?: EmergencySumOrderByAggregateInput
  }

  export type EmergencyScalarWhereWithAggregatesInput = {
    AND?: EmergencyScalarWhereWithAggregatesInput | EmergencyScalarWhereWithAggregatesInput[]
    OR?: EmergencyScalarWhereWithAggregatesInput[]
    NOT?: EmergencyScalarWhereWithAggregatesInput | EmergencyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Emergency"> | string
    status?: EnumEmergencyStatusWithAggregatesFilter<"Emergency"> | $Enums.EmergencyStatus
    braceletId?: StringWithAggregatesFilter<"Emergency"> | string
    zoneId?: StringWithAggregatesFilter<"Emergency"> | string
    nightclubId?: StringWithAggregatesFilter<"Emergency"> | string
    responderId?: StringNullableWithAggregatesFilter<"Emergency"> | string | null
    responseTime?: IntNullableWithAggregatesFilter<"Emergency"> | number | null
    escalationDetails?: JsonNullableWithAggregatesFilter<"Emergency">
    resolutionDetails?: JsonNullableWithAggregatesFilter<"Emergency">
    metadata?: JsonNullableWithAggregatesFilter<"Emergency">
    createdAt?: DateTimeWithAggregatesFilter<"Emergency"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Emergency"> | Date | string
    resolvedAt?: DateTimeNullableWithAggregatesFilter<"Emergency"> | Date | string | null
  }

  export type SensorWhereInput = {
    AND?: SensorWhereInput | SensorWhereInput[]
    OR?: SensorWhereInput[]
    NOT?: SensorWhereInput | SensorWhereInput[]
    id?: StringFilter<"Sensor"> | string
    type?: EnumSensorTypeFilter<"Sensor"> | $Enums.SensorType
    status?: EnumSensorStatusFilter<"Sensor"> | $Enums.SensorStatus
    zoneId?: StringFilter<"Sensor"> | string
    data?: JsonNullableFilter<"Sensor">
    metadata?: JsonNullableFilter<"Sensor">
    createdAt?: DateTimeFilter<"Sensor"> | Date | string
    updatedAt?: DateTimeFilter<"Sensor"> | Date | string
    lastReading?: DateTimeNullableFilter<"Sensor"> | Date | string | null
    zone?: XOR<ZoneRelationFilter, ZoneWhereInput>
  }

  export type SensorOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    zoneId?: SortOrder
    data?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastReading?: SortOrderInput | SortOrder
    zone?: ZoneOrderByWithRelationInput
  }

  export type SensorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SensorWhereInput | SensorWhereInput[]
    OR?: SensorWhereInput[]
    NOT?: SensorWhereInput | SensorWhereInput[]
    type?: EnumSensorTypeFilter<"Sensor"> | $Enums.SensorType
    status?: EnumSensorStatusFilter<"Sensor"> | $Enums.SensorStatus
    zoneId?: StringFilter<"Sensor"> | string
    data?: JsonNullableFilter<"Sensor">
    metadata?: JsonNullableFilter<"Sensor">
    createdAt?: DateTimeFilter<"Sensor"> | Date | string
    updatedAt?: DateTimeFilter<"Sensor"> | Date | string
    lastReading?: DateTimeNullableFilter<"Sensor"> | Date | string | null
    zone?: XOR<ZoneRelationFilter, ZoneWhereInput>
  }, "id">

  export type SensorOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    zoneId?: SortOrder
    data?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastReading?: SortOrderInput | SortOrder
    _count?: SensorCountOrderByAggregateInput
    _max?: SensorMaxOrderByAggregateInput
    _min?: SensorMinOrderByAggregateInput
  }

  export type SensorScalarWhereWithAggregatesInput = {
    AND?: SensorScalarWhereWithAggregatesInput | SensorScalarWhereWithAggregatesInput[]
    OR?: SensorScalarWhereWithAggregatesInput[]
    NOT?: SensorScalarWhereWithAggregatesInput | SensorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Sensor"> | string
    type?: EnumSensorTypeWithAggregatesFilter<"Sensor"> | $Enums.SensorType
    status?: EnumSensorStatusWithAggregatesFilter<"Sensor"> | $Enums.SensorStatus
    zoneId?: StringWithAggregatesFilter<"Sensor"> | string
    data?: JsonNullableWithAggregatesFilter<"Sensor">
    metadata?: JsonNullableWithAggregatesFilter<"Sensor">
    createdAt?: DateTimeWithAggregatesFilter<"Sensor"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Sensor"> | Date | string
    lastReading?: DateTimeNullableWithAggregatesFilter<"Sensor"> | Date | string | null
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    userId?: StringNullableFilter<"AuditLog"> | string | null
    metadata?: JsonNullableFilter<"AuditLog">
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    userId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    action?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: StringFilter<"AuditLog"> | string
    userId?: StringNullableFilter<"AuditLog"> | string | null
    metadata?: JsonNullableFilter<"AuditLog">
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    userId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    entityType?: StringWithAggregatesFilter<"AuditLog"> | string
    entityId?: StringWithAggregatesFilter<"AuditLog"> | string
    userId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"AuditLog">
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type AnalyticsReportWhereInput = {
    AND?: AnalyticsReportWhereInput | AnalyticsReportWhereInput[]
    OR?: AnalyticsReportWhereInput[]
    NOT?: AnalyticsReportWhereInput | AnalyticsReportWhereInput[]
    id?: StringFilter<"AnalyticsReport"> | string
    nightclubId?: StringFilter<"AnalyticsReport"> | string
    type?: StringFilter<"AnalyticsReport"> | string
    report?: JsonFilter<"AnalyticsReport">
    metadata?: JsonNullableFilter<"AnalyticsReport">
    createdAt?: DateTimeFilter<"AnalyticsReport"> | Date | string
    updatedAt?: DateTimeFilter<"AnalyticsReport"> | Date | string
    nightclub?: XOR<NightclubRelationFilter, NightclubWhereInput>
  }

  export type AnalyticsReportOrderByWithRelationInput = {
    id?: SortOrder
    nightclubId?: SortOrder
    type?: SortOrder
    report?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nightclub?: NightclubOrderByWithRelationInput
  }

  export type AnalyticsReportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AnalyticsReportWhereInput | AnalyticsReportWhereInput[]
    OR?: AnalyticsReportWhereInput[]
    NOT?: AnalyticsReportWhereInput | AnalyticsReportWhereInput[]
    nightclubId?: StringFilter<"AnalyticsReport"> | string
    type?: StringFilter<"AnalyticsReport"> | string
    report?: JsonFilter<"AnalyticsReport">
    metadata?: JsonNullableFilter<"AnalyticsReport">
    createdAt?: DateTimeFilter<"AnalyticsReport"> | Date | string
    updatedAt?: DateTimeFilter<"AnalyticsReport"> | Date | string
    nightclub?: XOR<NightclubRelationFilter, NightclubWhereInput>
  }, "id">

  export type AnalyticsReportOrderByWithAggregationInput = {
    id?: SortOrder
    nightclubId?: SortOrder
    type?: SortOrder
    report?: SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AnalyticsReportCountOrderByAggregateInput
    _max?: AnalyticsReportMaxOrderByAggregateInput
    _min?: AnalyticsReportMinOrderByAggregateInput
  }

  export type AnalyticsReportScalarWhereWithAggregatesInput = {
    AND?: AnalyticsReportScalarWhereWithAggregatesInput | AnalyticsReportScalarWhereWithAggregatesInput[]
    OR?: AnalyticsReportScalarWhereWithAggregatesInput[]
    NOT?: AnalyticsReportScalarWhereWithAggregatesInput | AnalyticsReportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AnalyticsReport"> | string
    nightclubId?: StringWithAggregatesFilter<"AnalyticsReport"> | string
    type?: StringWithAggregatesFilter<"AnalyticsReport"> | string
    report?: JsonWithAggregatesFilter<"AnalyticsReport">
    metadata?: JsonNullableWithAggregatesFilter<"AnalyticsReport">
    createdAt?: DateTimeWithAggregatesFilter<"AnalyticsReport"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AnalyticsReport"> | Date | string
  }

  export type AIModelWhereInput = {
    AND?: AIModelWhereInput | AIModelWhereInput[]
    OR?: AIModelWhereInput[]
    NOT?: AIModelWhereInput | AIModelWhereInput[]
    id?: StringFilter<"AIModel"> | string
    type?: StringFilter<"AIModel"> | string
    name?: StringFilter<"AIModel"> | string
    version?: StringFilter<"AIModel"> | string
    status?: StringFilter<"AIModel"> | string
    config?: JsonFilter<"AIModel">
    createdAt?: DateTimeFilter<"AIModel"> | Date | string
    updatedAt?: DateTimeFilter<"AIModel"> | Date | string
    predictions?: PredictionListRelationFilter
    anomalies?: AnomalyListRelationFilter
    behaviorAnalyses?: BehaviorAnalysisListRelationFilter
  }

  export type AIModelOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    version?: SortOrder
    status?: SortOrder
    config?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    predictions?: PredictionOrderByRelationAggregateInput
    anomalies?: AnomalyOrderByRelationAggregateInput
    behaviorAnalyses?: BehaviorAnalysisOrderByRelationAggregateInput
  }

  export type AIModelWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AIModelWhereInput | AIModelWhereInput[]
    OR?: AIModelWhereInput[]
    NOT?: AIModelWhereInput | AIModelWhereInput[]
    type?: StringFilter<"AIModel"> | string
    name?: StringFilter<"AIModel"> | string
    version?: StringFilter<"AIModel"> | string
    status?: StringFilter<"AIModel"> | string
    config?: JsonFilter<"AIModel">
    createdAt?: DateTimeFilter<"AIModel"> | Date | string
    updatedAt?: DateTimeFilter<"AIModel"> | Date | string
    predictions?: PredictionListRelationFilter
    anomalies?: AnomalyListRelationFilter
    behaviorAnalyses?: BehaviorAnalysisListRelationFilter
  }, "id">

  export type AIModelOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    version?: SortOrder
    status?: SortOrder
    config?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AIModelCountOrderByAggregateInput
    _max?: AIModelMaxOrderByAggregateInput
    _min?: AIModelMinOrderByAggregateInput
  }

  export type AIModelScalarWhereWithAggregatesInput = {
    AND?: AIModelScalarWhereWithAggregatesInput | AIModelScalarWhereWithAggregatesInput[]
    OR?: AIModelScalarWhereWithAggregatesInput[]
    NOT?: AIModelScalarWhereWithAggregatesInput | AIModelScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AIModel"> | string
    type?: StringWithAggregatesFilter<"AIModel"> | string
    name?: StringWithAggregatesFilter<"AIModel"> | string
    version?: StringWithAggregatesFilter<"AIModel"> | string
    status?: StringWithAggregatesFilter<"AIModel"> | string
    config?: JsonWithAggregatesFilter<"AIModel">
    createdAt?: DateTimeWithAggregatesFilter<"AIModel"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AIModel"> | Date | string
  }

  export type PredictionWhereInput = {
    AND?: PredictionWhereInput | PredictionWhereInput[]
    OR?: PredictionWhereInput[]
    NOT?: PredictionWhereInput | PredictionWhereInput[]
    id?: StringFilter<"Prediction"> | string
    type?: StringFilter<"Prediction"> | string
    timestamp?: DateTimeFilter<"Prediction"> | Date | string
    value?: FloatFilter<"Prediction"> | number
    confidence?: FloatFilter<"Prediction"> | number
    metadata?: JsonNullableFilter<"Prediction">
    nightclubId?: StringFilter<"Prediction"> | string
    zoneId?: StringNullableFilter<"Prediction"> | string | null
    modelId?: StringFilter<"Prediction"> | string
    createdAt?: DateTimeFilter<"Prediction"> | Date | string
    updatedAt?: DateTimeFilter<"Prediction"> | Date | string
    nightclub?: XOR<NightclubRelationFilter, NightclubWhereInput>
    zone?: XOR<ZoneNullableRelationFilter, ZoneWhereInput> | null
    model?: XOR<AIModelRelationFilter, AIModelWhereInput>
  }

  export type PredictionOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    timestamp?: SortOrder
    value?: SortOrder
    confidence?: SortOrder
    metadata?: SortOrderInput | SortOrder
    nightclubId?: SortOrder
    zoneId?: SortOrderInput | SortOrder
    modelId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nightclub?: NightclubOrderByWithRelationInput
    zone?: ZoneOrderByWithRelationInput
    model?: AIModelOrderByWithRelationInput
  }

  export type PredictionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PredictionWhereInput | PredictionWhereInput[]
    OR?: PredictionWhereInput[]
    NOT?: PredictionWhereInput | PredictionWhereInput[]
    type?: StringFilter<"Prediction"> | string
    timestamp?: DateTimeFilter<"Prediction"> | Date | string
    value?: FloatFilter<"Prediction"> | number
    confidence?: FloatFilter<"Prediction"> | number
    metadata?: JsonNullableFilter<"Prediction">
    nightclubId?: StringFilter<"Prediction"> | string
    zoneId?: StringNullableFilter<"Prediction"> | string | null
    modelId?: StringFilter<"Prediction"> | string
    createdAt?: DateTimeFilter<"Prediction"> | Date | string
    updatedAt?: DateTimeFilter<"Prediction"> | Date | string
    nightclub?: XOR<NightclubRelationFilter, NightclubWhereInput>
    zone?: XOR<ZoneNullableRelationFilter, ZoneWhereInput> | null
    model?: XOR<AIModelRelationFilter, AIModelWhereInput>
  }, "id">

  export type PredictionOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    timestamp?: SortOrder
    value?: SortOrder
    confidence?: SortOrder
    metadata?: SortOrderInput | SortOrder
    nightclubId?: SortOrder
    zoneId?: SortOrderInput | SortOrder
    modelId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PredictionCountOrderByAggregateInput
    _avg?: PredictionAvgOrderByAggregateInput
    _max?: PredictionMaxOrderByAggregateInput
    _min?: PredictionMinOrderByAggregateInput
    _sum?: PredictionSumOrderByAggregateInput
  }

  export type PredictionScalarWhereWithAggregatesInput = {
    AND?: PredictionScalarWhereWithAggregatesInput | PredictionScalarWhereWithAggregatesInput[]
    OR?: PredictionScalarWhereWithAggregatesInput[]
    NOT?: PredictionScalarWhereWithAggregatesInput | PredictionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Prediction"> | string
    type?: StringWithAggregatesFilter<"Prediction"> | string
    timestamp?: DateTimeWithAggregatesFilter<"Prediction"> | Date | string
    value?: FloatWithAggregatesFilter<"Prediction"> | number
    confidence?: FloatWithAggregatesFilter<"Prediction"> | number
    metadata?: JsonNullableWithAggregatesFilter<"Prediction">
    nightclubId?: StringWithAggregatesFilter<"Prediction"> | string
    zoneId?: StringNullableWithAggregatesFilter<"Prediction"> | string | null
    modelId?: StringWithAggregatesFilter<"Prediction"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Prediction"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Prediction"> | Date | string
  }

  export type AnomalyWhereInput = {
    AND?: AnomalyWhereInput | AnomalyWhereInput[]
    OR?: AnomalyWhereInput[]
    NOT?: AnomalyWhereInput | AnomalyWhereInput[]
    id?: StringFilter<"Anomaly"> | string
    type?: StringFilter<"Anomaly"> | string
    severity?: StringFilter<"Anomaly"> | string
    status?: StringFilter<"Anomaly"> | string
    description?: StringFilter<"Anomaly"> | string
    timestamp?: DateTimeFilter<"Anomaly"> | Date | string
    metadata?: JsonNullableFilter<"Anomaly">
    nightclubId?: StringFilter<"Anomaly"> | string
    zoneId?: StringNullableFilter<"Anomaly"> | string | null
    modelId?: StringFilter<"Anomaly"> | string
    createdAt?: DateTimeFilter<"Anomaly"> | Date | string
    updatedAt?: DateTimeFilter<"Anomaly"> | Date | string
    nightclub?: XOR<NightclubRelationFilter, NightclubWhereInput>
    zone?: XOR<ZoneNullableRelationFilter, ZoneWhereInput> | null
    model?: XOR<AIModelRelationFilter, AIModelWhereInput>
  }

  export type AnomalyOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    severity?: SortOrder
    status?: SortOrder
    description?: SortOrder
    timestamp?: SortOrder
    metadata?: SortOrderInput | SortOrder
    nightclubId?: SortOrder
    zoneId?: SortOrderInput | SortOrder
    modelId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nightclub?: NightclubOrderByWithRelationInput
    zone?: ZoneOrderByWithRelationInput
    model?: AIModelOrderByWithRelationInput
  }

  export type AnomalyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AnomalyWhereInput | AnomalyWhereInput[]
    OR?: AnomalyWhereInput[]
    NOT?: AnomalyWhereInput | AnomalyWhereInput[]
    type?: StringFilter<"Anomaly"> | string
    severity?: StringFilter<"Anomaly"> | string
    status?: StringFilter<"Anomaly"> | string
    description?: StringFilter<"Anomaly"> | string
    timestamp?: DateTimeFilter<"Anomaly"> | Date | string
    metadata?: JsonNullableFilter<"Anomaly">
    nightclubId?: StringFilter<"Anomaly"> | string
    zoneId?: StringNullableFilter<"Anomaly"> | string | null
    modelId?: StringFilter<"Anomaly"> | string
    createdAt?: DateTimeFilter<"Anomaly"> | Date | string
    updatedAt?: DateTimeFilter<"Anomaly"> | Date | string
    nightclub?: XOR<NightclubRelationFilter, NightclubWhereInput>
    zone?: XOR<ZoneNullableRelationFilter, ZoneWhereInput> | null
    model?: XOR<AIModelRelationFilter, AIModelWhereInput>
  }, "id">

  export type AnomalyOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    severity?: SortOrder
    status?: SortOrder
    description?: SortOrder
    timestamp?: SortOrder
    metadata?: SortOrderInput | SortOrder
    nightclubId?: SortOrder
    zoneId?: SortOrderInput | SortOrder
    modelId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AnomalyCountOrderByAggregateInput
    _max?: AnomalyMaxOrderByAggregateInput
    _min?: AnomalyMinOrderByAggregateInput
  }

  export type AnomalyScalarWhereWithAggregatesInput = {
    AND?: AnomalyScalarWhereWithAggregatesInput | AnomalyScalarWhereWithAggregatesInput[]
    OR?: AnomalyScalarWhereWithAggregatesInput[]
    NOT?: AnomalyScalarWhereWithAggregatesInput | AnomalyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Anomaly"> | string
    type?: StringWithAggregatesFilter<"Anomaly"> | string
    severity?: StringWithAggregatesFilter<"Anomaly"> | string
    status?: StringWithAggregatesFilter<"Anomaly"> | string
    description?: StringWithAggregatesFilter<"Anomaly"> | string
    timestamp?: DateTimeWithAggregatesFilter<"Anomaly"> | Date | string
    metadata?: JsonNullableWithAggregatesFilter<"Anomaly">
    nightclubId?: StringWithAggregatesFilter<"Anomaly"> | string
    zoneId?: StringNullableWithAggregatesFilter<"Anomaly"> | string | null
    modelId?: StringWithAggregatesFilter<"Anomaly"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Anomaly"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Anomaly"> | Date | string
  }

  export type BehaviorAnalysisWhereInput = {
    AND?: BehaviorAnalysisWhereInput | BehaviorAnalysisWhereInput[]
    OR?: BehaviorAnalysisWhereInput[]
    NOT?: BehaviorAnalysisWhereInput | BehaviorAnalysisWhereInput[]
    id?: StringFilter<"BehaviorAnalysis"> | string
    type?: StringFilter<"BehaviorAnalysis"> | string
    timestamp?: DateTimeFilter<"BehaviorAnalysis"> | Date | string
    insights?: JsonFilter<"BehaviorAnalysis">
    metadata?: JsonNullableFilter<"BehaviorAnalysis">
    nightclubId?: StringFilter<"BehaviorAnalysis"> | string
    zoneId?: StringNullableFilter<"BehaviorAnalysis"> | string | null
    modelId?: StringFilter<"BehaviorAnalysis"> | string
    createdAt?: DateTimeFilter<"BehaviorAnalysis"> | Date | string
    updatedAt?: DateTimeFilter<"BehaviorAnalysis"> | Date | string
    nightclub?: XOR<NightclubRelationFilter, NightclubWhereInput>
    zone?: XOR<ZoneNullableRelationFilter, ZoneWhereInput> | null
    model?: XOR<AIModelRelationFilter, AIModelWhereInput>
  }

  export type BehaviorAnalysisOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    timestamp?: SortOrder
    insights?: SortOrder
    metadata?: SortOrderInput | SortOrder
    nightclubId?: SortOrder
    zoneId?: SortOrderInput | SortOrder
    modelId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nightclub?: NightclubOrderByWithRelationInput
    zone?: ZoneOrderByWithRelationInput
    model?: AIModelOrderByWithRelationInput
  }

  export type BehaviorAnalysisWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BehaviorAnalysisWhereInput | BehaviorAnalysisWhereInput[]
    OR?: BehaviorAnalysisWhereInput[]
    NOT?: BehaviorAnalysisWhereInput | BehaviorAnalysisWhereInput[]
    type?: StringFilter<"BehaviorAnalysis"> | string
    timestamp?: DateTimeFilter<"BehaviorAnalysis"> | Date | string
    insights?: JsonFilter<"BehaviorAnalysis">
    metadata?: JsonNullableFilter<"BehaviorAnalysis">
    nightclubId?: StringFilter<"BehaviorAnalysis"> | string
    zoneId?: StringNullableFilter<"BehaviorAnalysis"> | string | null
    modelId?: StringFilter<"BehaviorAnalysis"> | string
    createdAt?: DateTimeFilter<"BehaviorAnalysis"> | Date | string
    updatedAt?: DateTimeFilter<"BehaviorAnalysis"> | Date | string
    nightclub?: XOR<NightclubRelationFilter, NightclubWhereInput>
    zone?: XOR<ZoneNullableRelationFilter, ZoneWhereInput> | null
    model?: XOR<AIModelRelationFilter, AIModelWhereInput>
  }, "id">

  export type BehaviorAnalysisOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    timestamp?: SortOrder
    insights?: SortOrder
    metadata?: SortOrderInput | SortOrder
    nightclubId?: SortOrder
    zoneId?: SortOrderInput | SortOrder
    modelId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BehaviorAnalysisCountOrderByAggregateInput
    _max?: BehaviorAnalysisMaxOrderByAggregateInput
    _min?: BehaviorAnalysisMinOrderByAggregateInput
  }

  export type BehaviorAnalysisScalarWhereWithAggregatesInput = {
    AND?: BehaviorAnalysisScalarWhereWithAggregatesInput | BehaviorAnalysisScalarWhereWithAggregatesInput[]
    OR?: BehaviorAnalysisScalarWhereWithAggregatesInput[]
    NOT?: BehaviorAnalysisScalarWhereWithAggregatesInput | BehaviorAnalysisScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BehaviorAnalysis"> | string
    type?: StringWithAggregatesFilter<"BehaviorAnalysis"> | string
    timestamp?: DateTimeWithAggregatesFilter<"BehaviorAnalysis"> | Date | string
    insights?: JsonWithAggregatesFilter<"BehaviorAnalysis">
    metadata?: JsonNullableWithAggregatesFilter<"BehaviorAnalysis">
    nightclubId?: StringWithAggregatesFilter<"BehaviorAnalysis"> | string
    zoneId?: StringNullableWithAggregatesFilter<"BehaviorAnalysis"> | string | null
    modelId?: StringWithAggregatesFilter<"BehaviorAnalysis"> | string
    createdAt?: DateTimeWithAggregatesFilter<"BehaviorAnalysis"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BehaviorAnalysis"> | Date | string
  }

  export type RealTimeMetricWhereInput = {
    AND?: RealTimeMetricWhereInput | RealTimeMetricWhereInput[]
    OR?: RealTimeMetricWhereInput[]
    NOT?: RealTimeMetricWhereInput | RealTimeMetricWhereInput[]
    id?: StringFilter<"RealTimeMetric"> | string
    type?: StringFilter<"RealTimeMetric"> | string
    value?: FloatFilter<"RealTimeMetric"> | number
    timestamp?: DateTimeFilter<"RealTimeMetric"> | Date | string
    metadata?: JsonNullableFilter<"RealTimeMetric">
    nightclubId?: StringFilter<"RealTimeMetric"> | string
    zoneId?: StringNullableFilter<"RealTimeMetric"> | string | null
    createdAt?: DateTimeFilter<"RealTimeMetric"> | Date | string
    updatedAt?: DateTimeFilter<"RealTimeMetric"> | Date | string
    nightclub?: XOR<NightclubRelationFilter, NightclubWhereInput>
    zone?: XOR<ZoneNullableRelationFilter, ZoneWhereInput> | null
  }

  export type RealTimeMetricOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    value?: SortOrder
    timestamp?: SortOrder
    metadata?: SortOrderInput | SortOrder
    nightclubId?: SortOrder
    zoneId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nightclub?: NightclubOrderByWithRelationInput
    zone?: ZoneOrderByWithRelationInput
  }

  export type RealTimeMetricWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RealTimeMetricWhereInput | RealTimeMetricWhereInput[]
    OR?: RealTimeMetricWhereInput[]
    NOT?: RealTimeMetricWhereInput | RealTimeMetricWhereInput[]
    type?: StringFilter<"RealTimeMetric"> | string
    value?: FloatFilter<"RealTimeMetric"> | number
    timestamp?: DateTimeFilter<"RealTimeMetric"> | Date | string
    metadata?: JsonNullableFilter<"RealTimeMetric">
    nightclubId?: StringFilter<"RealTimeMetric"> | string
    zoneId?: StringNullableFilter<"RealTimeMetric"> | string | null
    createdAt?: DateTimeFilter<"RealTimeMetric"> | Date | string
    updatedAt?: DateTimeFilter<"RealTimeMetric"> | Date | string
    nightclub?: XOR<NightclubRelationFilter, NightclubWhereInput>
    zone?: XOR<ZoneNullableRelationFilter, ZoneWhereInput> | null
  }, "id">

  export type RealTimeMetricOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    value?: SortOrder
    timestamp?: SortOrder
    metadata?: SortOrderInput | SortOrder
    nightclubId?: SortOrder
    zoneId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RealTimeMetricCountOrderByAggregateInput
    _avg?: RealTimeMetricAvgOrderByAggregateInput
    _max?: RealTimeMetricMaxOrderByAggregateInput
    _min?: RealTimeMetricMinOrderByAggregateInput
    _sum?: RealTimeMetricSumOrderByAggregateInput
  }

  export type RealTimeMetricScalarWhereWithAggregatesInput = {
    AND?: RealTimeMetricScalarWhereWithAggregatesInput | RealTimeMetricScalarWhereWithAggregatesInput[]
    OR?: RealTimeMetricScalarWhereWithAggregatesInput[]
    NOT?: RealTimeMetricScalarWhereWithAggregatesInput | RealTimeMetricScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RealTimeMetric"> | string
    type?: StringWithAggregatesFilter<"RealTimeMetric"> | string
    value?: FloatWithAggregatesFilter<"RealTimeMetric"> | number
    timestamp?: DateTimeWithAggregatesFilter<"RealTimeMetric"> | Date | string
    metadata?: JsonNullableWithAggregatesFilter<"RealTimeMetric">
    nightclubId?: StringWithAggregatesFilter<"RealTimeMetric"> | string
    zoneId?: StringNullableWithAggregatesFilter<"RealTimeMetric"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"RealTimeMetric"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RealTimeMetric"> | Date | string
  }

  export type DataStreamWhereInput = {
    AND?: DataStreamWhereInput | DataStreamWhereInput[]
    OR?: DataStreamWhereInput[]
    NOT?: DataStreamWhereInput | DataStreamWhereInput[]
    id?: StringFilter<"DataStream"> | string
    type?: StringFilter<"DataStream"> | string
    status?: StringFilter<"DataStream"> | string
    lastUpdate?: DateTimeFilter<"DataStream"> | Date | string
    metadata?: JsonNullableFilter<"DataStream">
    nightclubId?: StringFilter<"DataStream"> | string
    createdAt?: DateTimeFilter<"DataStream"> | Date | string
    updatedAt?: DateTimeFilter<"DataStream"> | Date | string
    nightclub?: XOR<NightclubRelationFilter, NightclubWhereInput>
  }

  export type DataStreamOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    lastUpdate?: SortOrder
    metadata?: SortOrderInput | SortOrder
    nightclubId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nightclub?: NightclubOrderByWithRelationInput
  }

  export type DataStreamWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DataStreamWhereInput | DataStreamWhereInput[]
    OR?: DataStreamWhereInput[]
    NOT?: DataStreamWhereInput | DataStreamWhereInput[]
    type?: StringFilter<"DataStream"> | string
    status?: StringFilter<"DataStream"> | string
    lastUpdate?: DateTimeFilter<"DataStream"> | Date | string
    metadata?: JsonNullableFilter<"DataStream">
    nightclubId?: StringFilter<"DataStream"> | string
    createdAt?: DateTimeFilter<"DataStream"> | Date | string
    updatedAt?: DateTimeFilter<"DataStream"> | Date | string
    nightclub?: XOR<NightclubRelationFilter, NightclubWhereInput>
  }, "id">

  export type DataStreamOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    lastUpdate?: SortOrder
    metadata?: SortOrderInput | SortOrder
    nightclubId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DataStreamCountOrderByAggregateInput
    _max?: DataStreamMaxOrderByAggregateInput
    _min?: DataStreamMinOrderByAggregateInput
  }

  export type DataStreamScalarWhereWithAggregatesInput = {
    AND?: DataStreamScalarWhereWithAggregatesInput | DataStreamScalarWhereWithAggregatesInput[]
    OR?: DataStreamScalarWhereWithAggregatesInput[]
    NOT?: DataStreamScalarWhereWithAggregatesInput | DataStreamScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DataStream"> | string
    type?: StringWithAggregatesFilter<"DataStream"> | string
    status?: StringWithAggregatesFilter<"DataStream"> | string
    lastUpdate?: DateTimeWithAggregatesFilter<"DataStream"> | Date | string
    metadata?: JsonNullableWithAggregatesFilter<"DataStream">
    nightclubId?: StringWithAggregatesFilter<"DataStream"> | string
    createdAt?: DateTimeWithAggregatesFilter<"DataStream"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DataStream"> | Date | string
  }

  export type CacheEntryWhereInput = {
    AND?: CacheEntryWhereInput | CacheEntryWhereInput[]
    OR?: CacheEntryWhereInput[]
    NOT?: CacheEntryWhereInput | CacheEntryWhereInput[]
    id?: StringFilter<"CacheEntry"> | string
    key?: StringFilter<"CacheEntry"> | string
    value?: JsonFilter<"CacheEntry">
    expiresAt?: DateTimeNullableFilter<"CacheEntry"> | Date | string | null
    createdAt?: DateTimeFilter<"CacheEntry"> | Date | string
    updatedAt?: DateTimeFilter<"CacheEntry"> | Date | string
    nightclubId?: StringFilter<"CacheEntry"> | string
    nightclub?: XOR<NightclubRelationFilter, NightclubWhereInput>
  }

  export type CacheEntryOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nightclubId?: SortOrder
    nightclub?: NightclubOrderByWithRelationInput
  }

  export type CacheEntryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    key?: string
    AND?: CacheEntryWhereInput | CacheEntryWhereInput[]
    OR?: CacheEntryWhereInput[]
    NOT?: CacheEntryWhereInput | CacheEntryWhereInput[]
    value?: JsonFilter<"CacheEntry">
    expiresAt?: DateTimeNullableFilter<"CacheEntry"> | Date | string | null
    createdAt?: DateTimeFilter<"CacheEntry"> | Date | string
    updatedAt?: DateTimeFilter<"CacheEntry"> | Date | string
    nightclubId?: StringFilter<"CacheEntry"> | string
    nightclub?: XOR<NightclubRelationFilter, NightclubWhereInput>
  }, "id" | "key">

  export type CacheEntryOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nightclubId?: SortOrder
    _count?: CacheEntryCountOrderByAggregateInput
    _max?: CacheEntryMaxOrderByAggregateInput
    _min?: CacheEntryMinOrderByAggregateInput
  }

  export type CacheEntryScalarWhereWithAggregatesInput = {
    AND?: CacheEntryScalarWhereWithAggregatesInput | CacheEntryScalarWhereWithAggregatesInput[]
    OR?: CacheEntryScalarWhereWithAggregatesInput[]
    NOT?: CacheEntryScalarWhereWithAggregatesInput | CacheEntryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CacheEntry"> | string
    key?: StringWithAggregatesFilter<"CacheEntry"> | string
    value?: JsonWithAggregatesFilter<"CacheEntry">
    expiresAt?: DateTimeNullableWithAggregatesFilter<"CacheEntry"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CacheEntry"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CacheEntry"> | Date | string
    nightclubId?: StringWithAggregatesFilter<"CacheEntry"> | string
  }

  export type NightclubCreateInput = {
    id?: string
    name: string
    address: string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    floorPlans?: FloorPlanCreateNestedManyWithoutNightclubInput
    users?: UserCreateNestedManyWithoutNightclubInput
    bracelets?: BraceletCreateNestedManyWithoutNightclubInput
    zones?: ZoneCreateNestedManyWithoutNightclubInput
    emergencies?: EmergencyCreateNestedManyWithoutNightclubInput
    analyticsReports?: AnalyticsReportCreateNestedManyWithoutNightclubInput
    predictions?: PredictionCreateNestedManyWithoutNightclubInput
    anomalies?: AnomalyCreateNestedManyWithoutNightclubInput
    behaviors?: BehaviorAnalysisCreateNestedManyWithoutNightclubInput
    realTimeMetrics?: RealTimeMetricCreateNestedManyWithoutNightclubInput
    dataStreams?: DataStreamCreateNestedManyWithoutNightclubInput
    cacheEntries?: CacheEntryCreateNestedManyWithoutNightclubInput
  }

  export type NightclubUncheckedCreateInput = {
    id?: string
    name: string
    address: string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    floorPlans?: FloorPlanUncheckedCreateNestedManyWithoutNightclubInput
    users?: UserUncheckedCreateNestedManyWithoutNightclubInput
    bracelets?: BraceletUncheckedCreateNestedManyWithoutNightclubInput
    zones?: ZoneUncheckedCreateNestedManyWithoutNightclubInput
    emergencies?: EmergencyUncheckedCreateNestedManyWithoutNightclubInput
    analyticsReports?: AnalyticsReportUncheckedCreateNestedManyWithoutNightclubInput
    predictions?: PredictionUncheckedCreateNestedManyWithoutNightclubInput
    anomalies?: AnomalyUncheckedCreateNestedManyWithoutNightclubInput
    behaviors?: BehaviorAnalysisUncheckedCreateNestedManyWithoutNightclubInput
    realTimeMetrics?: RealTimeMetricUncheckedCreateNestedManyWithoutNightclubInput
    dataStreams?: DataStreamUncheckedCreateNestedManyWithoutNightclubInput
    cacheEntries?: CacheEntryUncheckedCreateNestedManyWithoutNightclubInput
  }

  export type NightclubUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    floorPlans?: FloorPlanUpdateManyWithoutNightclubNestedInput
    users?: UserUpdateManyWithoutNightclubNestedInput
    bracelets?: BraceletUpdateManyWithoutNightclubNestedInput
    zones?: ZoneUpdateManyWithoutNightclubNestedInput
    emergencies?: EmergencyUpdateManyWithoutNightclubNestedInput
    analyticsReports?: AnalyticsReportUpdateManyWithoutNightclubNestedInput
    predictions?: PredictionUpdateManyWithoutNightclubNestedInput
    anomalies?: AnomalyUpdateManyWithoutNightclubNestedInput
    behaviors?: BehaviorAnalysisUpdateManyWithoutNightclubNestedInput
    realTimeMetrics?: RealTimeMetricUpdateManyWithoutNightclubNestedInput
    dataStreams?: DataStreamUpdateManyWithoutNightclubNestedInput
    cacheEntries?: CacheEntryUpdateManyWithoutNightclubNestedInput
  }

  export type NightclubUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    floorPlans?: FloorPlanUncheckedUpdateManyWithoutNightclubNestedInput
    users?: UserUncheckedUpdateManyWithoutNightclubNestedInput
    bracelets?: BraceletUncheckedUpdateManyWithoutNightclubNestedInput
    zones?: ZoneUncheckedUpdateManyWithoutNightclubNestedInput
    emergencies?: EmergencyUncheckedUpdateManyWithoutNightclubNestedInput
    analyticsReports?: AnalyticsReportUncheckedUpdateManyWithoutNightclubNestedInput
    predictions?: PredictionUncheckedUpdateManyWithoutNightclubNestedInput
    anomalies?: AnomalyUncheckedUpdateManyWithoutNightclubNestedInput
    behaviors?: BehaviorAnalysisUncheckedUpdateManyWithoutNightclubNestedInput
    realTimeMetrics?: RealTimeMetricUncheckedUpdateManyWithoutNightclubNestedInput
    dataStreams?: DataStreamUncheckedUpdateManyWithoutNightclubNestedInput
    cacheEntries?: CacheEntryUncheckedUpdateManyWithoutNightclubNestedInput
  }

  export type NightclubCreateManyInput = {
    id?: string
    name: string
    address: string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NightclubUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NightclubUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    deviceId?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    lastLocation?: NullableJsonNullValueInput | InputJsonValue
    nightclub?: NightclubCreateNestedOneWithoutUsersInput
    alerts?: AlertCreateNestedManyWithoutUserInput
    emergencies?: EmergencyCreateNestedManyWithoutResponderInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    deviceId?: string | null
    nightclubId?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    lastLocation?: NullableJsonNullValueInput | InputJsonValue
    alerts?: AlertUncheckedCreateNestedManyWithoutUserInput
    emergencies?: EmergencyUncheckedCreateNestedManyWithoutResponderInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLocation?: NullableJsonNullValueInput | InputJsonValue
    nightclub?: NightclubUpdateOneWithoutUsersNestedInput
    alerts?: AlertUpdateManyWithoutUserNestedInput
    emergencies?: EmergencyUpdateManyWithoutResponderNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    nightclubId?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLocation?: NullableJsonNullValueInput | InputJsonValue
    alerts?: AlertUncheckedUpdateManyWithoutUserNestedInput
    emergencies?: EmergencyUncheckedUpdateManyWithoutResponderNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    deviceId?: string | null
    nightclubId?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    lastLocation?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLocation?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    nightclubId?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLocation?: NullableJsonNullValueInput | InputJsonValue
  }

  export type FloorPlanCreateInput = {
    id?: string
    name: string
    imageUrl: string
    createdAt?: Date | string
    updatedAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    nightclub: NightclubCreateNestedOneWithoutFloorPlansInput
    zones?: ZoneCreateNestedManyWithoutFloorPlanInput
  }

  export type FloorPlanUncheckedCreateInput = {
    id?: string
    name: string
    imageUrl: string
    nightclubId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    zones?: ZoneUncheckedCreateNestedManyWithoutFloorPlanInput
  }

  export type FloorPlanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    nightclub?: NightclubUpdateOneRequiredWithoutFloorPlansNestedInput
    zones?: ZoneUpdateManyWithoutFloorPlanNestedInput
  }

  export type FloorPlanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    nightclubId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    zones?: ZoneUncheckedUpdateManyWithoutFloorPlanNestedInput
  }

  export type FloorPlanCreateManyInput = {
    id?: string
    name: string
    imageUrl: string
    nightclubId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type FloorPlanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type FloorPlanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    nightclubId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ZoneCreateInput = {
    id?: string
    name: string
    coordinates: JsonNullValueInput | InputJsonValue
    capacity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    floorPlan: FloorPlanCreateNestedOneWithoutZonesInput
    nightclub: NightclubCreateNestedOneWithoutZonesInput
    alerts?: AlertCreateNestedManyWithoutZoneInput
    emergencies?: EmergencyCreateNestedManyWithoutZoneInput
    sensors?: SensorCreateNestedManyWithoutZoneInput
    anomalies?: AnomalyCreateNestedManyWithoutZoneInput
    behaviors?: BehaviorAnalysisCreateNestedManyWithoutZoneInput
    realTimeMetrics?: RealTimeMetricCreateNestedManyWithoutZoneInput
    predictions?: PredictionCreateNestedManyWithoutZoneInput
  }

  export type ZoneUncheckedCreateInput = {
    id?: string
    name: string
    coordinates: JsonNullValueInput | InputJsonValue
    capacity: number
    floorPlanId: string
    nightclubId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    alerts?: AlertUncheckedCreateNestedManyWithoutZoneInput
    emergencies?: EmergencyUncheckedCreateNestedManyWithoutZoneInput
    sensors?: SensorUncheckedCreateNestedManyWithoutZoneInput
    anomalies?: AnomalyUncheckedCreateNestedManyWithoutZoneInput
    behaviors?: BehaviorAnalysisUncheckedCreateNestedManyWithoutZoneInput
    realTimeMetrics?: RealTimeMetricUncheckedCreateNestedManyWithoutZoneInput
    predictions?: PredictionUncheckedCreateNestedManyWithoutZoneInput
  }

  export type ZoneUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    coordinates?: JsonNullValueInput | InputJsonValue
    capacity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    floorPlan?: FloorPlanUpdateOneRequiredWithoutZonesNestedInput
    nightclub?: NightclubUpdateOneRequiredWithoutZonesNestedInput
    alerts?: AlertUpdateManyWithoutZoneNestedInput
    emergencies?: EmergencyUpdateManyWithoutZoneNestedInput
    sensors?: SensorUpdateManyWithoutZoneNestedInput
    anomalies?: AnomalyUpdateManyWithoutZoneNestedInput
    behaviors?: BehaviorAnalysisUpdateManyWithoutZoneNestedInput
    realTimeMetrics?: RealTimeMetricUpdateManyWithoutZoneNestedInput
    predictions?: PredictionUpdateManyWithoutZoneNestedInput
  }

  export type ZoneUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    coordinates?: JsonNullValueInput | InputJsonValue
    capacity?: IntFieldUpdateOperationsInput | number
    floorPlanId?: StringFieldUpdateOperationsInput | string
    nightclubId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    alerts?: AlertUncheckedUpdateManyWithoutZoneNestedInput
    emergencies?: EmergencyUncheckedUpdateManyWithoutZoneNestedInput
    sensors?: SensorUncheckedUpdateManyWithoutZoneNestedInput
    anomalies?: AnomalyUncheckedUpdateManyWithoutZoneNestedInput
    behaviors?: BehaviorAnalysisUncheckedUpdateManyWithoutZoneNestedInput
    realTimeMetrics?: RealTimeMetricUncheckedUpdateManyWithoutZoneNestedInput
    predictions?: PredictionUncheckedUpdateManyWithoutZoneNestedInput
  }

  export type ZoneCreateManyInput = {
    id?: string
    name: string
    coordinates: JsonNullValueInput | InputJsonValue
    capacity: number
    floorPlanId: string
    nightclubId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ZoneUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    coordinates?: JsonNullValueInput | InputJsonValue
    capacity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ZoneUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    coordinates?: JsonNullValueInput | InputJsonValue
    capacity?: IntFieldUpdateOperationsInput | number
    floorPlanId?: StringFieldUpdateOperationsInput | string
    nightclubId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BraceletCreateInput = {
    id?: string
    deviceId: string
    batteryLevel?: number | null
    status?: $Enums.BraceletStatus
    lastSeen?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    nightclub: NightclubCreateNestedOneWithoutBraceletsInput
    alerts?: AlertCreateNestedManyWithoutBraceletInput
    emergencies?: EmergencyCreateNestedManyWithoutBraceletInput
  }

  export type BraceletUncheckedCreateInput = {
    id?: string
    deviceId: string
    batteryLevel?: number | null
    status?: $Enums.BraceletStatus
    lastSeen?: Date | string | null
    nightclubId: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    alerts?: AlertUncheckedCreateNestedManyWithoutBraceletInput
    emergencies?: EmergencyUncheckedCreateNestedManyWithoutBraceletInput
  }

  export type BraceletUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    batteryLevel?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumBraceletStatusFieldUpdateOperationsInput | $Enums.BraceletStatus
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nightclub?: NightclubUpdateOneRequiredWithoutBraceletsNestedInput
    alerts?: AlertUpdateManyWithoutBraceletNestedInput
    emergencies?: EmergencyUpdateManyWithoutBraceletNestedInput
  }

  export type BraceletUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    batteryLevel?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumBraceletStatusFieldUpdateOperationsInput | $Enums.BraceletStatus
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nightclubId?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    alerts?: AlertUncheckedUpdateManyWithoutBraceletNestedInput
    emergencies?: EmergencyUncheckedUpdateManyWithoutBraceletNestedInput
  }

  export type BraceletCreateManyInput = {
    id?: string
    deviceId: string
    batteryLevel?: number | null
    status?: $Enums.BraceletStatus
    lastSeen?: Date | string | null
    nightclubId: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BraceletUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    batteryLevel?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumBraceletStatusFieldUpdateOperationsInput | $Enums.BraceletStatus
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BraceletUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    batteryLevel?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumBraceletStatusFieldUpdateOperationsInput | $Enums.BraceletStatus
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nightclubId?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlertCreateInput = {
    id?: string
    type: $Enums.AlertType
    status?: $Enums.AlertStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    resolvedAt?: Date | string | null
    bracelet: BraceletCreateNestedOneWithoutAlertsInput
    user: UserCreateNestedOneWithoutAlertsInput
    zone: ZoneCreateNestedOneWithoutAlertsInput
  }

  export type AlertUncheckedCreateInput = {
    id?: string
    type: $Enums.AlertType
    status?: $Enums.AlertStatus
    braceletId: string
    userId: string
    zoneId: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    resolvedAt?: Date | string | null
  }

  export type AlertUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAlertTypeFieldUpdateOperationsInput | $Enums.AlertType
    status?: EnumAlertStatusFieldUpdateOperationsInput | $Enums.AlertStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bracelet?: BraceletUpdateOneRequiredWithoutAlertsNestedInput
    user?: UserUpdateOneRequiredWithoutAlertsNestedInput
    zone?: ZoneUpdateOneRequiredWithoutAlertsNestedInput
  }

  export type AlertUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAlertTypeFieldUpdateOperationsInput | $Enums.AlertType
    status?: EnumAlertStatusFieldUpdateOperationsInput | $Enums.AlertStatus
    braceletId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AlertCreateManyInput = {
    id?: string
    type: $Enums.AlertType
    status?: $Enums.AlertStatus
    braceletId: string
    userId: string
    zoneId: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    resolvedAt?: Date | string | null
  }

  export type AlertUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAlertTypeFieldUpdateOperationsInput | $Enums.AlertType
    status?: EnumAlertStatusFieldUpdateOperationsInput | $Enums.AlertStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AlertUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAlertTypeFieldUpdateOperationsInput | $Enums.AlertType
    status?: EnumAlertStatusFieldUpdateOperationsInput | $Enums.AlertStatus
    braceletId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmergencyCreateInput = {
    id?: string
    status?: $Enums.EmergencyStatus
    responseTime?: number | null
    escalationDetails?: NullableJsonNullValueInput | InputJsonValue
    resolutionDetails?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    resolvedAt?: Date | string | null
    bracelet: BraceletCreateNestedOneWithoutEmergenciesInput
    zone: ZoneCreateNestedOneWithoutEmergenciesInput
    nightclub: NightclubCreateNestedOneWithoutEmergenciesInput
    responder?: UserCreateNestedOneWithoutEmergenciesInput
  }

  export type EmergencyUncheckedCreateInput = {
    id?: string
    status?: $Enums.EmergencyStatus
    braceletId: string
    zoneId: string
    nightclubId: string
    responderId?: string | null
    responseTime?: number | null
    escalationDetails?: NullableJsonNullValueInput | InputJsonValue
    resolutionDetails?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    resolvedAt?: Date | string | null
  }

  export type EmergencyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumEmergencyStatusFieldUpdateOperationsInput | $Enums.EmergencyStatus
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    escalationDetails?: NullableJsonNullValueInput | InputJsonValue
    resolutionDetails?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bracelet?: BraceletUpdateOneRequiredWithoutEmergenciesNestedInput
    zone?: ZoneUpdateOneRequiredWithoutEmergenciesNestedInput
    nightclub?: NightclubUpdateOneRequiredWithoutEmergenciesNestedInput
    responder?: UserUpdateOneWithoutEmergenciesNestedInput
  }

  export type EmergencyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumEmergencyStatusFieldUpdateOperationsInput | $Enums.EmergencyStatus
    braceletId?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    nightclubId?: StringFieldUpdateOperationsInput | string
    responderId?: NullableStringFieldUpdateOperationsInput | string | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    escalationDetails?: NullableJsonNullValueInput | InputJsonValue
    resolutionDetails?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmergencyCreateManyInput = {
    id?: string
    status?: $Enums.EmergencyStatus
    braceletId: string
    zoneId: string
    nightclubId: string
    responderId?: string | null
    responseTime?: number | null
    escalationDetails?: NullableJsonNullValueInput | InputJsonValue
    resolutionDetails?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    resolvedAt?: Date | string | null
  }

  export type EmergencyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumEmergencyStatusFieldUpdateOperationsInput | $Enums.EmergencyStatus
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    escalationDetails?: NullableJsonNullValueInput | InputJsonValue
    resolutionDetails?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmergencyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumEmergencyStatusFieldUpdateOperationsInput | $Enums.EmergencyStatus
    braceletId?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    nightclubId?: StringFieldUpdateOperationsInput | string
    responderId?: NullableStringFieldUpdateOperationsInput | string | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    escalationDetails?: NullableJsonNullValueInput | InputJsonValue
    resolutionDetails?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SensorCreateInput = {
    id?: string
    type: $Enums.SensorType
    status?: $Enums.SensorStatus
    data?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    lastReading?: Date | string | null
    zone: ZoneCreateNestedOneWithoutSensorsInput
  }

  export type SensorUncheckedCreateInput = {
    id?: string
    type: $Enums.SensorType
    status?: $Enums.SensorStatus
    zoneId: string
    data?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    lastReading?: Date | string | null
  }

  export type SensorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumSensorTypeFieldUpdateOperationsInput | $Enums.SensorType
    status?: EnumSensorStatusFieldUpdateOperationsInput | $Enums.SensorStatus
    data?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastReading?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    zone?: ZoneUpdateOneRequiredWithoutSensorsNestedInput
  }

  export type SensorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumSensorTypeFieldUpdateOperationsInput | $Enums.SensorType
    status?: EnumSensorStatusFieldUpdateOperationsInput | $Enums.SensorStatus
    zoneId?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastReading?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SensorCreateManyInput = {
    id?: string
    type: $Enums.SensorType
    status?: $Enums.SensorStatus
    zoneId: string
    data?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    lastReading?: Date | string | null
  }

  export type SensorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumSensorTypeFieldUpdateOperationsInput | $Enums.SensorType
    status?: EnumSensorStatusFieldUpdateOperationsInput | $Enums.SensorStatus
    data?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastReading?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SensorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumSensorTypeFieldUpdateOperationsInput | $Enums.SensorType
    status?: EnumSensorStatusFieldUpdateOperationsInput | $Enums.SensorStatus
    zoneId?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastReading?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AuditLogCreateInput = {
    id?: string
    action: string
    entityType: string
    entityId: string
    userId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    action: string
    entityType: string
    entityId: string
    userId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    action: string
    entityType: string
    entityId: string
    userId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsReportCreateInput = {
    id?: string
    type: string
    report: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    nightclub: NightclubCreateNestedOneWithoutAnalyticsReportsInput
  }

  export type AnalyticsReportUncheckedCreateInput = {
    id?: string
    nightclubId: string
    type: string
    report: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnalyticsReportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    report?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nightclub?: NightclubUpdateOneRequiredWithoutAnalyticsReportsNestedInput
  }

  export type AnalyticsReportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nightclubId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    report?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsReportCreateManyInput = {
    id?: string
    nightclubId: string
    type: string
    report: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnalyticsReportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    report?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsReportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nightclubId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    report?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIModelCreateInput = {
    id?: string
    type: string
    name: string
    version: string
    status: string
    config: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    predictions?: PredictionCreateNestedManyWithoutModelInput
    anomalies?: AnomalyCreateNestedManyWithoutModelInput
    behaviorAnalyses?: BehaviorAnalysisCreateNestedManyWithoutModelInput
  }

  export type AIModelUncheckedCreateInput = {
    id?: string
    type: string
    name: string
    version: string
    status: string
    config: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    predictions?: PredictionUncheckedCreateNestedManyWithoutModelInput
    anomalies?: AnomalyUncheckedCreateNestedManyWithoutModelInput
    behaviorAnalyses?: BehaviorAnalysisUncheckedCreateNestedManyWithoutModelInput
  }

  export type AIModelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    predictions?: PredictionUpdateManyWithoutModelNestedInput
    anomalies?: AnomalyUpdateManyWithoutModelNestedInput
    behaviorAnalyses?: BehaviorAnalysisUpdateManyWithoutModelNestedInput
  }

  export type AIModelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    predictions?: PredictionUncheckedUpdateManyWithoutModelNestedInput
    anomalies?: AnomalyUncheckedUpdateManyWithoutModelNestedInput
    behaviorAnalyses?: BehaviorAnalysisUncheckedUpdateManyWithoutModelNestedInput
  }

  export type AIModelCreateManyInput = {
    id?: string
    type: string
    name: string
    version: string
    status: string
    config: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AIModelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AIModelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PredictionCreateInput = {
    id?: string
    type: string
    timestamp?: Date | string
    value: number
    confidence: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    nightclub: NightclubCreateNestedOneWithoutPredictionsInput
    zone?: ZoneCreateNestedOneWithoutPredictionsInput
    model: AIModelCreateNestedOneWithoutPredictionsInput
  }

  export type PredictionUncheckedCreateInput = {
    id?: string
    type: string
    timestamp?: Date | string
    value: number
    confidence: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    nightclubId: string
    zoneId?: string | null
    modelId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PredictionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: FloatFieldUpdateOperationsInput | number
    confidence?: FloatFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nightclub?: NightclubUpdateOneRequiredWithoutPredictionsNestedInput
    zone?: ZoneUpdateOneWithoutPredictionsNestedInput
    model?: AIModelUpdateOneRequiredWithoutPredictionsNestedInput
  }

  export type PredictionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: FloatFieldUpdateOperationsInput | number
    confidence?: FloatFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    nightclubId?: StringFieldUpdateOperationsInput | string
    zoneId?: NullableStringFieldUpdateOperationsInput | string | null
    modelId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PredictionCreateManyInput = {
    id?: string
    type: string
    timestamp?: Date | string
    value: number
    confidence: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    nightclubId: string
    zoneId?: string | null
    modelId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PredictionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: FloatFieldUpdateOperationsInput | number
    confidence?: FloatFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PredictionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: FloatFieldUpdateOperationsInput | number
    confidence?: FloatFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    nightclubId?: StringFieldUpdateOperationsInput | string
    zoneId?: NullableStringFieldUpdateOperationsInput | string | null
    modelId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnomalyCreateInput = {
    id?: string
    type: string
    severity: string
    status: string
    description: string
    timestamp?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    nightclub: NightclubCreateNestedOneWithoutAnomaliesInput
    zone?: ZoneCreateNestedOneWithoutAnomaliesInput
    model: AIModelCreateNestedOneWithoutAnomaliesInput
  }

  export type AnomalyUncheckedCreateInput = {
    id?: string
    type: string
    severity: string
    status: string
    description: string
    timestamp?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    nightclubId: string
    zoneId?: string | null
    modelId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnomalyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nightclub?: NightclubUpdateOneRequiredWithoutAnomaliesNestedInput
    zone?: ZoneUpdateOneWithoutAnomaliesNestedInput
    model?: AIModelUpdateOneRequiredWithoutAnomaliesNestedInput
  }

  export type AnomalyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    nightclubId?: StringFieldUpdateOperationsInput | string
    zoneId?: NullableStringFieldUpdateOperationsInput | string | null
    modelId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnomalyCreateManyInput = {
    id?: string
    type: string
    severity: string
    status: string
    description: string
    timestamp?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    nightclubId: string
    zoneId?: string | null
    modelId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnomalyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnomalyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    nightclubId?: StringFieldUpdateOperationsInput | string
    zoneId?: NullableStringFieldUpdateOperationsInput | string | null
    modelId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BehaviorAnalysisCreateInput = {
    id?: string
    type: string
    timestamp?: Date | string
    insights: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    nightclub: NightclubCreateNestedOneWithoutBehaviorsInput
    zone?: ZoneCreateNestedOneWithoutBehaviorsInput
    model: AIModelCreateNestedOneWithoutBehaviorAnalysesInput
  }

  export type BehaviorAnalysisUncheckedCreateInput = {
    id?: string
    type: string
    timestamp?: Date | string
    insights: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    nightclubId: string
    zoneId?: string | null
    modelId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BehaviorAnalysisUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    insights?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nightclub?: NightclubUpdateOneRequiredWithoutBehaviorsNestedInput
    zone?: ZoneUpdateOneWithoutBehaviorsNestedInput
    model?: AIModelUpdateOneRequiredWithoutBehaviorAnalysesNestedInput
  }

  export type BehaviorAnalysisUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    insights?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    nightclubId?: StringFieldUpdateOperationsInput | string
    zoneId?: NullableStringFieldUpdateOperationsInput | string | null
    modelId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BehaviorAnalysisCreateManyInput = {
    id?: string
    type: string
    timestamp?: Date | string
    insights: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    nightclubId: string
    zoneId?: string | null
    modelId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BehaviorAnalysisUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    insights?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BehaviorAnalysisUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    insights?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    nightclubId?: StringFieldUpdateOperationsInput | string
    zoneId?: NullableStringFieldUpdateOperationsInput | string | null
    modelId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RealTimeMetricCreateInput = {
    id?: string
    type: string
    value: number
    timestamp?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    nightclub: NightclubCreateNestedOneWithoutRealTimeMetricsInput
    zone?: ZoneCreateNestedOneWithoutRealTimeMetricsInput
  }

  export type RealTimeMetricUncheckedCreateInput = {
    id?: string
    type: string
    value: number
    timestamp?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    nightclubId: string
    zoneId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RealTimeMetricUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nightclub?: NightclubUpdateOneRequiredWithoutRealTimeMetricsNestedInput
    zone?: ZoneUpdateOneWithoutRealTimeMetricsNestedInput
  }

  export type RealTimeMetricUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    nightclubId?: StringFieldUpdateOperationsInput | string
    zoneId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RealTimeMetricCreateManyInput = {
    id?: string
    type: string
    value: number
    timestamp?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    nightclubId: string
    zoneId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RealTimeMetricUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RealTimeMetricUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    nightclubId?: StringFieldUpdateOperationsInput | string
    zoneId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DataStreamCreateInput = {
    id?: string
    type: string
    status: string
    lastUpdate?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    nightclub: NightclubCreateNestedOneWithoutDataStreamsInput
  }

  export type DataStreamUncheckedCreateInput = {
    id?: string
    type: string
    status: string
    lastUpdate?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    nightclubId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DataStreamUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nightclub?: NightclubUpdateOneRequiredWithoutDataStreamsNestedInput
  }

  export type DataStreamUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    nightclubId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DataStreamCreateManyInput = {
    id?: string
    type: string
    status: string
    lastUpdate?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    nightclubId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DataStreamUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DataStreamUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    nightclubId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CacheEntryCreateInput = {
    id?: string
    key: string
    value: JsonNullValueInput | InputJsonValue
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    nightclub: NightclubCreateNestedOneWithoutCacheEntriesInput
  }

  export type CacheEntryUncheckedCreateInput = {
    id?: string
    key: string
    value: JsonNullValueInput | InputJsonValue
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    nightclubId: string
  }

  export type CacheEntryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nightclub?: NightclubUpdateOneRequiredWithoutCacheEntriesNestedInput
  }

  export type CacheEntryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nightclubId?: StringFieldUpdateOperationsInput | string
  }

  export type CacheEntryCreateManyInput = {
    id?: string
    key: string
    value: JsonNullValueInput | InputJsonValue
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    nightclubId: string
  }

  export type CacheEntryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CacheEntryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nightclubId?: StringFieldUpdateOperationsInput | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type FloorPlanListRelationFilter = {
    every?: FloorPlanWhereInput
    some?: FloorPlanWhereInput
    none?: FloorPlanWhereInput
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type BraceletListRelationFilter = {
    every?: BraceletWhereInput
    some?: BraceletWhereInput
    none?: BraceletWhereInput
  }

  export type ZoneListRelationFilter = {
    every?: ZoneWhereInput
    some?: ZoneWhereInput
    none?: ZoneWhereInput
  }

  export type EmergencyListRelationFilter = {
    every?: EmergencyWhereInput
    some?: EmergencyWhereInput
    none?: EmergencyWhereInput
  }

  export type AnalyticsReportListRelationFilter = {
    every?: AnalyticsReportWhereInput
    some?: AnalyticsReportWhereInput
    none?: AnalyticsReportWhereInput
  }

  export type PredictionListRelationFilter = {
    every?: PredictionWhereInput
    some?: PredictionWhereInput
    none?: PredictionWhereInput
  }

  export type AnomalyListRelationFilter = {
    every?: AnomalyWhereInput
    some?: AnomalyWhereInput
    none?: AnomalyWhereInput
  }

  export type BehaviorAnalysisListRelationFilter = {
    every?: BehaviorAnalysisWhereInput
    some?: BehaviorAnalysisWhereInput
    none?: BehaviorAnalysisWhereInput
  }

  export type RealTimeMetricListRelationFilter = {
    every?: RealTimeMetricWhereInput
    some?: RealTimeMetricWhereInput
    none?: RealTimeMetricWhereInput
  }

  export type DataStreamListRelationFilter = {
    every?: DataStreamWhereInput
    some?: DataStreamWhereInput
    none?: DataStreamWhereInput
  }

  export type CacheEntryListRelationFilter = {
    every?: CacheEntryWhereInput
    some?: CacheEntryWhereInput
    none?: CacheEntryWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type FloorPlanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BraceletOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ZoneOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmergencyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AnalyticsReportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PredictionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AnomalyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BehaviorAnalysisOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RealTimeMetricOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DataStreamOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CacheEntryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NightclubCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    settings?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NightclubMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NightclubMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type EnumUserStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusFilter<$PrismaModel> | $Enums.UserStatus
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NightclubNullableRelationFilter = {
    is?: NightclubWhereInput | null
    isNot?: NightclubWhereInput | null
  }

  export type AlertListRelationFilter = {
    every?: AlertWhereInput
    some?: AlertWhereInput
    none?: AlertWhereInput
  }

  export type AlertOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    status?: SortOrder
    deviceId?: SortOrder
    nightclubId?: SortOrder
    resetToken?: SortOrder
    resetTokenExpiry?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLogin?: SortOrder
    lastLocation?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    status?: SortOrder
    deviceId?: SortOrder
    nightclubId?: SortOrder
    resetToken?: SortOrder
    resetTokenExpiry?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLogin?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    status?: SortOrder
    deviceId?: SortOrder
    nightclubId?: SortOrder
    resetToken?: SortOrder
    resetTokenExpiry?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastLogin?: SortOrder
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type EnumUserStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusWithAggregatesFilter<$PrismaModel> | $Enums.UserStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserStatusFilter<$PrismaModel>
    _max?: NestedEnumUserStatusFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NightclubRelationFilter = {
    is?: NightclubWhereInput
    isNot?: NightclubWhereInput
  }

  export type FloorPlanCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    imageUrl?: SortOrder
    nightclubId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    metadata?: SortOrder
  }

  export type FloorPlanMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    imageUrl?: SortOrder
    nightclubId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FloorPlanMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    imageUrl?: SortOrder
    nightclubId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type FloorPlanRelationFilter = {
    is?: FloorPlanWhereInput
    isNot?: FloorPlanWhereInput
  }

  export type SensorListRelationFilter = {
    every?: SensorWhereInput
    some?: SensorWhereInput
    none?: SensorWhereInput
  }

  export type SensorOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ZoneCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    coordinates?: SortOrder
    capacity?: SortOrder
    floorPlanId?: SortOrder
    nightclubId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ZoneAvgOrderByAggregateInput = {
    capacity?: SortOrder
  }

  export type ZoneMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    capacity?: SortOrder
    floorPlanId?: SortOrder
    nightclubId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ZoneMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    capacity?: SortOrder
    floorPlanId?: SortOrder
    nightclubId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ZoneSumOrderByAggregateInput = {
    capacity?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type EnumBraceletStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BraceletStatus | EnumBraceletStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BraceletStatus[] | ListEnumBraceletStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BraceletStatus[] | ListEnumBraceletStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBraceletStatusFilter<$PrismaModel> | $Enums.BraceletStatus
  }

  export type BraceletCountOrderByAggregateInput = {
    id?: SortOrder
    deviceId?: SortOrder
    batteryLevel?: SortOrder
    status?: SortOrder
    lastSeen?: SortOrder
    nightclubId?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BraceletAvgOrderByAggregateInput = {
    batteryLevel?: SortOrder
  }

  export type BraceletMaxOrderByAggregateInput = {
    id?: SortOrder
    deviceId?: SortOrder
    batteryLevel?: SortOrder
    status?: SortOrder
    lastSeen?: SortOrder
    nightclubId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BraceletMinOrderByAggregateInput = {
    id?: SortOrder
    deviceId?: SortOrder
    batteryLevel?: SortOrder
    status?: SortOrder
    lastSeen?: SortOrder
    nightclubId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BraceletSumOrderByAggregateInput = {
    batteryLevel?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumBraceletStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BraceletStatus | EnumBraceletStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BraceletStatus[] | ListEnumBraceletStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BraceletStatus[] | ListEnumBraceletStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBraceletStatusWithAggregatesFilter<$PrismaModel> | $Enums.BraceletStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBraceletStatusFilter<$PrismaModel>
    _max?: NestedEnumBraceletStatusFilter<$PrismaModel>
  }

  export type EnumAlertTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AlertType | EnumAlertTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AlertType[] | ListEnumAlertTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AlertType[] | ListEnumAlertTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAlertTypeFilter<$PrismaModel> | $Enums.AlertType
  }

  export type EnumAlertStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AlertStatus | EnumAlertStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AlertStatus[] | ListEnumAlertStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AlertStatus[] | ListEnumAlertStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAlertStatusFilter<$PrismaModel> | $Enums.AlertStatus
  }

  export type BraceletRelationFilter = {
    is?: BraceletWhereInput
    isNot?: BraceletWhereInput
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type ZoneRelationFilter = {
    is?: ZoneWhereInput
    isNot?: ZoneWhereInput
  }

  export type AlertCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    braceletId?: SortOrder
    userId?: SortOrder
    zoneId?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    resolvedAt?: SortOrder
  }

  export type AlertMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    braceletId?: SortOrder
    userId?: SortOrder
    zoneId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    resolvedAt?: SortOrder
  }

  export type AlertMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    braceletId?: SortOrder
    userId?: SortOrder
    zoneId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    resolvedAt?: SortOrder
  }

  export type EnumAlertTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AlertType | EnumAlertTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AlertType[] | ListEnumAlertTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AlertType[] | ListEnumAlertTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAlertTypeWithAggregatesFilter<$PrismaModel> | $Enums.AlertType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAlertTypeFilter<$PrismaModel>
    _max?: NestedEnumAlertTypeFilter<$PrismaModel>
  }

  export type EnumAlertStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AlertStatus | EnumAlertStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AlertStatus[] | ListEnumAlertStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AlertStatus[] | ListEnumAlertStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAlertStatusWithAggregatesFilter<$PrismaModel> | $Enums.AlertStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAlertStatusFilter<$PrismaModel>
    _max?: NestedEnumAlertStatusFilter<$PrismaModel>
  }

  export type EnumEmergencyStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EmergencyStatus | EnumEmergencyStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EmergencyStatus[] | ListEnumEmergencyStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmergencyStatus[] | ListEnumEmergencyStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEmergencyStatusFilter<$PrismaModel> | $Enums.EmergencyStatus
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type EmergencyCountOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    braceletId?: SortOrder
    zoneId?: SortOrder
    nightclubId?: SortOrder
    responderId?: SortOrder
    responseTime?: SortOrder
    escalationDetails?: SortOrder
    resolutionDetails?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    resolvedAt?: SortOrder
  }

  export type EmergencyAvgOrderByAggregateInput = {
    responseTime?: SortOrder
  }

  export type EmergencyMaxOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    braceletId?: SortOrder
    zoneId?: SortOrder
    nightclubId?: SortOrder
    responderId?: SortOrder
    responseTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    resolvedAt?: SortOrder
  }

  export type EmergencyMinOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
    braceletId?: SortOrder
    zoneId?: SortOrder
    nightclubId?: SortOrder
    responderId?: SortOrder
    responseTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    resolvedAt?: SortOrder
  }

  export type EmergencySumOrderByAggregateInput = {
    responseTime?: SortOrder
  }

  export type EnumEmergencyStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EmergencyStatus | EnumEmergencyStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EmergencyStatus[] | ListEnumEmergencyStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmergencyStatus[] | ListEnumEmergencyStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEmergencyStatusWithAggregatesFilter<$PrismaModel> | $Enums.EmergencyStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEmergencyStatusFilter<$PrismaModel>
    _max?: NestedEnumEmergencyStatusFilter<$PrismaModel>
  }

  export type EnumSensorTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SensorType | EnumSensorTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SensorType[] | ListEnumSensorTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SensorType[] | ListEnumSensorTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSensorTypeFilter<$PrismaModel> | $Enums.SensorType
  }

  export type EnumSensorStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SensorStatus | EnumSensorStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SensorStatus[] | ListEnumSensorStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SensorStatus[] | ListEnumSensorStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSensorStatusFilter<$PrismaModel> | $Enums.SensorStatus
  }

  export type SensorCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    zoneId?: SortOrder
    data?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastReading?: SortOrder
  }

  export type SensorMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    zoneId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastReading?: SortOrder
  }

  export type SensorMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    zoneId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastReading?: SortOrder
  }

  export type EnumSensorTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SensorType | EnumSensorTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SensorType[] | ListEnumSensorTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SensorType[] | ListEnumSensorTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSensorTypeWithAggregatesFilter<$PrismaModel> | $Enums.SensorType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSensorTypeFilter<$PrismaModel>
    _max?: NestedEnumSensorTypeFilter<$PrismaModel>
  }

  export type EnumSensorStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SensorStatus | EnumSensorStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SensorStatus[] | ListEnumSensorStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SensorStatus[] | ListEnumSensorStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSensorStatusWithAggregatesFilter<$PrismaModel> | $Enums.SensorStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSensorStatusFilter<$PrismaModel>
    _max?: NestedEnumSensorStatusFilter<$PrismaModel>
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    userId?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type AnalyticsReportCountOrderByAggregateInput = {
    id?: SortOrder
    nightclubId?: SortOrder
    type?: SortOrder
    report?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AnalyticsReportMaxOrderByAggregateInput = {
    id?: SortOrder
    nightclubId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AnalyticsReportMinOrderByAggregateInput = {
    id?: SortOrder
    nightclubId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AIModelCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    version?: SortOrder
    status?: SortOrder
    config?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AIModelMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    version?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AIModelMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    version?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type ZoneNullableRelationFilter = {
    is?: ZoneWhereInput | null
    isNot?: ZoneWhereInput | null
  }

  export type AIModelRelationFilter = {
    is?: AIModelWhereInput
    isNot?: AIModelWhereInput
  }

  export type PredictionCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    timestamp?: SortOrder
    value?: SortOrder
    confidence?: SortOrder
    metadata?: SortOrder
    nightclubId?: SortOrder
    zoneId?: SortOrder
    modelId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PredictionAvgOrderByAggregateInput = {
    value?: SortOrder
    confidence?: SortOrder
  }

  export type PredictionMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    timestamp?: SortOrder
    value?: SortOrder
    confidence?: SortOrder
    nightclubId?: SortOrder
    zoneId?: SortOrder
    modelId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PredictionMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    timestamp?: SortOrder
    value?: SortOrder
    confidence?: SortOrder
    nightclubId?: SortOrder
    zoneId?: SortOrder
    modelId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PredictionSumOrderByAggregateInput = {
    value?: SortOrder
    confidence?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type AnomalyCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    severity?: SortOrder
    status?: SortOrder
    description?: SortOrder
    timestamp?: SortOrder
    metadata?: SortOrder
    nightclubId?: SortOrder
    zoneId?: SortOrder
    modelId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AnomalyMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    severity?: SortOrder
    status?: SortOrder
    description?: SortOrder
    timestamp?: SortOrder
    nightclubId?: SortOrder
    zoneId?: SortOrder
    modelId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AnomalyMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    severity?: SortOrder
    status?: SortOrder
    description?: SortOrder
    timestamp?: SortOrder
    nightclubId?: SortOrder
    zoneId?: SortOrder
    modelId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BehaviorAnalysisCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    timestamp?: SortOrder
    insights?: SortOrder
    metadata?: SortOrder
    nightclubId?: SortOrder
    zoneId?: SortOrder
    modelId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BehaviorAnalysisMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    timestamp?: SortOrder
    nightclubId?: SortOrder
    zoneId?: SortOrder
    modelId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BehaviorAnalysisMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    timestamp?: SortOrder
    nightclubId?: SortOrder
    zoneId?: SortOrder
    modelId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RealTimeMetricCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    value?: SortOrder
    timestamp?: SortOrder
    metadata?: SortOrder
    nightclubId?: SortOrder
    zoneId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RealTimeMetricAvgOrderByAggregateInput = {
    value?: SortOrder
  }

  export type RealTimeMetricMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    value?: SortOrder
    timestamp?: SortOrder
    nightclubId?: SortOrder
    zoneId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RealTimeMetricMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    value?: SortOrder
    timestamp?: SortOrder
    nightclubId?: SortOrder
    zoneId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RealTimeMetricSumOrderByAggregateInput = {
    value?: SortOrder
  }

  export type DataStreamCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    lastUpdate?: SortOrder
    metadata?: SortOrder
    nightclubId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DataStreamMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    lastUpdate?: SortOrder
    nightclubId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DataStreamMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    lastUpdate?: SortOrder
    nightclubId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CacheEntryCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nightclubId?: SortOrder
  }

  export type CacheEntryMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nightclubId?: SortOrder
  }

  export type CacheEntryMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    nightclubId?: SortOrder
  }

  export type FloorPlanCreateNestedManyWithoutNightclubInput = {
    create?: XOR<FloorPlanCreateWithoutNightclubInput, FloorPlanUncheckedCreateWithoutNightclubInput> | FloorPlanCreateWithoutNightclubInput[] | FloorPlanUncheckedCreateWithoutNightclubInput[]
    connectOrCreate?: FloorPlanCreateOrConnectWithoutNightclubInput | FloorPlanCreateOrConnectWithoutNightclubInput[]
    createMany?: FloorPlanCreateManyNightclubInputEnvelope
    connect?: FloorPlanWhereUniqueInput | FloorPlanWhereUniqueInput[]
  }

  export type UserCreateNestedManyWithoutNightclubInput = {
    create?: XOR<UserCreateWithoutNightclubInput, UserUncheckedCreateWithoutNightclubInput> | UserCreateWithoutNightclubInput[] | UserUncheckedCreateWithoutNightclubInput[]
    connectOrCreate?: UserCreateOrConnectWithoutNightclubInput | UserCreateOrConnectWithoutNightclubInput[]
    createMany?: UserCreateManyNightclubInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type BraceletCreateNestedManyWithoutNightclubInput = {
    create?: XOR<BraceletCreateWithoutNightclubInput, BraceletUncheckedCreateWithoutNightclubInput> | BraceletCreateWithoutNightclubInput[] | BraceletUncheckedCreateWithoutNightclubInput[]
    connectOrCreate?: BraceletCreateOrConnectWithoutNightclubInput | BraceletCreateOrConnectWithoutNightclubInput[]
    createMany?: BraceletCreateManyNightclubInputEnvelope
    connect?: BraceletWhereUniqueInput | BraceletWhereUniqueInput[]
  }

  export type ZoneCreateNestedManyWithoutNightclubInput = {
    create?: XOR<ZoneCreateWithoutNightclubInput, ZoneUncheckedCreateWithoutNightclubInput> | ZoneCreateWithoutNightclubInput[] | ZoneUncheckedCreateWithoutNightclubInput[]
    connectOrCreate?: ZoneCreateOrConnectWithoutNightclubInput | ZoneCreateOrConnectWithoutNightclubInput[]
    createMany?: ZoneCreateManyNightclubInputEnvelope
    connect?: ZoneWhereUniqueInput | ZoneWhereUniqueInput[]
  }

  export type EmergencyCreateNestedManyWithoutNightclubInput = {
    create?: XOR<EmergencyCreateWithoutNightclubInput, EmergencyUncheckedCreateWithoutNightclubInput> | EmergencyCreateWithoutNightclubInput[] | EmergencyUncheckedCreateWithoutNightclubInput[]
    connectOrCreate?: EmergencyCreateOrConnectWithoutNightclubInput | EmergencyCreateOrConnectWithoutNightclubInput[]
    createMany?: EmergencyCreateManyNightclubInputEnvelope
    connect?: EmergencyWhereUniqueInput | EmergencyWhereUniqueInput[]
  }

  export type AnalyticsReportCreateNestedManyWithoutNightclubInput = {
    create?: XOR<AnalyticsReportCreateWithoutNightclubInput, AnalyticsReportUncheckedCreateWithoutNightclubInput> | AnalyticsReportCreateWithoutNightclubInput[] | AnalyticsReportUncheckedCreateWithoutNightclubInput[]
    connectOrCreate?: AnalyticsReportCreateOrConnectWithoutNightclubInput | AnalyticsReportCreateOrConnectWithoutNightclubInput[]
    createMany?: AnalyticsReportCreateManyNightclubInputEnvelope
    connect?: AnalyticsReportWhereUniqueInput | AnalyticsReportWhereUniqueInput[]
  }

  export type PredictionCreateNestedManyWithoutNightclubInput = {
    create?: XOR<PredictionCreateWithoutNightclubInput, PredictionUncheckedCreateWithoutNightclubInput> | PredictionCreateWithoutNightclubInput[] | PredictionUncheckedCreateWithoutNightclubInput[]
    connectOrCreate?: PredictionCreateOrConnectWithoutNightclubInput | PredictionCreateOrConnectWithoutNightclubInput[]
    createMany?: PredictionCreateManyNightclubInputEnvelope
    connect?: PredictionWhereUniqueInput | PredictionWhereUniqueInput[]
  }

  export type AnomalyCreateNestedManyWithoutNightclubInput = {
    create?: XOR<AnomalyCreateWithoutNightclubInput, AnomalyUncheckedCreateWithoutNightclubInput> | AnomalyCreateWithoutNightclubInput[] | AnomalyUncheckedCreateWithoutNightclubInput[]
    connectOrCreate?: AnomalyCreateOrConnectWithoutNightclubInput | AnomalyCreateOrConnectWithoutNightclubInput[]
    createMany?: AnomalyCreateManyNightclubInputEnvelope
    connect?: AnomalyWhereUniqueInput | AnomalyWhereUniqueInput[]
  }

  export type BehaviorAnalysisCreateNestedManyWithoutNightclubInput = {
    create?: XOR<BehaviorAnalysisCreateWithoutNightclubInput, BehaviorAnalysisUncheckedCreateWithoutNightclubInput> | BehaviorAnalysisCreateWithoutNightclubInput[] | BehaviorAnalysisUncheckedCreateWithoutNightclubInput[]
    connectOrCreate?: BehaviorAnalysisCreateOrConnectWithoutNightclubInput | BehaviorAnalysisCreateOrConnectWithoutNightclubInput[]
    createMany?: BehaviorAnalysisCreateManyNightclubInputEnvelope
    connect?: BehaviorAnalysisWhereUniqueInput | BehaviorAnalysisWhereUniqueInput[]
  }

  export type RealTimeMetricCreateNestedManyWithoutNightclubInput = {
    create?: XOR<RealTimeMetricCreateWithoutNightclubInput, RealTimeMetricUncheckedCreateWithoutNightclubInput> | RealTimeMetricCreateWithoutNightclubInput[] | RealTimeMetricUncheckedCreateWithoutNightclubInput[]
    connectOrCreate?: RealTimeMetricCreateOrConnectWithoutNightclubInput | RealTimeMetricCreateOrConnectWithoutNightclubInput[]
    createMany?: RealTimeMetricCreateManyNightclubInputEnvelope
    connect?: RealTimeMetricWhereUniqueInput | RealTimeMetricWhereUniqueInput[]
  }

  export type DataStreamCreateNestedManyWithoutNightclubInput = {
    create?: XOR<DataStreamCreateWithoutNightclubInput, DataStreamUncheckedCreateWithoutNightclubInput> | DataStreamCreateWithoutNightclubInput[] | DataStreamUncheckedCreateWithoutNightclubInput[]
    connectOrCreate?: DataStreamCreateOrConnectWithoutNightclubInput | DataStreamCreateOrConnectWithoutNightclubInput[]
    createMany?: DataStreamCreateManyNightclubInputEnvelope
    connect?: DataStreamWhereUniqueInput | DataStreamWhereUniqueInput[]
  }

  export type CacheEntryCreateNestedManyWithoutNightclubInput = {
    create?: XOR<CacheEntryCreateWithoutNightclubInput, CacheEntryUncheckedCreateWithoutNightclubInput> | CacheEntryCreateWithoutNightclubInput[] | CacheEntryUncheckedCreateWithoutNightclubInput[]
    connectOrCreate?: CacheEntryCreateOrConnectWithoutNightclubInput | CacheEntryCreateOrConnectWithoutNightclubInput[]
    createMany?: CacheEntryCreateManyNightclubInputEnvelope
    connect?: CacheEntryWhereUniqueInput | CacheEntryWhereUniqueInput[]
  }

  export type FloorPlanUncheckedCreateNestedManyWithoutNightclubInput = {
    create?: XOR<FloorPlanCreateWithoutNightclubInput, FloorPlanUncheckedCreateWithoutNightclubInput> | FloorPlanCreateWithoutNightclubInput[] | FloorPlanUncheckedCreateWithoutNightclubInput[]
    connectOrCreate?: FloorPlanCreateOrConnectWithoutNightclubInput | FloorPlanCreateOrConnectWithoutNightclubInput[]
    createMany?: FloorPlanCreateManyNightclubInputEnvelope
    connect?: FloorPlanWhereUniqueInput | FloorPlanWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutNightclubInput = {
    create?: XOR<UserCreateWithoutNightclubInput, UserUncheckedCreateWithoutNightclubInput> | UserCreateWithoutNightclubInput[] | UserUncheckedCreateWithoutNightclubInput[]
    connectOrCreate?: UserCreateOrConnectWithoutNightclubInput | UserCreateOrConnectWithoutNightclubInput[]
    createMany?: UserCreateManyNightclubInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type BraceletUncheckedCreateNestedManyWithoutNightclubInput = {
    create?: XOR<BraceletCreateWithoutNightclubInput, BraceletUncheckedCreateWithoutNightclubInput> | BraceletCreateWithoutNightclubInput[] | BraceletUncheckedCreateWithoutNightclubInput[]
    connectOrCreate?: BraceletCreateOrConnectWithoutNightclubInput | BraceletCreateOrConnectWithoutNightclubInput[]
    createMany?: BraceletCreateManyNightclubInputEnvelope
    connect?: BraceletWhereUniqueInput | BraceletWhereUniqueInput[]
  }

  export type ZoneUncheckedCreateNestedManyWithoutNightclubInput = {
    create?: XOR<ZoneCreateWithoutNightclubInput, ZoneUncheckedCreateWithoutNightclubInput> | ZoneCreateWithoutNightclubInput[] | ZoneUncheckedCreateWithoutNightclubInput[]
    connectOrCreate?: ZoneCreateOrConnectWithoutNightclubInput | ZoneCreateOrConnectWithoutNightclubInput[]
    createMany?: ZoneCreateManyNightclubInputEnvelope
    connect?: ZoneWhereUniqueInput | ZoneWhereUniqueInput[]
  }

  export type EmergencyUncheckedCreateNestedManyWithoutNightclubInput = {
    create?: XOR<EmergencyCreateWithoutNightclubInput, EmergencyUncheckedCreateWithoutNightclubInput> | EmergencyCreateWithoutNightclubInput[] | EmergencyUncheckedCreateWithoutNightclubInput[]
    connectOrCreate?: EmergencyCreateOrConnectWithoutNightclubInput | EmergencyCreateOrConnectWithoutNightclubInput[]
    createMany?: EmergencyCreateManyNightclubInputEnvelope
    connect?: EmergencyWhereUniqueInput | EmergencyWhereUniqueInput[]
  }

  export type AnalyticsReportUncheckedCreateNestedManyWithoutNightclubInput = {
    create?: XOR<AnalyticsReportCreateWithoutNightclubInput, AnalyticsReportUncheckedCreateWithoutNightclubInput> | AnalyticsReportCreateWithoutNightclubInput[] | AnalyticsReportUncheckedCreateWithoutNightclubInput[]
    connectOrCreate?: AnalyticsReportCreateOrConnectWithoutNightclubInput | AnalyticsReportCreateOrConnectWithoutNightclubInput[]
    createMany?: AnalyticsReportCreateManyNightclubInputEnvelope
    connect?: AnalyticsReportWhereUniqueInput | AnalyticsReportWhereUniqueInput[]
  }

  export type PredictionUncheckedCreateNestedManyWithoutNightclubInput = {
    create?: XOR<PredictionCreateWithoutNightclubInput, PredictionUncheckedCreateWithoutNightclubInput> | PredictionCreateWithoutNightclubInput[] | PredictionUncheckedCreateWithoutNightclubInput[]
    connectOrCreate?: PredictionCreateOrConnectWithoutNightclubInput | PredictionCreateOrConnectWithoutNightclubInput[]
    createMany?: PredictionCreateManyNightclubInputEnvelope
    connect?: PredictionWhereUniqueInput | PredictionWhereUniqueInput[]
  }

  export type AnomalyUncheckedCreateNestedManyWithoutNightclubInput = {
    create?: XOR<AnomalyCreateWithoutNightclubInput, AnomalyUncheckedCreateWithoutNightclubInput> | AnomalyCreateWithoutNightclubInput[] | AnomalyUncheckedCreateWithoutNightclubInput[]
    connectOrCreate?: AnomalyCreateOrConnectWithoutNightclubInput | AnomalyCreateOrConnectWithoutNightclubInput[]
    createMany?: AnomalyCreateManyNightclubInputEnvelope
    connect?: AnomalyWhereUniqueInput | AnomalyWhereUniqueInput[]
  }

  export type BehaviorAnalysisUncheckedCreateNestedManyWithoutNightclubInput = {
    create?: XOR<BehaviorAnalysisCreateWithoutNightclubInput, BehaviorAnalysisUncheckedCreateWithoutNightclubInput> | BehaviorAnalysisCreateWithoutNightclubInput[] | BehaviorAnalysisUncheckedCreateWithoutNightclubInput[]
    connectOrCreate?: BehaviorAnalysisCreateOrConnectWithoutNightclubInput | BehaviorAnalysisCreateOrConnectWithoutNightclubInput[]
    createMany?: BehaviorAnalysisCreateManyNightclubInputEnvelope
    connect?: BehaviorAnalysisWhereUniqueInput | BehaviorAnalysisWhereUniqueInput[]
  }

  export type RealTimeMetricUncheckedCreateNestedManyWithoutNightclubInput = {
    create?: XOR<RealTimeMetricCreateWithoutNightclubInput, RealTimeMetricUncheckedCreateWithoutNightclubInput> | RealTimeMetricCreateWithoutNightclubInput[] | RealTimeMetricUncheckedCreateWithoutNightclubInput[]
    connectOrCreate?: RealTimeMetricCreateOrConnectWithoutNightclubInput | RealTimeMetricCreateOrConnectWithoutNightclubInput[]
    createMany?: RealTimeMetricCreateManyNightclubInputEnvelope
    connect?: RealTimeMetricWhereUniqueInput | RealTimeMetricWhereUniqueInput[]
  }

  export type DataStreamUncheckedCreateNestedManyWithoutNightclubInput = {
    create?: XOR<DataStreamCreateWithoutNightclubInput, DataStreamUncheckedCreateWithoutNightclubInput> | DataStreamCreateWithoutNightclubInput[] | DataStreamUncheckedCreateWithoutNightclubInput[]
    connectOrCreate?: DataStreamCreateOrConnectWithoutNightclubInput | DataStreamCreateOrConnectWithoutNightclubInput[]
    createMany?: DataStreamCreateManyNightclubInputEnvelope
    connect?: DataStreamWhereUniqueInput | DataStreamWhereUniqueInput[]
  }

  export type CacheEntryUncheckedCreateNestedManyWithoutNightclubInput = {
    create?: XOR<CacheEntryCreateWithoutNightclubInput, CacheEntryUncheckedCreateWithoutNightclubInput> | CacheEntryCreateWithoutNightclubInput[] | CacheEntryUncheckedCreateWithoutNightclubInput[]
    connectOrCreate?: CacheEntryCreateOrConnectWithoutNightclubInput | CacheEntryCreateOrConnectWithoutNightclubInput[]
    createMany?: CacheEntryCreateManyNightclubInputEnvelope
    connect?: CacheEntryWhereUniqueInput | CacheEntryWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type FloorPlanUpdateManyWithoutNightclubNestedInput = {
    create?: XOR<FloorPlanCreateWithoutNightclubInput, FloorPlanUncheckedCreateWithoutNightclubInput> | FloorPlanCreateWithoutNightclubInput[] | FloorPlanUncheckedCreateWithoutNightclubInput[]
    connectOrCreate?: FloorPlanCreateOrConnectWithoutNightclubInput | FloorPlanCreateOrConnectWithoutNightclubInput[]
    upsert?: FloorPlanUpsertWithWhereUniqueWithoutNightclubInput | FloorPlanUpsertWithWhereUniqueWithoutNightclubInput[]
    createMany?: FloorPlanCreateManyNightclubInputEnvelope
    set?: FloorPlanWhereUniqueInput | FloorPlanWhereUniqueInput[]
    disconnect?: FloorPlanWhereUniqueInput | FloorPlanWhereUniqueInput[]
    delete?: FloorPlanWhereUniqueInput | FloorPlanWhereUniqueInput[]
    connect?: FloorPlanWhereUniqueInput | FloorPlanWhereUniqueInput[]
    update?: FloorPlanUpdateWithWhereUniqueWithoutNightclubInput | FloorPlanUpdateWithWhereUniqueWithoutNightclubInput[]
    updateMany?: FloorPlanUpdateManyWithWhereWithoutNightclubInput | FloorPlanUpdateManyWithWhereWithoutNightclubInput[]
    deleteMany?: FloorPlanScalarWhereInput | FloorPlanScalarWhereInput[]
  }

  export type UserUpdateManyWithoutNightclubNestedInput = {
    create?: XOR<UserCreateWithoutNightclubInput, UserUncheckedCreateWithoutNightclubInput> | UserCreateWithoutNightclubInput[] | UserUncheckedCreateWithoutNightclubInput[]
    connectOrCreate?: UserCreateOrConnectWithoutNightclubInput | UserCreateOrConnectWithoutNightclubInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutNightclubInput | UserUpsertWithWhereUniqueWithoutNightclubInput[]
    createMany?: UserCreateManyNightclubInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutNightclubInput | UserUpdateWithWhereUniqueWithoutNightclubInput[]
    updateMany?: UserUpdateManyWithWhereWithoutNightclubInput | UserUpdateManyWithWhereWithoutNightclubInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type BraceletUpdateManyWithoutNightclubNestedInput = {
    create?: XOR<BraceletCreateWithoutNightclubInput, BraceletUncheckedCreateWithoutNightclubInput> | BraceletCreateWithoutNightclubInput[] | BraceletUncheckedCreateWithoutNightclubInput[]
    connectOrCreate?: BraceletCreateOrConnectWithoutNightclubInput | BraceletCreateOrConnectWithoutNightclubInput[]
    upsert?: BraceletUpsertWithWhereUniqueWithoutNightclubInput | BraceletUpsertWithWhereUniqueWithoutNightclubInput[]
    createMany?: BraceletCreateManyNightclubInputEnvelope
    set?: BraceletWhereUniqueInput | BraceletWhereUniqueInput[]
    disconnect?: BraceletWhereUniqueInput | BraceletWhereUniqueInput[]
    delete?: BraceletWhereUniqueInput | BraceletWhereUniqueInput[]
    connect?: BraceletWhereUniqueInput | BraceletWhereUniqueInput[]
    update?: BraceletUpdateWithWhereUniqueWithoutNightclubInput | BraceletUpdateWithWhereUniqueWithoutNightclubInput[]
    updateMany?: BraceletUpdateManyWithWhereWithoutNightclubInput | BraceletUpdateManyWithWhereWithoutNightclubInput[]
    deleteMany?: BraceletScalarWhereInput | BraceletScalarWhereInput[]
  }

  export type ZoneUpdateManyWithoutNightclubNestedInput = {
    create?: XOR<ZoneCreateWithoutNightclubInput, ZoneUncheckedCreateWithoutNightclubInput> | ZoneCreateWithoutNightclubInput[] | ZoneUncheckedCreateWithoutNightclubInput[]
    connectOrCreate?: ZoneCreateOrConnectWithoutNightclubInput | ZoneCreateOrConnectWithoutNightclubInput[]
    upsert?: ZoneUpsertWithWhereUniqueWithoutNightclubInput | ZoneUpsertWithWhereUniqueWithoutNightclubInput[]
    createMany?: ZoneCreateManyNightclubInputEnvelope
    set?: ZoneWhereUniqueInput | ZoneWhereUniqueInput[]
    disconnect?: ZoneWhereUniqueInput | ZoneWhereUniqueInput[]
    delete?: ZoneWhereUniqueInput | ZoneWhereUniqueInput[]
    connect?: ZoneWhereUniqueInput | ZoneWhereUniqueInput[]
    update?: ZoneUpdateWithWhereUniqueWithoutNightclubInput | ZoneUpdateWithWhereUniqueWithoutNightclubInput[]
    updateMany?: ZoneUpdateManyWithWhereWithoutNightclubInput | ZoneUpdateManyWithWhereWithoutNightclubInput[]
    deleteMany?: ZoneScalarWhereInput | ZoneScalarWhereInput[]
  }

  export type EmergencyUpdateManyWithoutNightclubNestedInput = {
    create?: XOR<EmergencyCreateWithoutNightclubInput, EmergencyUncheckedCreateWithoutNightclubInput> | EmergencyCreateWithoutNightclubInput[] | EmergencyUncheckedCreateWithoutNightclubInput[]
    connectOrCreate?: EmergencyCreateOrConnectWithoutNightclubInput | EmergencyCreateOrConnectWithoutNightclubInput[]
    upsert?: EmergencyUpsertWithWhereUniqueWithoutNightclubInput | EmergencyUpsertWithWhereUniqueWithoutNightclubInput[]
    createMany?: EmergencyCreateManyNightclubInputEnvelope
    set?: EmergencyWhereUniqueInput | EmergencyWhereUniqueInput[]
    disconnect?: EmergencyWhereUniqueInput | EmergencyWhereUniqueInput[]
    delete?: EmergencyWhereUniqueInput | EmergencyWhereUniqueInput[]
    connect?: EmergencyWhereUniqueInput | EmergencyWhereUniqueInput[]
    update?: EmergencyUpdateWithWhereUniqueWithoutNightclubInput | EmergencyUpdateWithWhereUniqueWithoutNightclubInput[]
    updateMany?: EmergencyUpdateManyWithWhereWithoutNightclubInput | EmergencyUpdateManyWithWhereWithoutNightclubInput[]
    deleteMany?: EmergencyScalarWhereInput | EmergencyScalarWhereInput[]
  }

  export type AnalyticsReportUpdateManyWithoutNightclubNestedInput = {
    create?: XOR<AnalyticsReportCreateWithoutNightclubInput, AnalyticsReportUncheckedCreateWithoutNightclubInput> | AnalyticsReportCreateWithoutNightclubInput[] | AnalyticsReportUncheckedCreateWithoutNightclubInput[]
    connectOrCreate?: AnalyticsReportCreateOrConnectWithoutNightclubInput | AnalyticsReportCreateOrConnectWithoutNightclubInput[]
    upsert?: AnalyticsReportUpsertWithWhereUniqueWithoutNightclubInput | AnalyticsReportUpsertWithWhereUniqueWithoutNightclubInput[]
    createMany?: AnalyticsReportCreateManyNightclubInputEnvelope
    set?: AnalyticsReportWhereUniqueInput | AnalyticsReportWhereUniqueInput[]
    disconnect?: AnalyticsReportWhereUniqueInput | AnalyticsReportWhereUniqueInput[]
    delete?: AnalyticsReportWhereUniqueInput | AnalyticsReportWhereUniqueInput[]
    connect?: AnalyticsReportWhereUniqueInput | AnalyticsReportWhereUniqueInput[]
    update?: AnalyticsReportUpdateWithWhereUniqueWithoutNightclubInput | AnalyticsReportUpdateWithWhereUniqueWithoutNightclubInput[]
    updateMany?: AnalyticsReportUpdateManyWithWhereWithoutNightclubInput | AnalyticsReportUpdateManyWithWhereWithoutNightclubInput[]
    deleteMany?: AnalyticsReportScalarWhereInput | AnalyticsReportScalarWhereInput[]
  }

  export type PredictionUpdateManyWithoutNightclubNestedInput = {
    create?: XOR<PredictionCreateWithoutNightclubInput, PredictionUncheckedCreateWithoutNightclubInput> | PredictionCreateWithoutNightclubInput[] | PredictionUncheckedCreateWithoutNightclubInput[]
    connectOrCreate?: PredictionCreateOrConnectWithoutNightclubInput | PredictionCreateOrConnectWithoutNightclubInput[]
    upsert?: PredictionUpsertWithWhereUniqueWithoutNightclubInput | PredictionUpsertWithWhereUniqueWithoutNightclubInput[]
    createMany?: PredictionCreateManyNightclubInputEnvelope
    set?: PredictionWhereUniqueInput | PredictionWhereUniqueInput[]
    disconnect?: PredictionWhereUniqueInput | PredictionWhereUniqueInput[]
    delete?: PredictionWhereUniqueInput | PredictionWhereUniqueInput[]
    connect?: PredictionWhereUniqueInput | PredictionWhereUniqueInput[]
    update?: PredictionUpdateWithWhereUniqueWithoutNightclubInput | PredictionUpdateWithWhereUniqueWithoutNightclubInput[]
    updateMany?: PredictionUpdateManyWithWhereWithoutNightclubInput | PredictionUpdateManyWithWhereWithoutNightclubInput[]
    deleteMany?: PredictionScalarWhereInput | PredictionScalarWhereInput[]
  }

  export type AnomalyUpdateManyWithoutNightclubNestedInput = {
    create?: XOR<AnomalyCreateWithoutNightclubInput, AnomalyUncheckedCreateWithoutNightclubInput> | AnomalyCreateWithoutNightclubInput[] | AnomalyUncheckedCreateWithoutNightclubInput[]
    connectOrCreate?: AnomalyCreateOrConnectWithoutNightclubInput | AnomalyCreateOrConnectWithoutNightclubInput[]
    upsert?: AnomalyUpsertWithWhereUniqueWithoutNightclubInput | AnomalyUpsertWithWhereUniqueWithoutNightclubInput[]
    createMany?: AnomalyCreateManyNightclubInputEnvelope
    set?: AnomalyWhereUniqueInput | AnomalyWhereUniqueInput[]
    disconnect?: AnomalyWhereUniqueInput | AnomalyWhereUniqueInput[]
    delete?: AnomalyWhereUniqueInput | AnomalyWhereUniqueInput[]
    connect?: AnomalyWhereUniqueInput | AnomalyWhereUniqueInput[]
    update?: AnomalyUpdateWithWhereUniqueWithoutNightclubInput | AnomalyUpdateWithWhereUniqueWithoutNightclubInput[]
    updateMany?: AnomalyUpdateManyWithWhereWithoutNightclubInput | AnomalyUpdateManyWithWhereWithoutNightclubInput[]
    deleteMany?: AnomalyScalarWhereInput | AnomalyScalarWhereInput[]
  }

  export type BehaviorAnalysisUpdateManyWithoutNightclubNestedInput = {
    create?: XOR<BehaviorAnalysisCreateWithoutNightclubInput, BehaviorAnalysisUncheckedCreateWithoutNightclubInput> | BehaviorAnalysisCreateWithoutNightclubInput[] | BehaviorAnalysisUncheckedCreateWithoutNightclubInput[]
    connectOrCreate?: BehaviorAnalysisCreateOrConnectWithoutNightclubInput | BehaviorAnalysisCreateOrConnectWithoutNightclubInput[]
    upsert?: BehaviorAnalysisUpsertWithWhereUniqueWithoutNightclubInput | BehaviorAnalysisUpsertWithWhereUniqueWithoutNightclubInput[]
    createMany?: BehaviorAnalysisCreateManyNightclubInputEnvelope
    set?: BehaviorAnalysisWhereUniqueInput | BehaviorAnalysisWhereUniqueInput[]
    disconnect?: BehaviorAnalysisWhereUniqueInput | BehaviorAnalysisWhereUniqueInput[]
    delete?: BehaviorAnalysisWhereUniqueInput | BehaviorAnalysisWhereUniqueInput[]
    connect?: BehaviorAnalysisWhereUniqueInput | BehaviorAnalysisWhereUniqueInput[]
    update?: BehaviorAnalysisUpdateWithWhereUniqueWithoutNightclubInput | BehaviorAnalysisUpdateWithWhereUniqueWithoutNightclubInput[]
    updateMany?: BehaviorAnalysisUpdateManyWithWhereWithoutNightclubInput | BehaviorAnalysisUpdateManyWithWhereWithoutNightclubInput[]
    deleteMany?: BehaviorAnalysisScalarWhereInput | BehaviorAnalysisScalarWhereInput[]
  }

  export type RealTimeMetricUpdateManyWithoutNightclubNestedInput = {
    create?: XOR<RealTimeMetricCreateWithoutNightclubInput, RealTimeMetricUncheckedCreateWithoutNightclubInput> | RealTimeMetricCreateWithoutNightclubInput[] | RealTimeMetricUncheckedCreateWithoutNightclubInput[]
    connectOrCreate?: RealTimeMetricCreateOrConnectWithoutNightclubInput | RealTimeMetricCreateOrConnectWithoutNightclubInput[]
    upsert?: RealTimeMetricUpsertWithWhereUniqueWithoutNightclubInput | RealTimeMetricUpsertWithWhereUniqueWithoutNightclubInput[]
    createMany?: RealTimeMetricCreateManyNightclubInputEnvelope
    set?: RealTimeMetricWhereUniqueInput | RealTimeMetricWhereUniqueInput[]
    disconnect?: RealTimeMetricWhereUniqueInput | RealTimeMetricWhereUniqueInput[]
    delete?: RealTimeMetricWhereUniqueInput | RealTimeMetricWhereUniqueInput[]
    connect?: RealTimeMetricWhereUniqueInput | RealTimeMetricWhereUniqueInput[]
    update?: RealTimeMetricUpdateWithWhereUniqueWithoutNightclubInput | RealTimeMetricUpdateWithWhereUniqueWithoutNightclubInput[]
    updateMany?: RealTimeMetricUpdateManyWithWhereWithoutNightclubInput | RealTimeMetricUpdateManyWithWhereWithoutNightclubInput[]
    deleteMany?: RealTimeMetricScalarWhereInput | RealTimeMetricScalarWhereInput[]
  }

  export type DataStreamUpdateManyWithoutNightclubNestedInput = {
    create?: XOR<DataStreamCreateWithoutNightclubInput, DataStreamUncheckedCreateWithoutNightclubInput> | DataStreamCreateWithoutNightclubInput[] | DataStreamUncheckedCreateWithoutNightclubInput[]
    connectOrCreate?: DataStreamCreateOrConnectWithoutNightclubInput | DataStreamCreateOrConnectWithoutNightclubInput[]
    upsert?: DataStreamUpsertWithWhereUniqueWithoutNightclubInput | DataStreamUpsertWithWhereUniqueWithoutNightclubInput[]
    createMany?: DataStreamCreateManyNightclubInputEnvelope
    set?: DataStreamWhereUniqueInput | DataStreamWhereUniqueInput[]
    disconnect?: DataStreamWhereUniqueInput | DataStreamWhereUniqueInput[]
    delete?: DataStreamWhereUniqueInput | DataStreamWhereUniqueInput[]
    connect?: DataStreamWhereUniqueInput | DataStreamWhereUniqueInput[]
    update?: DataStreamUpdateWithWhereUniqueWithoutNightclubInput | DataStreamUpdateWithWhereUniqueWithoutNightclubInput[]
    updateMany?: DataStreamUpdateManyWithWhereWithoutNightclubInput | DataStreamUpdateManyWithWhereWithoutNightclubInput[]
    deleteMany?: DataStreamScalarWhereInput | DataStreamScalarWhereInput[]
  }

  export type CacheEntryUpdateManyWithoutNightclubNestedInput = {
    create?: XOR<CacheEntryCreateWithoutNightclubInput, CacheEntryUncheckedCreateWithoutNightclubInput> | CacheEntryCreateWithoutNightclubInput[] | CacheEntryUncheckedCreateWithoutNightclubInput[]
    connectOrCreate?: CacheEntryCreateOrConnectWithoutNightclubInput | CacheEntryCreateOrConnectWithoutNightclubInput[]
    upsert?: CacheEntryUpsertWithWhereUniqueWithoutNightclubInput | CacheEntryUpsertWithWhereUniqueWithoutNightclubInput[]
    createMany?: CacheEntryCreateManyNightclubInputEnvelope
    set?: CacheEntryWhereUniqueInput | CacheEntryWhereUniqueInput[]
    disconnect?: CacheEntryWhereUniqueInput | CacheEntryWhereUniqueInput[]
    delete?: CacheEntryWhereUniqueInput | CacheEntryWhereUniqueInput[]
    connect?: CacheEntryWhereUniqueInput | CacheEntryWhereUniqueInput[]
    update?: CacheEntryUpdateWithWhereUniqueWithoutNightclubInput | CacheEntryUpdateWithWhereUniqueWithoutNightclubInput[]
    updateMany?: CacheEntryUpdateManyWithWhereWithoutNightclubInput | CacheEntryUpdateManyWithWhereWithoutNightclubInput[]
    deleteMany?: CacheEntryScalarWhereInput | CacheEntryScalarWhereInput[]
  }

  export type FloorPlanUncheckedUpdateManyWithoutNightclubNestedInput = {
    create?: XOR<FloorPlanCreateWithoutNightclubInput, FloorPlanUncheckedCreateWithoutNightclubInput> | FloorPlanCreateWithoutNightclubInput[] | FloorPlanUncheckedCreateWithoutNightclubInput[]
    connectOrCreate?: FloorPlanCreateOrConnectWithoutNightclubInput | FloorPlanCreateOrConnectWithoutNightclubInput[]
    upsert?: FloorPlanUpsertWithWhereUniqueWithoutNightclubInput | FloorPlanUpsertWithWhereUniqueWithoutNightclubInput[]
    createMany?: FloorPlanCreateManyNightclubInputEnvelope
    set?: FloorPlanWhereUniqueInput | FloorPlanWhereUniqueInput[]
    disconnect?: FloorPlanWhereUniqueInput | FloorPlanWhereUniqueInput[]
    delete?: FloorPlanWhereUniqueInput | FloorPlanWhereUniqueInput[]
    connect?: FloorPlanWhereUniqueInput | FloorPlanWhereUniqueInput[]
    update?: FloorPlanUpdateWithWhereUniqueWithoutNightclubInput | FloorPlanUpdateWithWhereUniqueWithoutNightclubInput[]
    updateMany?: FloorPlanUpdateManyWithWhereWithoutNightclubInput | FloorPlanUpdateManyWithWhereWithoutNightclubInput[]
    deleteMany?: FloorPlanScalarWhereInput | FloorPlanScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutNightclubNestedInput = {
    create?: XOR<UserCreateWithoutNightclubInput, UserUncheckedCreateWithoutNightclubInput> | UserCreateWithoutNightclubInput[] | UserUncheckedCreateWithoutNightclubInput[]
    connectOrCreate?: UserCreateOrConnectWithoutNightclubInput | UserCreateOrConnectWithoutNightclubInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutNightclubInput | UserUpsertWithWhereUniqueWithoutNightclubInput[]
    createMany?: UserCreateManyNightclubInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutNightclubInput | UserUpdateWithWhereUniqueWithoutNightclubInput[]
    updateMany?: UserUpdateManyWithWhereWithoutNightclubInput | UserUpdateManyWithWhereWithoutNightclubInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type BraceletUncheckedUpdateManyWithoutNightclubNestedInput = {
    create?: XOR<BraceletCreateWithoutNightclubInput, BraceletUncheckedCreateWithoutNightclubInput> | BraceletCreateWithoutNightclubInput[] | BraceletUncheckedCreateWithoutNightclubInput[]
    connectOrCreate?: BraceletCreateOrConnectWithoutNightclubInput | BraceletCreateOrConnectWithoutNightclubInput[]
    upsert?: BraceletUpsertWithWhereUniqueWithoutNightclubInput | BraceletUpsertWithWhereUniqueWithoutNightclubInput[]
    createMany?: BraceletCreateManyNightclubInputEnvelope
    set?: BraceletWhereUniqueInput | BraceletWhereUniqueInput[]
    disconnect?: BraceletWhereUniqueInput | BraceletWhereUniqueInput[]
    delete?: BraceletWhereUniqueInput | BraceletWhereUniqueInput[]
    connect?: BraceletWhereUniqueInput | BraceletWhereUniqueInput[]
    update?: BraceletUpdateWithWhereUniqueWithoutNightclubInput | BraceletUpdateWithWhereUniqueWithoutNightclubInput[]
    updateMany?: BraceletUpdateManyWithWhereWithoutNightclubInput | BraceletUpdateManyWithWhereWithoutNightclubInput[]
    deleteMany?: BraceletScalarWhereInput | BraceletScalarWhereInput[]
  }

  export type ZoneUncheckedUpdateManyWithoutNightclubNestedInput = {
    create?: XOR<ZoneCreateWithoutNightclubInput, ZoneUncheckedCreateWithoutNightclubInput> | ZoneCreateWithoutNightclubInput[] | ZoneUncheckedCreateWithoutNightclubInput[]
    connectOrCreate?: ZoneCreateOrConnectWithoutNightclubInput | ZoneCreateOrConnectWithoutNightclubInput[]
    upsert?: ZoneUpsertWithWhereUniqueWithoutNightclubInput | ZoneUpsertWithWhereUniqueWithoutNightclubInput[]
    createMany?: ZoneCreateManyNightclubInputEnvelope
    set?: ZoneWhereUniqueInput | ZoneWhereUniqueInput[]
    disconnect?: ZoneWhereUniqueInput | ZoneWhereUniqueInput[]
    delete?: ZoneWhereUniqueInput | ZoneWhereUniqueInput[]
    connect?: ZoneWhereUniqueInput | ZoneWhereUniqueInput[]
    update?: ZoneUpdateWithWhereUniqueWithoutNightclubInput | ZoneUpdateWithWhereUniqueWithoutNightclubInput[]
    updateMany?: ZoneUpdateManyWithWhereWithoutNightclubInput | ZoneUpdateManyWithWhereWithoutNightclubInput[]
    deleteMany?: ZoneScalarWhereInput | ZoneScalarWhereInput[]
  }

  export type EmergencyUncheckedUpdateManyWithoutNightclubNestedInput = {
    create?: XOR<EmergencyCreateWithoutNightclubInput, EmergencyUncheckedCreateWithoutNightclubInput> | EmergencyCreateWithoutNightclubInput[] | EmergencyUncheckedCreateWithoutNightclubInput[]
    connectOrCreate?: EmergencyCreateOrConnectWithoutNightclubInput | EmergencyCreateOrConnectWithoutNightclubInput[]
    upsert?: EmergencyUpsertWithWhereUniqueWithoutNightclubInput | EmergencyUpsertWithWhereUniqueWithoutNightclubInput[]
    createMany?: EmergencyCreateManyNightclubInputEnvelope
    set?: EmergencyWhereUniqueInput | EmergencyWhereUniqueInput[]
    disconnect?: EmergencyWhereUniqueInput | EmergencyWhereUniqueInput[]
    delete?: EmergencyWhereUniqueInput | EmergencyWhereUniqueInput[]
    connect?: EmergencyWhereUniqueInput | EmergencyWhereUniqueInput[]
    update?: EmergencyUpdateWithWhereUniqueWithoutNightclubInput | EmergencyUpdateWithWhereUniqueWithoutNightclubInput[]
    updateMany?: EmergencyUpdateManyWithWhereWithoutNightclubInput | EmergencyUpdateManyWithWhereWithoutNightclubInput[]
    deleteMany?: EmergencyScalarWhereInput | EmergencyScalarWhereInput[]
  }

  export type AnalyticsReportUncheckedUpdateManyWithoutNightclubNestedInput = {
    create?: XOR<AnalyticsReportCreateWithoutNightclubInput, AnalyticsReportUncheckedCreateWithoutNightclubInput> | AnalyticsReportCreateWithoutNightclubInput[] | AnalyticsReportUncheckedCreateWithoutNightclubInput[]
    connectOrCreate?: AnalyticsReportCreateOrConnectWithoutNightclubInput | AnalyticsReportCreateOrConnectWithoutNightclubInput[]
    upsert?: AnalyticsReportUpsertWithWhereUniqueWithoutNightclubInput | AnalyticsReportUpsertWithWhereUniqueWithoutNightclubInput[]
    createMany?: AnalyticsReportCreateManyNightclubInputEnvelope
    set?: AnalyticsReportWhereUniqueInput | AnalyticsReportWhereUniqueInput[]
    disconnect?: AnalyticsReportWhereUniqueInput | AnalyticsReportWhereUniqueInput[]
    delete?: AnalyticsReportWhereUniqueInput | AnalyticsReportWhereUniqueInput[]
    connect?: AnalyticsReportWhereUniqueInput | AnalyticsReportWhereUniqueInput[]
    update?: AnalyticsReportUpdateWithWhereUniqueWithoutNightclubInput | AnalyticsReportUpdateWithWhereUniqueWithoutNightclubInput[]
    updateMany?: AnalyticsReportUpdateManyWithWhereWithoutNightclubInput | AnalyticsReportUpdateManyWithWhereWithoutNightclubInput[]
    deleteMany?: AnalyticsReportScalarWhereInput | AnalyticsReportScalarWhereInput[]
  }

  export type PredictionUncheckedUpdateManyWithoutNightclubNestedInput = {
    create?: XOR<PredictionCreateWithoutNightclubInput, PredictionUncheckedCreateWithoutNightclubInput> | PredictionCreateWithoutNightclubInput[] | PredictionUncheckedCreateWithoutNightclubInput[]
    connectOrCreate?: PredictionCreateOrConnectWithoutNightclubInput | PredictionCreateOrConnectWithoutNightclubInput[]
    upsert?: PredictionUpsertWithWhereUniqueWithoutNightclubInput | PredictionUpsertWithWhereUniqueWithoutNightclubInput[]
    createMany?: PredictionCreateManyNightclubInputEnvelope
    set?: PredictionWhereUniqueInput | PredictionWhereUniqueInput[]
    disconnect?: PredictionWhereUniqueInput | PredictionWhereUniqueInput[]
    delete?: PredictionWhereUniqueInput | PredictionWhereUniqueInput[]
    connect?: PredictionWhereUniqueInput | PredictionWhereUniqueInput[]
    update?: PredictionUpdateWithWhereUniqueWithoutNightclubInput | PredictionUpdateWithWhereUniqueWithoutNightclubInput[]
    updateMany?: PredictionUpdateManyWithWhereWithoutNightclubInput | PredictionUpdateManyWithWhereWithoutNightclubInput[]
    deleteMany?: PredictionScalarWhereInput | PredictionScalarWhereInput[]
  }

  export type AnomalyUncheckedUpdateManyWithoutNightclubNestedInput = {
    create?: XOR<AnomalyCreateWithoutNightclubInput, AnomalyUncheckedCreateWithoutNightclubInput> | AnomalyCreateWithoutNightclubInput[] | AnomalyUncheckedCreateWithoutNightclubInput[]
    connectOrCreate?: AnomalyCreateOrConnectWithoutNightclubInput | AnomalyCreateOrConnectWithoutNightclubInput[]
    upsert?: AnomalyUpsertWithWhereUniqueWithoutNightclubInput | AnomalyUpsertWithWhereUniqueWithoutNightclubInput[]
    createMany?: AnomalyCreateManyNightclubInputEnvelope
    set?: AnomalyWhereUniqueInput | AnomalyWhereUniqueInput[]
    disconnect?: AnomalyWhereUniqueInput | AnomalyWhereUniqueInput[]
    delete?: AnomalyWhereUniqueInput | AnomalyWhereUniqueInput[]
    connect?: AnomalyWhereUniqueInput | AnomalyWhereUniqueInput[]
    update?: AnomalyUpdateWithWhereUniqueWithoutNightclubInput | AnomalyUpdateWithWhereUniqueWithoutNightclubInput[]
    updateMany?: AnomalyUpdateManyWithWhereWithoutNightclubInput | AnomalyUpdateManyWithWhereWithoutNightclubInput[]
    deleteMany?: AnomalyScalarWhereInput | AnomalyScalarWhereInput[]
  }

  export type BehaviorAnalysisUncheckedUpdateManyWithoutNightclubNestedInput = {
    create?: XOR<BehaviorAnalysisCreateWithoutNightclubInput, BehaviorAnalysisUncheckedCreateWithoutNightclubInput> | BehaviorAnalysisCreateWithoutNightclubInput[] | BehaviorAnalysisUncheckedCreateWithoutNightclubInput[]
    connectOrCreate?: BehaviorAnalysisCreateOrConnectWithoutNightclubInput | BehaviorAnalysisCreateOrConnectWithoutNightclubInput[]
    upsert?: BehaviorAnalysisUpsertWithWhereUniqueWithoutNightclubInput | BehaviorAnalysisUpsertWithWhereUniqueWithoutNightclubInput[]
    createMany?: BehaviorAnalysisCreateManyNightclubInputEnvelope
    set?: BehaviorAnalysisWhereUniqueInput | BehaviorAnalysisWhereUniqueInput[]
    disconnect?: BehaviorAnalysisWhereUniqueInput | BehaviorAnalysisWhereUniqueInput[]
    delete?: BehaviorAnalysisWhereUniqueInput | BehaviorAnalysisWhereUniqueInput[]
    connect?: BehaviorAnalysisWhereUniqueInput | BehaviorAnalysisWhereUniqueInput[]
    update?: BehaviorAnalysisUpdateWithWhereUniqueWithoutNightclubInput | BehaviorAnalysisUpdateWithWhereUniqueWithoutNightclubInput[]
    updateMany?: BehaviorAnalysisUpdateManyWithWhereWithoutNightclubInput | BehaviorAnalysisUpdateManyWithWhereWithoutNightclubInput[]
    deleteMany?: BehaviorAnalysisScalarWhereInput | BehaviorAnalysisScalarWhereInput[]
  }

  export type RealTimeMetricUncheckedUpdateManyWithoutNightclubNestedInput = {
    create?: XOR<RealTimeMetricCreateWithoutNightclubInput, RealTimeMetricUncheckedCreateWithoutNightclubInput> | RealTimeMetricCreateWithoutNightclubInput[] | RealTimeMetricUncheckedCreateWithoutNightclubInput[]
    connectOrCreate?: RealTimeMetricCreateOrConnectWithoutNightclubInput | RealTimeMetricCreateOrConnectWithoutNightclubInput[]
    upsert?: RealTimeMetricUpsertWithWhereUniqueWithoutNightclubInput | RealTimeMetricUpsertWithWhereUniqueWithoutNightclubInput[]
    createMany?: RealTimeMetricCreateManyNightclubInputEnvelope
    set?: RealTimeMetricWhereUniqueInput | RealTimeMetricWhereUniqueInput[]
    disconnect?: RealTimeMetricWhereUniqueInput | RealTimeMetricWhereUniqueInput[]
    delete?: RealTimeMetricWhereUniqueInput | RealTimeMetricWhereUniqueInput[]
    connect?: RealTimeMetricWhereUniqueInput | RealTimeMetricWhereUniqueInput[]
    update?: RealTimeMetricUpdateWithWhereUniqueWithoutNightclubInput | RealTimeMetricUpdateWithWhereUniqueWithoutNightclubInput[]
    updateMany?: RealTimeMetricUpdateManyWithWhereWithoutNightclubInput | RealTimeMetricUpdateManyWithWhereWithoutNightclubInput[]
    deleteMany?: RealTimeMetricScalarWhereInput | RealTimeMetricScalarWhereInput[]
  }

  export type DataStreamUncheckedUpdateManyWithoutNightclubNestedInput = {
    create?: XOR<DataStreamCreateWithoutNightclubInput, DataStreamUncheckedCreateWithoutNightclubInput> | DataStreamCreateWithoutNightclubInput[] | DataStreamUncheckedCreateWithoutNightclubInput[]
    connectOrCreate?: DataStreamCreateOrConnectWithoutNightclubInput | DataStreamCreateOrConnectWithoutNightclubInput[]
    upsert?: DataStreamUpsertWithWhereUniqueWithoutNightclubInput | DataStreamUpsertWithWhereUniqueWithoutNightclubInput[]
    createMany?: DataStreamCreateManyNightclubInputEnvelope
    set?: DataStreamWhereUniqueInput | DataStreamWhereUniqueInput[]
    disconnect?: DataStreamWhereUniqueInput | DataStreamWhereUniqueInput[]
    delete?: DataStreamWhereUniqueInput | DataStreamWhereUniqueInput[]
    connect?: DataStreamWhereUniqueInput | DataStreamWhereUniqueInput[]
    update?: DataStreamUpdateWithWhereUniqueWithoutNightclubInput | DataStreamUpdateWithWhereUniqueWithoutNightclubInput[]
    updateMany?: DataStreamUpdateManyWithWhereWithoutNightclubInput | DataStreamUpdateManyWithWhereWithoutNightclubInput[]
    deleteMany?: DataStreamScalarWhereInput | DataStreamScalarWhereInput[]
  }

  export type CacheEntryUncheckedUpdateManyWithoutNightclubNestedInput = {
    create?: XOR<CacheEntryCreateWithoutNightclubInput, CacheEntryUncheckedCreateWithoutNightclubInput> | CacheEntryCreateWithoutNightclubInput[] | CacheEntryUncheckedCreateWithoutNightclubInput[]
    connectOrCreate?: CacheEntryCreateOrConnectWithoutNightclubInput | CacheEntryCreateOrConnectWithoutNightclubInput[]
    upsert?: CacheEntryUpsertWithWhereUniqueWithoutNightclubInput | CacheEntryUpsertWithWhereUniqueWithoutNightclubInput[]
    createMany?: CacheEntryCreateManyNightclubInputEnvelope
    set?: CacheEntryWhereUniqueInput | CacheEntryWhereUniqueInput[]
    disconnect?: CacheEntryWhereUniqueInput | CacheEntryWhereUniqueInput[]
    delete?: CacheEntryWhereUniqueInput | CacheEntryWhereUniqueInput[]
    connect?: CacheEntryWhereUniqueInput | CacheEntryWhereUniqueInput[]
    update?: CacheEntryUpdateWithWhereUniqueWithoutNightclubInput | CacheEntryUpdateWithWhereUniqueWithoutNightclubInput[]
    updateMany?: CacheEntryUpdateManyWithWhereWithoutNightclubInput | CacheEntryUpdateManyWithWhereWithoutNightclubInput[]
    deleteMany?: CacheEntryScalarWhereInput | CacheEntryScalarWhereInput[]
  }

  export type NightclubCreateNestedOneWithoutUsersInput = {
    create?: XOR<NightclubCreateWithoutUsersInput, NightclubUncheckedCreateWithoutUsersInput>
    connectOrCreate?: NightclubCreateOrConnectWithoutUsersInput
    connect?: NightclubWhereUniqueInput
  }

  export type AlertCreateNestedManyWithoutUserInput = {
    create?: XOR<AlertCreateWithoutUserInput, AlertUncheckedCreateWithoutUserInput> | AlertCreateWithoutUserInput[] | AlertUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AlertCreateOrConnectWithoutUserInput | AlertCreateOrConnectWithoutUserInput[]
    createMany?: AlertCreateManyUserInputEnvelope
    connect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
  }

  export type EmergencyCreateNestedManyWithoutResponderInput = {
    create?: XOR<EmergencyCreateWithoutResponderInput, EmergencyUncheckedCreateWithoutResponderInput> | EmergencyCreateWithoutResponderInput[] | EmergencyUncheckedCreateWithoutResponderInput[]
    connectOrCreate?: EmergencyCreateOrConnectWithoutResponderInput | EmergencyCreateOrConnectWithoutResponderInput[]
    createMany?: EmergencyCreateManyResponderInputEnvelope
    connect?: EmergencyWhereUniqueInput | EmergencyWhereUniqueInput[]
  }

  export type AlertUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AlertCreateWithoutUserInput, AlertUncheckedCreateWithoutUserInput> | AlertCreateWithoutUserInput[] | AlertUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AlertCreateOrConnectWithoutUserInput | AlertCreateOrConnectWithoutUserInput[]
    createMany?: AlertCreateManyUserInputEnvelope
    connect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
  }

  export type EmergencyUncheckedCreateNestedManyWithoutResponderInput = {
    create?: XOR<EmergencyCreateWithoutResponderInput, EmergencyUncheckedCreateWithoutResponderInput> | EmergencyCreateWithoutResponderInput[] | EmergencyUncheckedCreateWithoutResponderInput[]
    connectOrCreate?: EmergencyCreateOrConnectWithoutResponderInput | EmergencyCreateOrConnectWithoutResponderInput[]
    createMany?: EmergencyCreateManyResponderInputEnvelope
    connect?: EmergencyWhereUniqueInput | EmergencyWhereUniqueInput[]
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type EnumUserStatusFieldUpdateOperationsInput = {
    set?: $Enums.UserStatus
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NightclubUpdateOneWithoutUsersNestedInput = {
    create?: XOR<NightclubCreateWithoutUsersInput, NightclubUncheckedCreateWithoutUsersInput>
    connectOrCreate?: NightclubCreateOrConnectWithoutUsersInput
    upsert?: NightclubUpsertWithoutUsersInput
    disconnect?: NightclubWhereInput | boolean
    delete?: NightclubWhereInput | boolean
    connect?: NightclubWhereUniqueInput
    update?: XOR<XOR<NightclubUpdateToOneWithWhereWithoutUsersInput, NightclubUpdateWithoutUsersInput>, NightclubUncheckedUpdateWithoutUsersInput>
  }

  export type AlertUpdateManyWithoutUserNestedInput = {
    create?: XOR<AlertCreateWithoutUserInput, AlertUncheckedCreateWithoutUserInput> | AlertCreateWithoutUserInput[] | AlertUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AlertCreateOrConnectWithoutUserInput | AlertCreateOrConnectWithoutUserInput[]
    upsert?: AlertUpsertWithWhereUniqueWithoutUserInput | AlertUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AlertCreateManyUserInputEnvelope
    set?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    disconnect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    delete?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    connect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    update?: AlertUpdateWithWhereUniqueWithoutUserInput | AlertUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AlertUpdateManyWithWhereWithoutUserInput | AlertUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AlertScalarWhereInput | AlertScalarWhereInput[]
  }

  export type EmergencyUpdateManyWithoutResponderNestedInput = {
    create?: XOR<EmergencyCreateWithoutResponderInput, EmergencyUncheckedCreateWithoutResponderInput> | EmergencyCreateWithoutResponderInput[] | EmergencyUncheckedCreateWithoutResponderInput[]
    connectOrCreate?: EmergencyCreateOrConnectWithoutResponderInput | EmergencyCreateOrConnectWithoutResponderInput[]
    upsert?: EmergencyUpsertWithWhereUniqueWithoutResponderInput | EmergencyUpsertWithWhereUniqueWithoutResponderInput[]
    createMany?: EmergencyCreateManyResponderInputEnvelope
    set?: EmergencyWhereUniqueInput | EmergencyWhereUniqueInput[]
    disconnect?: EmergencyWhereUniqueInput | EmergencyWhereUniqueInput[]
    delete?: EmergencyWhereUniqueInput | EmergencyWhereUniqueInput[]
    connect?: EmergencyWhereUniqueInput | EmergencyWhereUniqueInput[]
    update?: EmergencyUpdateWithWhereUniqueWithoutResponderInput | EmergencyUpdateWithWhereUniqueWithoutResponderInput[]
    updateMany?: EmergencyUpdateManyWithWhereWithoutResponderInput | EmergencyUpdateManyWithWhereWithoutResponderInput[]
    deleteMany?: EmergencyScalarWhereInput | EmergencyScalarWhereInput[]
  }

  export type AlertUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AlertCreateWithoutUserInput, AlertUncheckedCreateWithoutUserInput> | AlertCreateWithoutUserInput[] | AlertUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AlertCreateOrConnectWithoutUserInput | AlertCreateOrConnectWithoutUserInput[]
    upsert?: AlertUpsertWithWhereUniqueWithoutUserInput | AlertUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AlertCreateManyUserInputEnvelope
    set?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    disconnect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    delete?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    connect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    update?: AlertUpdateWithWhereUniqueWithoutUserInput | AlertUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AlertUpdateManyWithWhereWithoutUserInput | AlertUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AlertScalarWhereInput | AlertScalarWhereInput[]
  }

  export type EmergencyUncheckedUpdateManyWithoutResponderNestedInput = {
    create?: XOR<EmergencyCreateWithoutResponderInput, EmergencyUncheckedCreateWithoutResponderInput> | EmergencyCreateWithoutResponderInput[] | EmergencyUncheckedCreateWithoutResponderInput[]
    connectOrCreate?: EmergencyCreateOrConnectWithoutResponderInput | EmergencyCreateOrConnectWithoutResponderInput[]
    upsert?: EmergencyUpsertWithWhereUniqueWithoutResponderInput | EmergencyUpsertWithWhereUniqueWithoutResponderInput[]
    createMany?: EmergencyCreateManyResponderInputEnvelope
    set?: EmergencyWhereUniqueInput | EmergencyWhereUniqueInput[]
    disconnect?: EmergencyWhereUniqueInput | EmergencyWhereUniqueInput[]
    delete?: EmergencyWhereUniqueInput | EmergencyWhereUniqueInput[]
    connect?: EmergencyWhereUniqueInput | EmergencyWhereUniqueInput[]
    update?: EmergencyUpdateWithWhereUniqueWithoutResponderInput | EmergencyUpdateWithWhereUniqueWithoutResponderInput[]
    updateMany?: EmergencyUpdateManyWithWhereWithoutResponderInput | EmergencyUpdateManyWithWhereWithoutResponderInput[]
    deleteMany?: EmergencyScalarWhereInput | EmergencyScalarWhereInput[]
  }

  export type NightclubCreateNestedOneWithoutFloorPlansInput = {
    create?: XOR<NightclubCreateWithoutFloorPlansInput, NightclubUncheckedCreateWithoutFloorPlansInput>
    connectOrCreate?: NightclubCreateOrConnectWithoutFloorPlansInput
    connect?: NightclubWhereUniqueInput
  }

  export type ZoneCreateNestedManyWithoutFloorPlanInput = {
    create?: XOR<ZoneCreateWithoutFloorPlanInput, ZoneUncheckedCreateWithoutFloorPlanInput> | ZoneCreateWithoutFloorPlanInput[] | ZoneUncheckedCreateWithoutFloorPlanInput[]
    connectOrCreate?: ZoneCreateOrConnectWithoutFloorPlanInput | ZoneCreateOrConnectWithoutFloorPlanInput[]
    createMany?: ZoneCreateManyFloorPlanInputEnvelope
    connect?: ZoneWhereUniqueInput | ZoneWhereUniqueInput[]
  }

  export type ZoneUncheckedCreateNestedManyWithoutFloorPlanInput = {
    create?: XOR<ZoneCreateWithoutFloorPlanInput, ZoneUncheckedCreateWithoutFloorPlanInput> | ZoneCreateWithoutFloorPlanInput[] | ZoneUncheckedCreateWithoutFloorPlanInput[]
    connectOrCreate?: ZoneCreateOrConnectWithoutFloorPlanInput | ZoneCreateOrConnectWithoutFloorPlanInput[]
    createMany?: ZoneCreateManyFloorPlanInputEnvelope
    connect?: ZoneWhereUniqueInput | ZoneWhereUniqueInput[]
  }

  export type NightclubUpdateOneRequiredWithoutFloorPlansNestedInput = {
    create?: XOR<NightclubCreateWithoutFloorPlansInput, NightclubUncheckedCreateWithoutFloorPlansInput>
    connectOrCreate?: NightclubCreateOrConnectWithoutFloorPlansInput
    upsert?: NightclubUpsertWithoutFloorPlansInput
    connect?: NightclubWhereUniqueInput
    update?: XOR<XOR<NightclubUpdateToOneWithWhereWithoutFloorPlansInput, NightclubUpdateWithoutFloorPlansInput>, NightclubUncheckedUpdateWithoutFloorPlansInput>
  }

  export type ZoneUpdateManyWithoutFloorPlanNestedInput = {
    create?: XOR<ZoneCreateWithoutFloorPlanInput, ZoneUncheckedCreateWithoutFloorPlanInput> | ZoneCreateWithoutFloorPlanInput[] | ZoneUncheckedCreateWithoutFloorPlanInput[]
    connectOrCreate?: ZoneCreateOrConnectWithoutFloorPlanInput | ZoneCreateOrConnectWithoutFloorPlanInput[]
    upsert?: ZoneUpsertWithWhereUniqueWithoutFloorPlanInput | ZoneUpsertWithWhereUniqueWithoutFloorPlanInput[]
    createMany?: ZoneCreateManyFloorPlanInputEnvelope
    set?: ZoneWhereUniqueInput | ZoneWhereUniqueInput[]
    disconnect?: ZoneWhereUniqueInput | ZoneWhereUniqueInput[]
    delete?: ZoneWhereUniqueInput | ZoneWhereUniqueInput[]
    connect?: ZoneWhereUniqueInput | ZoneWhereUniqueInput[]
    update?: ZoneUpdateWithWhereUniqueWithoutFloorPlanInput | ZoneUpdateWithWhereUniqueWithoutFloorPlanInput[]
    updateMany?: ZoneUpdateManyWithWhereWithoutFloorPlanInput | ZoneUpdateManyWithWhereWithoutFloorPlanInput[]
    deleteMany?: ZoneScalarWhereInput | ZoneScalarWhereInput[]
  }

  export type ZoneUncheckedUpdateManyWithoutFloorPlanNestedInput = {
    create?: XOR<ZoneCreateWithoutFloorPlanInput, ZoneUncheckedCreateWithoutFloorPlanInput> | ZoneCreateWithoutFloorPlanInput[] | ZoneUncheckedCreateWithoutFloorPlanInput[]
    connectOrCreate?: ZoneCreateOrConnectWithoutFloorPlanInput | ZoneCreateOrConnectWithoutFloorPlanInput[]
    upsert?: ZoneUpsertWithWhereUniqueWithoutFloorPlanInput | ZoneUpsertWithWhereUniqueWithoutFloorPlanInput[]
    createMany?: ZoneCreateManyFloorPlanInputEnvelope
    set?: ZoneWhereUniqueInput | ZoneWhereUniqueInput[]
    disconnect?: ZoneWhereUniqueInput | ZoneWhereUniqueInput[]
    delete?: ZoneWhereUniqueInput | ZoneWhereUniqueInput[]
    connect?: ZoneWhereUniqueInput | ZoneWhereUniqueInput[]
    update?: ZoneUpdateWithWhereUniqueWithoutFloorPlanInput | ZoneUpdateWithWhereUniqueWithoutFloorPlanInput[]
    updateMany?: ZoneUpdateManyWithWhereWithoutFloorPlanInput | ZoneUpdateManyWithWhereWithoutFloorPlanInput[]
    deleteMany?: ZoneScalarWhereInput | ZoneScalarWhereInput[]
  }

  export type FloorPlanCreateNestedOneWithoutZonesInput = {
    create?: XOR<FloorPlanCreateWithoutZonesInput, FloorPlanUncheckedCreateWithoutZonesInput>
    connectOrCreate?: FloorPlanCreateOrConnectWithoutZonesInput
    connect?: FloorPlanWhereUniqueInput
  }

  export type NightclubCreateNestedOneWithoutZonesInput = {
    create?: XOR<NightclubCreateWithoutZonesInput, NightclubUncheckedCreateWithoutZonesInput>
    connectOrCreate?: NightclubCreateOrConnectWithoutZonesInput
    connect?: NightclubWhereUniqueInput
  }

  export type AlertCreateNestedManyWithoutZoneInput = {
    create?: XOR<AlertCreateWithoutZoneInput, AlertUncheckedCreateWithoutZoneInput> | AlertCreateWithoutZoneInput[] | AlertUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: AlertCreateOrConnectWithoutZoneInput | AlertCreateOrConnectWithoutZoneInput[]
    createMany?: AlertCreateManyZoneInputEnvelope
    connect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
  }

  export type EmergencyCreateNestedManyWithoutZoneInput = {
    create?: XOR<EmergencyCreateWithoutZoneInput, EmergencyUncheckedCreateWithoutZoneInput> | EmergencyCreateWithoutZoneInput[] | EmergencyUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: EmergencyCreateOrConnectWithoutZoneInput | EmergencyCreateOrConnectWithoutZoneInput[]
    createMany?: EmergencyCreateManyZoneInputEnvelope
    connect?: EmergencyWhereUniqueInput | EmergencyWhereUniqueInput[]
  }

  export type SensorCreateNestedManyWithoutZoneInput = {
    create?: XOR<SensorCreateWithoutZoneInput, SensorUncheckedCreateWithoutZoneInput> | SensorCreateWithoutZoneInput[] | SensorUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: SensorCreateOrConnectWithoutZoneInput | SensorCreateOrConnectWithoutZoneInput[]
    createMany?: SensorCreateManyZoneInputEnvelope
    connect?: SensorWhereUniqueInput | SensorWhereUniqueInput[]
  }

  export type AnomalyCreateNestedManyWithoutZoneInput = {
    create?: XOR<AnomalyCreateWithoutZoneInput, AnomalyUncheckedCreateWithoutZoneInput> | AnomalyCreateWithoutZoneInput[] | AnomalyUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: AnomalyCreateOrConnectWithoutZoneInput | AnomalyCreateOrConnectWithoutZoneInput[]
    createMany?: AnomalyCreateManyZoneInputEnvelope
    connect?: AnomalyWhereUniqueInput | AnomalyWhereUniqueInput[]
  }

  export type BehaviorAnalysisCreateNestedManyWithoutZoneInput = {
    create?: XOR<BehaviorAnalysisCreateWithoutZoneInput, BehaviorAnalysisUncheckedCreateWithoutZoneInput> | BehaviorAnalysisCreateWithoutZoneInput[] | BehaviorAnalysisUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: BehaviorAnalysisCreateOrConnectWithoutZoneInput | BehaviorAnalysisCreateOrConnectWithoutZoneInput[]
    createMany?: BehaviorAnalysisCreateManyZoneInputEnvelope
    connect?: BehaviorAnalysisWhereUniqueInput | BehaviorAnalysisWhereUniqueInput[]
  }

  export type RealTimeMetricCreateNestedManyWithoutZoneInput = {
    create?: XOR<RealTimeMetricCreateWithoutZoneInput, RealTimeMetricUncheckedCreateWithoutZoneInput> | RealTimeMetricCreateWithoutZoneInput[] | RealTimeMetricUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: RealTimeMetricCreateOrConnectWithoutZoneInput | RealTimeMetricCreateOrConnectWithoutZoneInput[]
    createMany?: RealTimeMetricCreateManyZoneInputEnvelope
    connect?: RealTimeMetricWhereUniqueInput | RealTimeMetricWhereUniqueInput[]
  }

  export type PredictionCreateNestedManyWithoutZoneInput = {
    create?: XOR<PredictionCreateWithoutZoneInput, PredictionUncheckedCreateWithoutZoneInput> | PredictionCreateWithoutZoneInput[] | PredictionUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: PredictionCreateOrConnectWithoutZoneInput | PredictionCreateOrConnectWithoutZoneInput[]
    createMany?: PredictionCreateManyZoneInputEnvelope
    connect?: PredictionWhereUniqueInput | PredictionWhereUniqueInput[]
  }

  export type AlertUncheckedCreateNestedManyWithoutZoneInput = {
    create?: XOR<AlertCreateWithoutZoneInput, AlertUncheckedCreateWithoutZoneInput> | AlertCreateWithoutZoneInput[] | AlertUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: AlertCreateOrConnectWithoutZoneInput | AlertCreateOrConnectWithoutZoneInput[]
    createMany?: AlertCreateManyZoneInputEnvelope
    connect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
  }

  export type EmergencyUncheckedCreateNestedManyWithoutZoneInput = {
    create?: XOR<EmergencyCreateWithoutZoneInput, EmergencyUncheckedCreateWithoutZoneInput> | EmergencyCreateWithoutZoneInput[] | EmergencyUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: EmergencyCreateOrConnectWithoutZoneInput | EmergencyCreateOrConnectWithoutZoneInput[]
    createMany?: EmergencyCreateManyZoneInputEnvelope
    connect?: EmergencyWhereUniqueInput | EmergencyWhereUniqueInput[]
  }

  export type SensorUncheckedCreateNestedManyWithoutZoneInput = {
    create?: XOR<SensorCreateWithoutZoneInput, SensorUncheckedCreateWithoutZoneInput> | SensorCreateWithoutZoneInput[] | SensorUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: SensorCreateOrConnectWithoutZoneInput | SensorCreateOrConnectWithoutZoneInput[]
    createMany?: SensorCreateManyZoneInputEnvelope
    connect?: SensorWhereUniqueInput | SensorWhereUniqueInput[]
  }

  export type AnomalyUncheckedCreateNestedManyWithoutZoneInput = {
    create?: XOR<AnomalyCreateWithoutZoneInput, AnomalyUncheckedCreateWithoutZoneInput> | AnomalyCreateWithoutZoneInput[] | AnomalyUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: AnomalyCreateOrConnectWithoutZoneInput | AnomalyCreateOrConnectWithoutZoneInput[]
    createMany?: AnomalyCreateManyZoneInputEnvelope
    connect?: AnomalyWhereUniqueInput | AnomalyWhereUniqueInput[]
  }

  export type BehaviorAnalysisUncheckedCreateNestedManyWithoutZoneInput = {
    create?: XOR<BehaviorAnalysisCreateWithoutZoneInput, BehaviorAnalysisUncheckedCreateWithoutZoneInput> | BehaviorAnalysisCreateWithoutZoneInput[] | BehaviorAnalysisUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: BehaviorAnalysisCreateOrConnectWithoutZoneInput | BehaviorAnalysisCreateOrConnectWithoutZoneInput[]
    createMany?: BehaviorAnalysisCreateManyZoneInputEnvelope
    connect?: BehaviorAnalysisWhereUniqueInput | BehaviorAnalysisWhereUniqueInput[]
  }

  export type RealTimeMetricUncheckedCreateNestedManyWithoutZoneInput = {
    create?: XOR<RealTimeMetricCreateWithoutZoneInput, RealTimeMetricUncheckedCreateWithoutZoneInput> | RealTimeMetricCreateWithoutZoneInput[] | RealTimeMetricUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: RealTimeMetricCreateOrConnectWithoutZoneInput | RealTimeMetricCreateOrConnectWithoutZoneInput[]
    createMany?: RealTimeMetricCreateManyZoneInputEnvelope
    connect?: RealTimeMetricWhereUniqueInput | RealTimeMetricWhereUniqueInput[]
  }

  export type PredictionUncheckedCreateNestedManyWithoutZoneInput = {
    create?: XOR<PredictionCreateWithoutZoneInput, PredictionUncheckedCreateWithoutZoneInput> | PredictionCreateWithoutZoneInput[] | PredictionUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: PredictionCreateOrConnectWithoutZoneInput | PredictionCreateOrConnectWithoutZoneInput[]
    createMany?: PredictionCreateManyZoneInputEnvelope
    connect?: PredictionWhereUniqueInput | PredictionWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type FloorPlanUpdateOneRequiredWithoutZonesNestedInput = {
    create?: XOR<FloorPlanCreateWithoutZonesInput, FloorPlanUncheckedCreateWithoutZonesInput>
    connectOrCreate?: FloorPlanCreateOrConnectWithoutZonesInput
    upsert?: FloorPlanUpsertWithoutZonesInput
    connect?: FloorPlanWhereUniqueInput
    update?: XOR<XOR<FloorPlanUpdateToOneWithWhereWithoutZonesInput, FloorPlanUpdateWithoutZonesInput>, FloorPlanUncheckedUpdateWithoutZonesInput>
  }

  export type NightclubUpdateOneRequiredWithoutZonesNestedInput = {
    create?: XOR<NightclubCreateWithoutZonesInput, NightclubUncheckedCreateWithoutZonesInput>
    connectOrCreate?: NightclubCreateOrConnectWithoutZonesInput
    upsert?: NightclubUpsertWithoutZonesInput
    connect?: NightclubWhereUniqueInput
    update?: XOR<XOR<NightclubUpdateToOneWithWhereWithoutZonesInput, NightclubUpdateWithoutZonesInput>, NightclubUncheckedUpdateWithoutZonesInput>
  }

  export type AlertUpdateManyWithoutZoneNestedInput = {
    create?: XOR<AlertCreateWithoutZoneInput, AlertUncheckedCreateWithoutZoneInput> | AlertCreateWithoutZoneInput[] | AlertUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: AlertCreateOrConnectWithoutZoneInput | AlertCreateOrConnectWithoutZoneInput[]
    upsert?: AlertUpsertWithWhereUniqueWithoutZoneInput | AlertUpsertWithWhereUniqueWithoutZoneInput[]
    createMany?: AlertCreateManyZoneInputEnvelope
    set?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    disconnect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    delete?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    connect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    update?: AlertUpdateWithWhereUniqueWithoutZoneInput | AlertUpdateWithWhereUniqueWithoutZoneInput[]
    updateMany?: AlertUpdateManyWithWhereWithoutZoneInput | AlertUpdateManyWithWhereWithoutZoneInput[]
    deleteMany?: AlertScalarWhereInput | AlertScalarWhereInput[]
  }

  export type EmergencyUpdateManyWithoutZoneNestedInput = {
    create?: XOR<EmergencyCreateWithoutZoneInput, EmergencyUncheckedCreateWithoutZoneInput> | EmergencyCreateWithoutZoneInput[] | EmergencyUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: EmergencyCreateOrConnectWithoutZoneInput | EmergencyCreateOrConnectWithoutZoneInput[]
    upsert?: EmergencyUpsertWithWhereUniqueWithoutZoneInput | EmergencyUpsertWithWhereUniqueWithoutZoneInput[]
    createMany?: EmergencyCreateManyZoneInputEnvelope
    set?: EmergencyWhereUniqueInput | EmergencyWhereUniqueInput[]
    disconnect?: EmergencyWhereUniqueInput | EmergencyWhereUniqueInput[]
    delete?: EmergencyWhereUniqueInput | EmergencyWhereUniqueInput[]
    connect?: EmergencyWhereUniqueInput | EmergencyWhereUniqueInput[]
    update?: EmergencyUpdateWithWhereUniqueWithoutZoneInput | EmergencyUpdateWithWhereUniqueWithoutZoneInput[]
    updateMany?: EmergencyUpdateManyWithWhereWithoutZoneInput | EmergencyUpdateManyWithWhereWithoutZoneInput[]
    deleteMany?: EmergencyScalarWhereInput | EmergencyScalarWhereInput[]
  }

  export type SensorUpdateManyWithoutZoneNestedInput = {
    create?: XOR<SensorCreateWithoutZoneInput, SensorUncheckedCreateWithoutZoneInput> | SensorCreateWithoutZoneInput[] | SensorUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: SensorCreateOrConnectWithoutZoneInput | SensorCreateOrConnectWithoutZoneInput[]
    upsert?: SensorUpsertWithWhereUniqueWithoutZoneInput | SensorUpsertWithWhereUniqueWithoutZoneInput[]
    createMany?: SensorCreateManyZoneInputEnvelope
    set?: SensorWhereUniqueInput | SensorWhereUniqueInput[]
    disconnect?: SensorWhereUniqueInput | SensorWhereUniqueInput[]
    delete?: SensorWhereUniqueInput | SensorWhereUniqueInput[]
    connect?: SensorWhereUniqueInput | SensorWhereUniqueInput[]
    update?: SensorUpdateWithWhereUniqueWithoutZoneInput | SensorUpdateWithWhereUniqueWithoutZoneInput[]
    updateMany?: SensorUpdateManyWithWhereWithoutZoneInput | SensorUpdateManyWithWhereWithoutZoneInput[]
    deleteMany?: SensorScalarWhereInput | SensorScalarWhereInput[]
  }

  export type AnomalyUpdateManyWithoutZoneNestedInput = {
    create?: XOR<AnomalyCreateWithoutZoneInput, AnomalyUncheckedCreateWithoutZoneInput> | AnomalyCreateWithoutZoneInput[] | AnomalyUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: AnomalyCreateOrConnectWithoutZoneInput | AnomalyCreateOrConnectWithoutZoneInput[]
    upsert?: AnomalyUpsertWithWhereUniqueWithoutZoneInput | AnomalyUpsertWithWhereUniqueWithoutZoneInput[]
    createMany?: AnomalyCreateManyZoneInputEnvelope
    set?: AnomalyWhereUniqueInput | AnomalyWhereUniqueInput[]
    disconnect?: AnomalyWhereUniqueInput | AnomalyWhereUniqueInput[]
    delete?: AnomalyWhereUniqueInput | AnomalyWhereUniqueInput[]
    connect?: AnomalyWhereUniqueInput | AnomalyWhereUniqueInput[]
    update?: AnomalyUpdateWithWhereUniqueWithoutZoneInput | AnomalyUpdateWithWhereUniqueWithoutZoneInput[]
    updateMany?: AnomalyUpdateManyWithWhereWithoutZoneInput | AnomalyUpdateManyWithWhereWithoutZoneInput[]
    deleteMany?: AnomalyScalarWhereInput | AnomalyScalarWhereInput[]
  }

  export type BehaviorAnalysisUpdateManyWithoutZoneNestedInput = {
    create?: XOR<BehaviorAnalysisCreateWithoutZoneInput, BehaviorAnalysisUncheckedCreateWithoutZoneInput> | BehaviorAnalysisCreateWithoutZoneInput[] | BehaviorAnalysisUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: BehaviorAnalysisCreateOrConnectWithoutZoneInput | BehaviorAnalysisCreateOrConnectWithoutZoneInput[]
    upsert?: BehaviorAnalysisUpsertWithWhereUniqueWithoutZoneInput | BehaviorAnalysisUpsertWithWhereUniqueWithoutZoneInput[]
    createMany?: BehaviorAnalysisCreateManyZoneInputEnvelope
    set?: BehaviorAnalysisWhereUniqueInput | BehaviorAnalysisWhereUniqueInput[]
    disconnect?: BehaviorAnalysisWhereUniqueInput | BehaviorAnalysisWhereUniqueInput[]
    delete?: BehaviorAnalysisWhereUniqueInput | BehaviorAnalysisWhereUniqueInput[]
    connect?: BehaviorAnalysisWhereUniqueInput | BehaviorAnalysisWhereUniqueInput[]
    update?: BehaviorAnalysisUpdateWithWhereUniqueWithoutZoneInput | BehaviorAnalysisUpdateWithWhereUniqueWithoutZoneInput[]
    updateMany?: BehaviorAnalysisUpdateManyWithWhereWithoutZoneInput | BehaviorAnalysisUpdateManyWithWhereWithoutZoneInput[]
    deleteMany?: BehaviorAnalysisScalarWhereInput | BehaviorAnalysisScalarWhereInput[]
  }

  export type RealTimeMetricUpdateManyWithoutZoneNestedInput = {
    create?: XOR<RealTimeMetricCreateWithoutZoneInput, RealTimeMetricUncheckedCreateWithoutZoneInput> | RealTimeMetricCreateWithoutZoneInput[] | RealTimeMetricUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: RealTimeMetricCreateOrConnectWithoutZoneInput | RealTimeMetricCreateOrConnectWithoutZoneInput[]
    upsert?: RealTimeMetricUpsertWithWhereUniqueWithoutZoneInput | RealTimeMetricUpsertWithWhereUniqueWithoutZoneInput[]
    createMany?: RealTimeMetricCreateManyZoneInputEnvelope
    set?: RealTimeMetricWhereUniqueInput | RealTimeMetricWhereUniqueInput[]
    disconnect?: RealTimeMetricWhereUniqueInput | RealTimeMetricWhereUniqueInput[]
    delete?: RealTimeMetricWhereUniqueInput | RealTimeMetricWhereUniqueInput[]
    connect?: RealTimeMetricWhereUniqueInput | RealTimeMetricWhereUniqueInput[]
    update?: RealTimeMetricUpdateWithWhereUniqueWithoutZoneInput | RealTimeMetricUpdateWithWhereUniqueWithoutZoneInput[]
    updateMany?: RealTimeMetricUpdateManyWithWhereWithoutZoneInput | RealTimeMetricUpdateManyWithWhereWithoutZoneInput[]
    deleteMany?: RealTimeMetricScalarWhereInput | RealTimeMetricScalarWhereInput[]
  }

  export type PredictionUpdateManyWithoutZoneNestedInput = {
    create?: XOR<PredictionCreateWithoutZoneInput, PredictionUncheckedCreateWithoutZoneInput> | PredictionCreateWithoutZoneInput[] | PredictionUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: PredictionCreateOrConnectWithoutZoneInput | PredictionCreateOrConnectWithoutZoneInput[]
    upsert?: PredictionUpsertWithWhereUniqueWithoutZoneInput | PredictionUpsertWithWhereUniqueWithoutZoneInput[]
    createMany?: PredictionCreateManyZoneInputEnvelope
    set?: PredictionWhereUniqueInput | PredictionWhereUniqueInput[]
    disconnect?: PredictionWhereUniqueInput | PredictionWhereUniqueInput[]
    delete?: PredictionWhereUniqueInput | PredictionWhereUniqueInput[]
    connect?: PredictionWhereUniqueInput | PredictionWhereUniqueInput[]
    update?: PredictionUpdateWithWhereUniqueWithoutZoneInput | PredictionUpdateWithWhereUniqueWithoutZoneInput[]
    updateMany?: PredictionUpdateManyWithWhereWithoutZoneInput | PredictionUpdateManyWithWhereWithoutZoneInput[]
    deleteMany?: PredictionScalarWhereInput | PredictionScalarWhereInput[]
  }

  export type AlertUncheckedUpdateManyWithoutZoneNestedInput = {
    create?: XOR<AlertCreateWithoutZoneInput, AlertUncheckedCreateWithoutZoneInput> | AlertCreateWithoutZoneInput[] | AlertUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: AlertCreateOrConnectWithoutZoneInput | AlertCreateOrConnectWithoutZoneInput[]
    upsert?: AlertUpsertWithWhereUniqueWithoutZoneInput | AlertUpsertWithWhereUniqueWithoutZoneInput[]
    createMany?: AlertCreateManyZoneInputEnvelope
    set?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    disconnect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    delete?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    connect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    update?: AlertUpdateWithWhereUniqueWithoutZoneInput | AlertUpdateWithWhereUniqueWithoutZoneInput[]
    updateMany?: AlertUpdateManyWithWhereWithoutZoneInput | AlertUpdateManyWithWhereWithoutZoneInput[]
    deleteMany?: AlertScalarWhereInput | AlertScalarWhereInput[]
  }

  export type EmergencyUncheckedUpdateManyWithoutZoneNestedInput = {
    create?: XOR<EmergencyCreateWithoutZoneInput, EmergencyUncheckedCreateWithoutZoneInput> | EmergencyCreateWithoutZoneInput[] | EmergencyUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: EmergencyCreateOrConnectWithoutZoneInput | EmergencyCreateOrConnectWithoutZoneInput[]
    upsert?: EmergencyUpsertWithWhereUniqueWithoutZoneInput | EmergencyUpsertWithWhereUniqueWithoutZoneInput[]
    createMany?: EmergencyCreateManyZoneInputEnvelope
    set?: EmergencyWhereUniqueInput | EmergencyWhereUniqueInput[]
    disconnect?: EmergencyWhereUniqueInput | EmergencyWhereUniqueInput[]
    delete?: EmergencyWhereUniqueInput | EmergencyWhereUniqueInput[]
    connect?: EmergencyWhereUniqueInput | EmergencyWhereUniqueInput[]
    update?: EmergencyUpdateWithWhereUniqueWithoutZoneInput | EmergencyUpdateWithWhereUniqueWithoutZoneInput[]
    updateMany?: EmergencyUpdateManyWithWhereWithoutZoneInput | EmergencyUpdateManyWithWhereWithoutZoneInput[]
    deleteMany?: EmergencyScalarWhereInput | EmergencyScalarWhereInput[]
  }

  export type SensorUncheckedUpdateManyWithoutZoneNestedInput = {
    create?: XOR<SensorCreateWithoutZoneInput, SensorUncheckedCreateWithoutZoneInput> | SensorCreateWithoutZoneInput[] | SensorUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: SensorCreateOrConnectWithoutZoneInput | SensorCreateOrConnectWithoutZoneInput[]
    upsert?: SensorUpsertWithWhereUniqueWithoutZoneInput | SensorUpsertWithWhereUniqueWithoutZoneInput[]
    createMany?: SensorCreateManyZoneInputEnvelope
    set?: SensorWhereUniqueInput | SensorWhereUniqueInput[]
    disconnect?: SensorWhereUniqueInput | SensorWhereUniqueInput[]
    delete?: SensorWhereUniqueInput | SensorWhereUniqueInput[]
    connect?: SensorWhereUniqueInput | SensorWhereUniqueInput[]
    update?: SensorUpdateWithWhereUniqueWithoutZoneInput | SensorUpdateWithWhereUniqueWithoutZoneInput[]
    updateMany?: SensorUpdateManyWithWhereWithoutZoneInput | SensorUpdateManyWithWhereWithoutZoneInput[]
    deleteMany?: SensorScalarWhereInput | SensorScalarWhereInput[]
  }

  export type AnomalyUncheckedUpdateManyWithoutZoneNestedInput = {
    create?: XOR<AnomalyCreateWithoutZoneInput, AnomalyUncheckedCreateWithoutZoneInput> | AnomalyCreateWithoutZoneInput[] | AnomalyUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: AnomalyCreateOrConnectWithoutZoneInput | AnomalyCreateOrConnectWithoutZoneInput[]
    upsert?: AnomalyUpsertWithWhereUniqueWithoutZoneInput | AnomalyUpsertWithWhereUniqueWithoutZoneInput[]
    createMany?: AnomalyCreateManyZoneInputEnvelope
    set?: AnomalyWhereUniqueInput | AnomalyWhereUniqueInput[]
    disconnect?: AnomalyWhereUniqueInput | AnomalyWhereUniqueInput[]
    delete?: AnomalyWhereUniqueInput | AnomalyWhereUniqueInput[]
    connect?: AnomalyWhereUniqueInput | AnomalyWhereUniqueInput[]
    update?: AnomalyUpdateWithWhereUniqueWithoutZoneInput | AnomalyUpdateWithWhereUniqueWithoutZoneInput[]
    updateMany?: AnomalyUpdateManyWithWhereWithoutZoneInput | AnomalyUpdateManyWithWhereWithoutZoneInput[]
    deleteMany?: AnomalyScalarWhereInput | AnomalyScalarWhereInput[]
  }

  export type BehaviorAnalysisUncheckedUpdateManyWithoutZoneNestedInput = {
    create?: XOR<BehaviorAnalysisCreateWithoutZoneInput, BehaviorAnalysisUncheckedCreateWithoutZoneInput> | BehaviorAnalysisCreateWithoutZoneInput[] | BehaviorAnalysisUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: BehaviorAnalysisCreateOrConnectWithoutZoneInput | BehaviorAnalysisCreateOrConnectWithoutZoneInput[]
    upsert?: BehaviorAnalysisUpsertWithWhereUniqueWithoutZoneInput | BehaviorAnalysisUpsertWithWhereUniqueWithoutZoneInput[]
    createMany?: BehaviorAnalysisCreateManyZoneInputEnvelope
    set?: BehaviorAnalysisWhereUniqueInput | BehaviorAnalysisWhereUniqueInput[]
    disconnect?: BehaviorAnalysisWhereUniqueInput | BehaviorAnalysisWhereUniqueInput[]
    delete?: BehaviorAnalysisWhereUniqueInput | BehaviorAnalysisWhereUniqueInput[]
    connect?: BehaviorAnalysisWhereUniqueInput | BehaviorAnalysisWhereUniqueInput[]
    update?: BehaviorAnalysisUpdateWithWhereUniqueWithoutZoneInput | BehaviorAnalysisUpdateWithWhereUniqueWithoutZoneInput[]
    updateMany?: BehaviorAnalysisUpdateManyWithWhereWithoutZoneInput | BehaviorAnalysisUpdateManyWithWhereWithoutZoneInput[]
    deleteMany?: BehaviorAnalysisScalarWhereInput | BehaviorAnalysisScalarWhereInput[]
  }

  export type RealTimeMetricUncheckedUpdateManyWithoutZoneNestedInput = {
    create?: XOR<RealTimeMetricCreateWithoutZoneInput, RealTimeMetricUncheckedCreateWithoutZoneInput> | RealTimeMetricCreateWithoutZoneInput[] | RealTimeMetricUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: RealTimeMetricCreateOrConnectWithoutZoneInput | RealTimeMetricCreateOrConnectWithoutZoneInput[]
    upsert?: RealTimeMetricUpsertWithWhereUniqueWithoutZoneInput | RealTimeMetricUpsertWithWhereUniqueWithoutZoneInput[]
    createMany?: RealTimeMetricCreateManyZoneInputEnvelope
    set?: RealTimeMetricWhereUniqueInput | RealTimeMetricWhereUniqueInput[]
    disconnect?: RealTimeMetricWhereUniqueInput | RealTimeMetricWhereUniqueInput[]
    delete?: RealTimeMetricWhereUniqueInput | RealTimeMetricWhereUniqueInput[]
    connect?: RealTimeMetricWhereUniqueInput | RealTimeMetricWhereUniqueInput[]
    update?: RealTimeMetricUpdateWithWhereUniqueWithoutZoneInput | RealTimeMetricUpdateWithWhereUniqueWithoutZoneInput[]
    updateMany?: RealTimeMetricUpdateManyWithWhereWithoutZoneInput | RealTimeMetricUpdateManyWithWhereWithoutZoneInput[]
    deleteMany?: RealTimeMetricScalarWhereInput | RealTimeMetricScalarWhereInput[]
  }

  export type PredictionUncheckedUpdateManyWithoutZoneNestedInput = {
    create?: XOR<PredictionCreateWithoutZoneInput, PredictionUncheckedCreateWithoutZoneInput> | PredictionCreateWithoutZoneInput[] | PredictionUncheckedCreateWithoutZoneInput[]
    connectOrCreate?: PredictionCreateOrConnectWithoutZoneInput | PredictionCreateOrConnectWithoutZoneInput[]
    upsert?: PredictionUpsertWithWhereUniqueWithoutZoneInput | PredictionUpsertWithWhereUniqueWithoutZoneInput[]
    createMany?: PredictionCreateManyZoneInputEnvelope
    set?: PredictionWhereUniqueInput | PredictionWhereUniqueInput[]
    disconnect?: PredictionWhereUniqueInput | PredictionWhereUniqueInput[]
    delete?: PredictionWhereUniqueInput | PredictionWhereUniqueInput[]
    connect?: PredictionWhereUniqueInput | PredictionWhereUniqueInput[]
    update?: PredictionUpdateWithWhereUniqueWithoutZoneInput | PredictionUpdateWithWhereUniqueWithoutZoneInput[]
    updateMany?: PredictionUpdateManyWithWhereWithoutZoneInput | PredictionUpdateManyWithWhereWithoutZoneInput[]
    deleteMany?: PredictionScalarWhereInput | PredictionScalarWhereInput[]
  }

  export type NightclubCreateNestedOneWithoutBraceletsInput = {
    create?: XOR<NightclubCreateWithoutBraceletsInput, NightclubUncheckedCreateWithoutBraceletsInput>
    connectOrCreate?: NightclubCreateOrConnectWithoutBraceletsInput
    connect?: NightclubWhereUniqueInput
  }

  export type AlertCreateNestedManyWithoutBraceletInput = {
    create?: XOR<AlertCreateWithoutBraceletInput, AlertUncheckedCreateWithoutBraceletInput> | AlertCreateWithoutBraceletInput[] | AlertUncheckedCreateWithoutBraceletInput[]
    connectOrCreate?: AlertCreateOrConnectWithoutBraceletInput | AlertCreateOrConnectWithoutBraceletInput[]
    createMany?: AlertCreateManyBraceletInputEnvelope
    connect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
  }

  export type EmergencyCreateNestedManyWithoutBraceletInput = {
    create?: XOR<EmergencyCreateWithoutBraceletInput, EmergencyUncheckedCreateWithoutBraceletInput> | EmergencyCreateWithoutBraceletInput[] | EmergencyUncheckedCreateWithoutBraceletInput[]
    connectOrCreate?: EmergencyCreateOrConnectWithoutBraceletInput | EmergencyCreateOrConnectWithoutBraceletInput[]
    createMany?: EmergencyCreateManyBraceletInputEnvelope
    connect?: EmergencyWhereUniqueInput | EmergencyWhereUniqueInput[]
  }

  export type AlertUncheckedCreateNestedManyWithoutBraceletInput = {
    create?: XOR<AlertCreateWithoutBraceletInput, AlertUncheckedCreateWithoutBraceletInput> | AlertCreateWithoutBraceletInput[] | AlertUncheckedCreateWithoutBraceletInput[]
    connectOrCreate?: AlertCreateOrConnectWithoutBraceletInput | AlertCreateOrConnectWithoutBraceletInput[]
    createMany?: AlertCreateManyBraceletInputEnvelope
    connect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
  }

  export type EmergencyUncheckedCreateNestedManyWithoutBraceletInput = {
    create?: XOR<EmergencyCreateWithoutBraceletInput, EmergencyUncheckedCreateWithoutBraceletInput> | EmergencyCreateWithoutBraceletInput[] | EmergencyUncheckedCreateWithoutBraceletInput[]
    connectOrCreate?: EmergencyCreateOrConnectWithoutBraceletInput | EmergencyCreateOrConnectWithoutBraceletInput[]
    createMany?: EmergencyCreateManyBraceletInputEnvelope
    connect?: EmergencyWhereUniqueInput | EmergencyWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumBraceletStatusFieldUpdateOperationsInput = {
    set?: $Enums.BraceletStatus
  }

  export type NightclubUpdateOneRequiredWithoutBraceletsNestedInput = {
    create?: XOR<NightclubCreateWithoutBraceletsInput, NightclubUncheckedCreateWithoutBraceletsInput>
    connectOrCreate?: NightclubCreateOrConnectWithoutBraceletsInput
    upsert?: NightclubUpsertWithoutBraceletsInput
    connect?: NightclubWhereUniqueInput
    update?: XOR<XOR<NightclubUpdateToOneWithWhereWithoutBraceletsInput, NightclubUpdateWithoutBraceletsInput>, NightclubUncheckedUpdateWithoutBraceletsInput>
  }

  export type AlertUpdateManyWithoutBraceletNestedInput = {
    create?: XOR<AlertCreateWithoutBraceletInput, AlertUncheckedCreateWithoutBraceletInput> | AlertCreateWithoutBraceletInput[] | AlertUncheckedCreateWithoutBraceletInput[]
    connectOrCreate?: AlertCreateOrConnectWithoutBraceletInput | AlertCreateOrConnectWithoutBraceletInput[]
    upsert?: AlertUpsertWithWhereUniqueWithoutBraceletInput | AlertUpsertWithWhereUniqueWithoutBraceletInput[]
    createMany?: AlertCreateManyBraceletInputEnvelope
    set?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    disconnect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    delete?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    connect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    update?: AlertUpdateWithWhereUniqueWithoutBraceletInput | AlertUpdateWithWhereUniqueWithoutBraceletInput[]
    updateMany?: AlertUpdateManyWithWhereWithoutBraceletInput | AlertUpdateManyWithWhereWithoutBraceletInput[]
    deleteMany?: AlertScalarWhereInput | AlertScalarWhereInput[]
  }

  export type EmergencyUpdateManyWithoutBraceletNestedInput = {
    create?: XOR<EmergencyCreateWithoutBraceletInput, EmergencyUncheckedCreateWithoutBraceletInput> | EmergencyCreateWithoutBraceletInput[] | EmergencyUncheckedCreateWithoutBraceletInput[]
    connectOrCreate?: EmergencyCreateOrConnectWithoutBraceletInput | EmergencyCreateOrConnectWithoutBraceletInput[]
    upsert?: EmergencyUpsertWithWhereUniqueWithoutBraceletInput | EmergencyUpsertWithWhereUniqueWithoutBraceletInput[]
    createMany?: EmergencyCreateManyBraceletInputEnvelope
    set?: EmergencyWhereUniqueInput | EmergencyWhereUniqueInput[]
    disconnect?: EmergencyWhereUniqueInput | EmergencyWhereUniqueInput[]
    delete?: EmergencyWhereUniqueInput | EmergencyWhereUniqueInput[]
    connect?: EmergencyWhereUniqueInput | EmergencyWhereUniqueInput[]
    update?: EmergencyUpdateWithWhereUniqueWithoutBraceletInput | EmergencyUpdateWithWhereUniqueWithoutBraceletInput[]
    updateMany?: EmergencyUpdateManyWithWhereWithoutBraceletInput | EmergencyUpdateManyWithWhereWithoutBraceletInput[]
    deleteMany?: EmergencyScalarWhereInput | EmergencyScalarWhereInput[]
  }

  export type AlertUncheckedUpdateManyWithoutBraceletNestedInput = {
    create?: XOR<AlertCreateWithoutBraceletInput, AlertUncheckedCreateWithoutBraceletInput> | AlertCreateWithoutBraceletInput[] | AlertUncheckedCreateWithoutBraceletInput[]
    connectOrCreate?: AlertCreateOrConnectWithoutBraceletInput | AlertCreateOrConnectWithoutBraceletInput[]
    upsert?: AlertUpsertWithWhereUniqueWithoutBraceletInput | AlertUpsertWithWhereUniqueWithoutBraceletInput[]
    createMany?: AlertCreateManyBraceletInputEnvelope
    set?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    disconnect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    delete?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    connect?: AlertWhereUniqueInput | AlertWhereUniqueInput[]
    update?: AlertUpdateWithWhereUniqueWithoutBraceletInput | AlertUpdateWithWhereUniqueWithoutBraceletInput[]
    updateMany?: AlertUpdateManyWithWhereWithoutBraceletInput | AlertUpdateManyWithWhereWithoutBraceletInput[]
    deleteMany?: AlertScalarWhereInput | AlertScalarWhereInput[]
  }

  export type EmergencyUncheckedUpdateManyWithoutBraceletNestedInput = {
    create?: XOR<EmergencyCreateWithoutBraceletInput, EmergencyUncheckedCreateWithoutBraceletInput> | EmergencyCreateWithoutBraceletInput[] | EmergencyUncheckedCreateWithoutBraceletInput[]
    connectOrCreate?: EmergencyCreateOrConnectWithoutBraceletInput | EmergencyCreateOrConnectWithoutBraceletInput[]
    upsert?: EmergencyUpsertWithWhereUniqueWithoutBraceletInput | EmergencyUpsertWithWhereUniqueWithoutBraceletInput[]
    createMany?: EmergencyCreateManyBraceletInputEnvelope
    set?: EmergencyWhereUniqueInput | EmergencyWhereUniqueInput[]
    disconnect?: EmergencyWhereUniqueInput | EmergencyWhereUniqueInput[]
    delete?: EmergencyWhereUniqueInput | EmergencyWhereUniqueInput[]
    connect?: EmergencyWhereUniqueInput | EmergencyWhereUniqueInput[]
    update?: EmergencyUpdateWithWhereUniqueWithoutBraceletInput | EmergencyUpdateWithWhereUniqueWithoutBraceletInput[]
    updateMany?: EmergencyUpdateManyWithWhereWithoutBraceletInput | EmergencyUpdateManyWithWhereWithoutBraceletInput[]
    deleteMany?: EmergencyScalarWhereInput | EmergencyScalarWhereInput[]
  }

  export type BraceletCreateNestedOneWithoutAlertsInput = {
    create?: XOR<BraceletCreateWithoutAlertsInput, BraceletUncheckedCreateWithoutAlertsInput>
    connectOrCreate?: BraceletCreateOrConnectWithoutAlertsInput
    connect?: BraceletWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAlertsInput = {
    create?: XOR<UserCreateWithoutAlertsInput, UserUncheckedCreateWithoutAlertsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAlertsInput
    connect?: UserWhereUniqueInput
  }

  export type ZoneCreateNestedOneWithoutAlertsInput = {
    create?: XOR<ZoneCreateWithoutAlertsInput, ZoneUncheckedCreateWithoutAlertsInput>
    connectOrCreate?: ZoneCreateOrConnectWithoutAlertsInput
    connect?: ZoneWhereUniqueInput
  }

  export type EnumAlertTypeFieldUpdateOperationsInput = {
    set?: $Enums.AlertType
  }

  export type EnumAlertStatusFieldUpdateOperationsInput = {
    set?: $Enums.AlertStatus
  }

  export type BraceletUpdateOneRequiredWithoutAlertsNestedInput = {
    create?: XOR<BraceletCreateWithoutAlertsInput, BraceletUncheckedCreateWithoutAlertsInput>
    connectOrCreate?: BraceletCreateOrConnectWithoutAlertsInput
    upsert?: BraceletUpsertWithoutAlertsInput
    connect?: BraceletWhereUniqueInput
    update?: XOR<XOR<BraceletUpdateToOneWithWhereWithoutAlertsInput, BraceletUpdateWithoutAlertsInput>, BraceletUncheckedUpdateWithoutAlertsInput>
  }

  export type UserUpdateOneRequiredWithoutAlertsNestedInput = {
    create?: XOR<UserCreateWithoutAlertsInput, UserUncheckedCreateWithoutAlertsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAlertsInput
    upsert?: UserUpsertWithoutAlertsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAlertsInput, UserUpdateWithoutAlertsInput>, UserUncheckedUpdateWithoutAlertsInput>
  }

  export type ZoneUpdateOneRequiredWithoutAlertsNestedInput = {
    create?: XOR<ZoneCreateWithoutAlertsInput, ZoneUncheckedCreateWithoutAlertsInput>
    connectOrCreate?: ZoneCreateOrConnectWithoutAlertsInput
    upsert?: ZoneUpsertWithoutAlertsInput
    connect?: ZoneWhereUniqueInput
    update?: XOR<XOR<ZoneUpdateToOneWithWhereWithoutAlertsInput, ZoneUpdateWithoutAlertsInput>, ZoneUncheckedUpdateWithoutAlertsInput>
  }

  export type BraceletCreateNestedOneWithoutEmergenciesInput = {
    create?: XOR<BraceletCreateWithoutEmergenciesInput, BraceletUncheckedCreateWithoutEmergenciesInput>
    connectOrCreate?: BraceletCreateOrConnectWithoutEmergenciesInput
    connect?: BraceletWhereUniqueInput
  }

  export type ZoneCreateNestedOneWithoutEmergenciesInput = {
    create?: XOR<ZoneCreateWithoutEmergenciesInput, ZoneUncheckedCreateWithoutEmergenciesInput>
    connectOrCreate?: ZoneCreateOrConnectWithoutEmergenciesInput
    connect?: ZoneWhereUniqueInput
  }

  export type NightclubCreateNestedOneWithoutEmergenciesInput = {
    create?: XOR<NightclubCreateWithoutEmergenciesInput, NightclubUncheckedCreateWithoutEmergenciesInput>
    connectOrCreate?: NightclubCreateOrConnectWithoutEmergenciesInput
    connect?: NightclubWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutEmergenciesInput = {
    create?: XOR<UserCreateWithoutEmergenciesInput, UserUncheckedCreateWithoutEmergenciesInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmergenciesInput
    connect?: UserWhereUniqueInput
  }

  export type EnumEmergencyStatusFieldUpdateOperationsInput = {
    set?: $Enums.EmergencyStatus
  }

  export type BraceletUpdateOneRequiredWithoutEmergenciesNestedInput = {
    create?: XOR<BraceletCreateWithoutEmergenciesInput, BraceletUncheckedCreateWithoutEmergenciesInput>
    connectOrCreate?: BraceletCreateOrConnectWithoutEmergenciesInput
    upsert?: BraceletUpsertWithoutEmergenciesInput
    connect?: BraceletWhereUniqueInput
    update?: XOR<XOR<BraceletUpdateToOneWithWhereWithoutEmergenciesInput, BraceletUpdateWithoutEmergenciesInput>, BraceletUncheckedUpdateWithoutEmergenciesInput>
  }

  export type ZoneUpdateOneRequiredWithoutEmergenciesNestedInput = {
    create?: XOR<ZoneCreateWithoutEmergenciesInput, ZoneUncheckedCreateWithoutEmergenciesInput>
    connectOrCreate?: ZoneCreateOrConnectWithoutEmergenciesInput
    upsert?: ZoneUpsertWithoutEmergenciesInput
    connect?: ZoneWhereUniqueInput
    update?: XOR<XOR<ZoneUpdateToOneWithWhereWithoutEmergenciesInput, ZoneUpdateWithoutEmergenciesInput>, ZoneUncheckedUpdateWithoutEmergenciesInput>
  }

  export type NightclubUpdateOneRequiredWithoutEmergenciesNestedInput = {
    create?: XOR<NightclubCreateWithoutEmergenciesInput, NightclubUncheckedCreateWithoutEmergenciesInput>
    connectOrCreate?: NightclubCreateOrConnectWithoutEmergenciesInput
    upsert?: NightclubUpsertWithoutEmergenciesInput
    connect?: NightclubWhereUniqueInput
    update?: XOR<XOR<NightclubUpdateToOneWithWhereWithoutEmergenciesInput, NightclubUpdateWithoutEmergenciesInput>, NightclubUncheckedUpdateWithoutEmergenciesInput>
  }

  export type UserUpdateOneWithoutEmergenciesNestedInput = {
    create?: XOR<UserCreateWithoutEmergenciesInput, UserUncheckedCreateWithoutEmergenciesInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmergenciesInput
    upsert?: UserUpsertWithoutEmergenciesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEmergenciesInput, UserUpdateWithoutEmergenciesInput>, UserUncheckedUpdateWithoutEmergenciesInput>
  }

  export type ZoneCreateNestedOneWithoutSensorsInput = {
    create?: XOR<ZoneCreateWithoutSensorsInput, ZoneUncheckedCreateWithoutSensorsInput>
    connectOrCreate?: ZoneCreateOrConnectWithoutSensorsInput
    connect?: ZoneWhereUniqueInput
  }

  export type EnumSensorTypeFieldUpdateOperationsInput = {
    set?: $Enums.SensorType
  }

  export type EnumSensorStatusFieldUpdateOperationsInput = {
    set?: $Enums.SensorStatus
  }

  export type ZoneUpdateOneRequiredWithoutSensorsNestedInput = {
    create?: XOR<ZoneCreateWithoutSensorsInput, ZoneUncheckedCreateWithoutSensorsInput>
    connectOrCreate?: ZoneCreateOrConnectWithoutSensorsInput
    upsert?: ZoneUpsertWithoutSensorsInput
    connect?: ZoneWhereUniqueInput
    update?: XOR<XOR<ZoneUpdateToOneWithWhereWithoutSensorsInput, ZoneUpdateWithoutSensorsInput>, ZoneUncheckedUpdateWithoutSensorsInput>
  }

  export type NightclubCreateNestedOneWithoutAnalyticsReportsInput = {
    create?: XOR<NightclubCreateWithoutAnalyticsReportsInput, NightclubUncheckedCreateWithoutAnalyticsReportsInput>
    connectOrCreate?: NightclubCreateOrConnectWithoutAnalyticsReportsInput
    connect?: NightclubWhereUniqueInput
  }

  export type NightclubUpdateOneRequiredWithoutAnalyticsReportsNestedInput = {
    create?: XOR<NightclubCreateWithoutAnalyticsReportsInput, NightclubUncheckedCreateWithoutAnalyticsReportsInput>
    connectOrCreate?: NightclubCreateOrConnectWithoutAnalyticsReportsInput
    upsert?: NightclubUpsertWithoutAnalyticsReportsInput
    connect?: NightclubWhereUniqueInput
    update?: XOR<XOR<NightclubUpdateToOneWithWhereWithoutAnalyticsReportsInput, NightclubUpdateWithoutAnalyticsReportsInput>, NightclubUncheckedUpdateWithoutAnalyticsReportsInput>
  }

  export type PredictionCreateNestedManyWithoutModelInput = {
    create?: XOR<PredictionCreateWithoutModelInput, PredictionUncheckedCreateWithoutModelInput> | PredictionCreateWithoutModelInput[] | PredictionUncheckedCreateWithoutModelInput[]
    connectOrCreate?: PredictionCreateOrConnectWithoutModelInput | PredictionCreateOrConnectWithoutModelInput[]
    createMany?: PredictionCreateManyModelInputEnvelope
    connect?: PredictionWhereUniqueInput | PredictionWhereUniqueInput[]
  }

  export type AnomalyCreateNestedManyWithoutModelInput = {
    create?: XOR<AnomalyCreateWithoutModelInput, AnomalyUncheckedCreateWithoutModelInput> | AnomalyCreateWithoutModelInput[] | AnomalyUncheckedCreateWithoutModelInput[]
    connectOrCreate?: AnomalyCreateOrConnectWithoutModelInput | AnomalyCreateOrConnectWithoutModelInput[]
    createMany?: AnomalyCreateManyModelInputEnvelope
    connect?: AnomalyWhereUniqueInput | AnomalyWhereUniqueInput[]
  }

  export type BehaviorAnalysisCreateNestedManyWithoutModelInput = {
    create?: XOR<BehaviorAnalysisCreateWithoutModelInput, BehaviorAnalysisUncheckedCreateWithoutModelInput> | BehaviorAnalysisCreateWithoutModelInput[] | BehaviorAnalysisUncheckedCreateWithoutModelInput[]
    connectOrCreate?: BehaviorAnalysisCreateOrConnectWithoutModelInput | BehaviorAnalysisCreateOrConnectWithoutModelInput[]
    createMany?: BehaviorAnalysisCreateManyModelInputEnvelope
    connect?: BehaviorAnalysisWhereUniqueInput | BehaviorAnalysisWhereUniqueInput[]
  }

  export type PredictionUncheckedCreateNestedManyWithoutModelInput = {
    create?: XOR<PredictionCreateWithoutModelInput, PredictionUncheckedCreateWithoutModelInput> | PredictionCreateWithoutModelInput[] | PredictionUncheckedCreateWithoutModelInput[]
    connectOrCreate?: PredictionCreateOrConnectWithoutModelInput | PredictionCreateOrConnectWithoutModelInput[]
    createMany?: PredictionCreateManyModelInputEnvelope
    connect?: PredictionWhereUniqueInput | PredictionWhereUniqueInput[]
  }

  export type AnomalyUncheckedCreateNestedManyWithoutModelInput = {
    create?: XOR<AnomalyCreateWithoutModelInput, AnomalyUncheckedCreateWithoutModelInput> | AnomalyCreateWithoutModelInput[] | AnomalyUncheckedCreateWithoutModelInput[]
    connectOrCreate?: AnomalyCreateOrConnectWithoutModelInput | AnomalyCreateOrConnectWithoutModelInput[]
    createMany?: AnomalyCreateManyModelInputEnvelope
    connect?: AnomalyWhereUniqueInput | AnomalyWhereUniqueInput[]
  }

  export type BehaviorAnalysisUncheckedCreateNestedManyWithoutModelInput = {
    create?: XOR<BehaviorAnalysisCreateWithoutModelInput, BehaviorAnalysisUncheckedCreateWithoutModelInput> | BehaviorAnalysisCreateWithoutModelInput[] | BehaviorAnalysisUncheckedCreateWithoutModelInput[]
    connectOrCreate?: BehaviorAnalysisCreateOrConnectWithoutModelInput | BehaviorAnalysisCreateOrConnectWithoutModelInput[]
    createMany?: BehaviorAnalysisCreateManyModelInputEnvelope
    connect?: BehaviorAnalysisWhereUniqueInput | BehaviorAnalysisWhereUniqueInput[]
  }

  export type PredictionUpdateManyWithoutModelNestedInput = {
    create?: XOR<PredictionCreateWithoutModelInput, PredictionUncheckedCreateWithoutModelInput> | PredictionCreateWithoutModelInput[] | PredictionUncheckedCreateWithoutModelInput[]
    connectOrCreate?: PredictionCreateOrConnectWithoutModelInput | PredictionCreateOrConnectWithoutModelInput[]
    upsert?: PredictionUpsertWithWhereUniqueWithoutModelInput | PredictionUpsertWithWhereUniqueWithoutModelInput[]
    createMany?: PredictionCreateManyModelInputEnvelope
    set?: PredictionWhereUniqueInput | PredictionWhereUniqueInput[]
    disconnect?: PredictionWhereUniqueInput | PredictionWhereUniqueInput[]
    delete?: PredictionWhereUniqueInput | PredictionWhereUniqueInput[]
    connect?: PredictionWhereUniqueInput | PredictionWhereUniqueInput[]
    update?: PredictionUpdateWithWhereUniqueWithoutModelInput | PredictionUpdateWithWhereUniqueWithoutModelInput[]
    updateMany?: PredictionUpdateManyWithWhereWithoutModelInput | PredictionUpdateManyWithWhereWithoutModelInput[]
    deleteMany?: PredictionScalarWhereInput | PredictionScalarWhereInput[]
  }

  export type AnomalyUpdateManyWithoutModelNestedInput = {
    create?: XOR<AnomalyCreateWithoutModelInput, AnomalyUncheckedCreateWithoutModelInput> | AnomalyCreateWithoutModelInput[] | AnomalyUncheckedCreateWithoutModelInput[]
    connectOrCreate?: AnomalyCreateOrConnectWithoutModelInput | AnomalyCreateOrConnectWithoutModelInput[]
    upsert?: AnomalyUpsertWithWhereUniqueWithoutModelInput | AnomalyUpsertWithWhereUniqueWithoutModelInput[]
    createMany?: AnomalyCreateManyModelInputEnvelope
    set?: AnomalyWhereUniqueInput | AnomalyWhereUniqueInput[]
    disconnect?: AnomalyWhereUniqueInput | AnomalyWhereUniqueInput[]
    delete?: AnomalyWhereUniqueInput | AnomalyWhereUniqueInput[]
    connect?: AnomalyWhereUniqueInput | AnomalyWhereUniqueInput[]
    update?: AnomalyUpdateWithWhereUniqueWithoutModelInput | AnomalyUpdateWithWhereUniqueWithoutModelInput[]
    updateMany?: AnomalyUpdateManyWithWhereWithoutModelInput | AnomalyUpdateManyWithWhereWithoutModelInput[]
    deleteMany?: AnomalyScalarWhereInput | AnomalyScalarWhereInput[]
  }

  export type BehaviorAnalysisUpdateManyWithoutModelNestedInput = {
    create?: XOR<BehaviorAnalysisCreateWithoutModelInput, BehaviorAnalysisUncheckedCreateWithoutModelInput> | BehaviorAnalysisCreateWithoutModelInput[] | BehaviorAnalysisUncheckedCreateWithoutModelInput[]
    connectOrCreate?: BehaviorAnalysisCreateOrConnectWithoutModelInput | BehaviorAnalysisCreateOrConnectWithoutModelInput[]
    upsert?: BehaviorAnalysisUpsertWithWhereUniqueWithoutModelInput | BehaviorAnalysisUpsertWithWhereUniqueWithoutModelInput[]
    createMany?: BehaviorAnalysisCreateManyModelInputEnvelope
    set?: BehaviorAnalysisWhereUniqueInput | BehaviorAnalysisWhereUniqueInput[]
    disconnect?: BehaviorAnalysisWhereUniqueInput | BehaviorAnalysisWhereUniqueInput[]
    delete?: BehaviorAnalysisWhereUniqueInput | BehaviorAnalysisWhereUniqueInput[]
    connect?: BehaviorAnalysisWhereUniqueInput | BehaviorAnalysisWhereUniqueInput[]
    update?: BehaviorAnalysisUpdateWithWhereUniqueWithoutModelInput | BehaviorAnalysisUpdateWithWhereUniqueWithoutModelInput[]
    updateMany?: BehaviorAnalysisUpdateManyWithWhereWithoutModelInput | BehaviorAnalysisUpdateManyWithWhereWithoutModelInput[]
    deleteMany?: BehaviorAnalysisScalarWhereInput | BehaviorAnalysisScalarWhereInput[]
  }

  export type PredictionUncheckedUpdateManyWithoutModelNestedInput = {
    create?: XOR<PredictionCreateWithoutModelInput, PredictionUncheckedCreateWithoutModelInput> | PredictionCreateWithoutModelInput[] | PredictionUncheckedCreateWithoutModelInput[]
    connectOrCreate?: PredictionCreateOrConnectWithoutModelInput | PredictionCreateOrConnectWithoutModelInput[]
    upsert?: PredictionUpsertWithWhereUniqueWithoutModelInput | PredictionUpsertWithWhereUniqueWithoutModelInput[]
    createMany?: PredictionCreateManyModelInputEnvelope
    set?: PredictionWhereUniqueInput | PredictionWhereUniqueInput[]
    disconnect?: PredictionWhereUniqueInput | PredictionWhereUniqueInput[]
    delete?: PredictionWhereUniqueInput | PredictionWhereUniqueInput[]
    connect?: PredictionWhereUniqueInput | PredictionWhereUniqueInput[]
    update?: PredictionUpdateWithWhereUniqueWithoutModelInput | PredictionUpdateWithWhereUniqueWithoutModelInput[]
    updateMany?: PredictionUpdateManyWithWhereWithoutModelInput | PredictionUpdateManyWithWhereWithoutModelInput[]
    deleteMany?: PredictionScalarWhereInput | PredictionScalarWhereInput[]
  }

  export type AnomalyUncheckedUpdateManyWithoutModelNestedInput = {
    create?: XOR<AnomalyCreateWithoutModelInput, AnomalyUncheckedCreateWithoutModelInput> | AnomalyCreateWithoutModelInput[] | AnomalyUncheckedCreateWithoutModelInput[]
    connectOrCreate?: AnomalyCreateOrConnectWithoutModelInput | AnomalyCreateOrConnectWithoutModelInput[]
    upsert?: AnomalyUpsertWithWhereUniqueWithoutModelInput | AnomalyUpsertWithWhereUniqueWithoutModelInput[]
    createMany?: AnomalyCreateManyModelInputEnvelope
    set?: AnomalyWhereUniqueInput | AnomalyWhereUniqueInput[]
    disconnect?: AnomalyWhereUniqueInput | AnomalyWhereUniqueInput[]
    delete?: AnomalyWhereUniqueInput | AnomalyWhereUniqueInput[]
    connect?: AnomalyWhereUniqueInput | AnomalyWhereUniqueInput[]
    update?: AnomalyUpdateWithWhereUniqueWithoutModelInput | AnomalyUpdateWithWhereUniqueWithoutModelInput[]
    updateMany?: AnomalyUpdateManyWithWhereWithoutModelInput | AnomalyUpdateManyWithWhereWithoutModelInput[]
    deleteMany?: AnomalyScalarWhereInput | AnomalyScalarWhereInput[]
  }

  export type BehaviorAnalysisUncheckedUpdateManyWithoutModelNestedInput = {
    create?: XOR<BehaviorAnalysisCreateWithoutModelInput, BehaviorAnalysisUncheckedCreateWithoutModelInput> | BehaviorAnalysisCreateWithoutModelInput[] | BehaviorAnalysisUncheckedCreateWithoutModelInput[]
    connectOrCreate?: BehaviorAnalysisCreateOrConnectWithoutModelInput | BehaviorAnalysisCreateOrConnectWithoutModelInput[]
    upsert?: BehaviorAnalysisUpsertWithWhereUniqueWithoutModelInput | BehaviorAnalysisUpsertWithWhereUniqueWithoutModelInput[]
    createMany?: BehaviorAnalysisCreateManyModelInputEnvelope
    set?: BehaviorAnalysisWhereUniqueInput | BehaviorAnalysisWhereUniqueInput[]
    disconnect?: BehaviorAnalysisWhereUniqueInput | BehaviorAnalysisWhereUniqueInput[]
    delete?: BehaviorAnalysisWhereUniqueInput | BehaviorAnalysisWhereUniqueInput[]
    connect?: BehaviorAnalysisWhereUniqueInput | BehaviorAnalysisWhereUniqueInput[]
    update?: BehaviorAnalysisUpdateWithWhereUniqueWithoutModelInput | BehaviorAnalysisUpdateWithWhereUniqueWithoutModelInput[]
    updateMany?: BehaviorAnalysisUpdateManyWithWhereWithoutModelInput | BehaviorAnalysisUpdateManyWithWhereWithoutModelInput[]
    deleteMany?: BehaviorAnalysisScalarWhereInput | BehaviorAnalysisScalarWhereInput[]
  }

  export type NightclubCreateNestedOneWithoutPredictionsInput = {
    create?: XOR<NightclubCreateWithoutPredictionsInput, NightclubUncheckedCreateWithoutPredictionsInput>
    connectOrCreate?: NightclubCreateOrConnectWithoutPredictionsInput
    connect?: NightclubWhereUniqueInput
  }

  export type ZoneCreateNestedOneWithoutPredictionsInput = {
    create?: XOR<ZoneCreateWithoutPredictionsInput, ZoneUncheckedCreateWithoutPredictionsInput>
    connectOrCreate?: ZoneCreateOrConnectWithoutPredictionsInput
    connect?: ZoneWhereUniqueInput
  }

  export type AIModelCreateNestedOneWithoutPredictionsInput = {
    create?: XOR<AIModelCreateWithoutPredictionsInput, AIModelUncheckedCreateWithoutPredictionsInput>
    connectOrCreate?: AIModelCreateOrConnectWithoutPredictionsInput
    connect?: AIModelWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NightclubUpdateOneRequiredWithoutPredictionsNestedInput = {
    create?: XOR<NightclubCreateWithoutPredictionsInput, NightclubUncheckedCreateWithoutPredictionsInput>
    connectOrCreate?: NightclubCreateOrConnectWithoutPredictionsInput
    upsert?: NightclubUpsertWithoutPredictionsInput
    connect?: NightclubWhereUniqueInput
    update?: XOR<XOR<NightclubUpdateToOneWithWhereWithoutPredictionsInput, NightclubUpdateWithoutPredictionsInput>, NightclubUncheckedUpdateWithoutPredictionsInput>
  }

  export type ZoneUpdateOneWithoutPredictionsNestedInput = {
    create?: XOR<ZoneCreateWithoutPredictionsInput, ZoneUncheckedCreateWithoutPredictionsInput>
    connectOrCreate?: ZoneCreateOrConnectWithoutPredictionsInput
    upsert?: ZoneUpsertWithoutPredictionsInput
    disconnect?: ZoneWhereInput | boolean
    delete?: ZoneWhereInput | boolean
    connect?: ZoneWhereUniqueInput
    update?: XOR<XOR<ZoneUpdateToOneWithWhereWithoutPredictionsInput, ZoneUpdateWithoutPredictionsInput>, ZoneUncheckedUpdateWithoutPredictionsInput>
  }

  export type AIModelUpdateOneRequiredWithoutPredictionsNestedInput = {
    create?: XOR<AIModelCreateWithoutPredictionsInput, AIModelUncheckedCreateWithoutPredictionsInput>
    connectOrCreate?: AIModelCreateOrConnectWithoutPredictionsInput
    upsert?: AIModelUpsertWithoutPredictionsInput
    connect?: AIModelWhereUniqueInput
    update?: XOR<XOR<AIModelUpdateToOneWithWhereWithoutPredictionsInput, AIModelUpdateWithoutPredictionsInput>, AIModelUncheckedUpdateWithoutPredictionsInput>
  }

  export type NightclubCreateNestedOneWithoutAnomaliesInput = {
    create?: XOR<NightclubCreateWithoutAnomaliesInput, NightclubUncheckedCreateWithoutAnomaliesInput>
    connectOrCreate?: NightclubCreateOrConnectWithoutAnomaliesInput
    connect?: NightclubWhereUniqueInput
  }

  export type ZoneCreateNestedOneWithoutAnomaliesInput = {
    create?: XOR<ZoneCreateWithoutAnomaliesInput, ZoneUncheckedCreateWithoutAnomaliesInput>
    connectOrCreate?: ZoneCreateOrConnectWithoutAnomaliesInput
    connect?: ZoneWhereUniqueInput
  }

  export type AIModelCreateNestedOneWithoutAnomaliesInput = {
    create?: XOR<AIModelCreateWithoutAnomaliesInput, AIModelUncheckedCreateWithoutAnomaliesInput>
    connectOrCreate?: AIModelCreateOrConnectWithoutAnomaliesInput
    connect?: AIModelWhereUniqueInput
  }

  export type NightclubUpdateOneRequiredWithoutAnomaliesNestedInput = {
    create?: XOR<NightclubCreateWithoutAnomaliesInput, NightclubUncheckedCreateWithoutAnomaliesInput>
    connectOrCreate?: NightclubCreateOrConnectWithoutAnomaliesInput
    upsert?: NightclubUpsertWithoutAnomaliesInput
    connect?: NightclubWhereUniqueInput
    update?: XOR<XOR<NightclubUpdateToOneWithWhereWithoutAnomaliesInput, NightclubUpdateWithoutAnomaliesInput>, NightclubUncheckedUpdateWithoutAnomaliesInput>
  }

  export type ZoneUpdateOneWithoutAnomaliesNestedInput = {
    create?: XOR<ZoneCreateWithoutAnomaliesInput, ZoneUncheckedCreateWithoutAnomaliesInput>
    connectOrCreate?: ZoneCreateOrConnectWithoutAnomaliesInput
    upsert?: ZoneUpsertWithoutAnomaliesInput
    disconnect?: ZoneWhereInput | boolean
    delete?: ZoneWhereInput | boolean
    connect?: ZoneWhereUniqueInput
    update?: XOR<XOR<ZoneUpdateToOneWithWhereWithoutAnomaliesInput, ZoneUpdateWithoutAnomaliesInput>, ZoneUncheckedUpdateWithoutAnomaliesInput>
  }

  export type AIModelUpdateOneRequiredWithoutAnomaliesNestedInput = {
    create?: XOR<AIModelCreateWithoutAnomaliesInput, AIModelUncheckedCreateWithoutAnomaliesInput>
    connectOrCreate?: AIModelCreateOrConnectWithoutAnomaliesInput
    upsert?: AIModelUpsertWithoutAnomaliesInput
    connect?: AIModelWhereUniqueInput
    update?: XOR<XOR<AIModelUpdateToOneWithWhereWithoutAnomaliesInput, AIModelUpdateWithoutAnomaliesInput>, AIModelUncheckedUpdateWithoutAnomaliesInput>
  }

  export type NightclubCreateNestedOneWithoutBehaviorsInput = {
    create?: XOR<NightclubCreateWithoutBehaviorsInput, NightclubUncheckedCreateWithoutBehaviorsInput>
    connectOrCreate?: NightclubCreateOrConnectWithoutBehaviorsInput
    connect?: NightclubWhereUniqueInput
  }

  export type ZoneCreateNestedOneWithoutBehaviorsInput = {
    create?: XOR<ZoneCreateWithoutBehaviorsInput, ZoneUncheckedCreateWithoutBehaviorsInput>
    connectOrCreate?: ZoneCreateOrConnectWithoutBehaviorsInput
    connect?: ZoneWhereUniqueInput
  }

  export type AIModelCreateNestedOneWithoutBehaviorAnalysesInput = {
    create?: XOR<AIModelCreateWithoutBehaviorAnalysesInput, AIModelUncheckedCreateWithoutBehaviorAnalysesInput>
    connectOrCreate?: AIModelCreateOrConnectWithoutBehaviorAnalysesInput
    connect?: AIModelWhereUniqueInput
  }

  export type NightclubUpdateOneRequiredWithoutBehaviorsNestedInput = {
    create?: XOR<NightclubCreateWithoutBehaviorsInput, NightclubUncheckedCreateWithoutBehaviorsInput>
    connectOrCreate?: NightclubCreateOrConnectWithoutBehaviorsInput
    upsert?: NightclubUpsertWithoutBehaviorsInput
    connect?: NightclubWhereUniqueInput
    update?: XOR<XOR<NightclubUpdateToOneWithWhereWithoutBehaviorsInput, NightclubUpdateWithoutBehaviorsInput>, NightclubUncheckedUpdateWithoutBehaviorsInput>
  }

  export type ZoneUpdateOneWithoutBehaviorsNestedInput = {
    create?: XOR<ZoneCreateWithoutBehaviorsInput, ZoneUncheckedCreateWithoutBehaviorsInput>
    connectOrCreate?: ZoneCreateOrConnectWithoutBehaviorsInput
    upsert?: ZoneUpsertWithoutBehaviorsInput
    disconnect?: ZoneWhereInput | boolean
    delete?: ZoneWhereInput | boolean
    connect?: ZoneWhereUniqueInput
    update?: XOR<XOR<ZoneUpdateToOneWithWhereWithoutBehaviorsInput, ZoneUpdateWithoutBehaviorsInput>, ZoneUncheckedUpdateWithoutBehaviorsInput>
  }

  export type AIModelUpdateOneRequiredWithoutBehaviorAnalysesNestedInput = {
    create?: XOR<AIModelCreateWithoutBehaviorAnalysesInput, AIModelUncheckedCreateWithoutBehaviorAnalysesInput>
    connectOrCreate?: AIModelCreateOrConnectWithoutBehaviorAnalysesInput
    upsert?: AIModelUpsertWithoutBehaviorAnalysesInput
    connect?: AIModelWhereUniqueInput
    update?: XOR<XOR<AIModelUpdateToOneWithWhereWithoutBehaviorAnalysesInput, AIModelUpdateWithoutBehaviorAnalysesInput>, AIModelUncheckedUpdateWithoutBehaviorAnalysesInput>
  }

  export type NightclubCreateNestedOneWithoutRealTimeMetricsInput = {
    create?: XOR<NightclubCreateWithoutRealTimeMetricsInput, NightclubUncheckedCreateWithoutRealTimeMetricsInput>
    connectOrCreate?: NightclubCreateOrConnectWithoutRealTimeMetricsInput
    connect?: NightclubWhereUniqueInput
  }

  export type ZoneCreateNestedOneWithoutRealTimeMetricsInput = {
    create?: XOR<ZoneCreateWithoutRealTimeMetricsInput, ZoneUncheckedCreateWithoutRealTimeMetricsInput>
    connectOrCreate?: ZoneCreateOrConnectWithoutRealTimeMetricsInput
    connect?: ZoneWhereUniqueInput
  }

  export type NightclubUpdateOneRequiredWithoutRealTimeMetricsNestedInput = {
    create?: XOR<NightclubCreateWithoutRealTimeMetricsInput, NightclubUncheckedCreateWithoutRealTimeMetricsInput>
    connectOrCreate?: NightclubCreateOrConnectWithoutRealTimeMetricsInput
    upsert?: NightclubUpsertWithoutRealTimeMetricsInput
    connect?: NightclubWhereUniqueInput
    update?: XOR<XOR<NightclubUpdateToOneWithWhereWithoutRealTimeMetricsInput, NightclubUpdateWithoutRealTimeMetricsInput>, NightclubUncheckedUpdateWithoutRealTimeMetricsInput>
  }

  export type ZoneUpdateOneWithoutRealTimeMetricsNestedInput = {
    create?: XOR<ZoneCreateWithoutRealTimeMetricsInput, ZoneUncheckedCreateWithoutRealTimeMetricsInput>
    connectOrCreate?: ZoneCreateOrConnectWithoutRealTimeMetricsInput
    upsert?: ZoneUpsertWithoutRealTimeMetricsInput
    disconnect?: ZoneWhereInput | boolean
    delete?: ZoneWhereInput | boolean
    connect?: ZoneWhereUniqueInput
    update?: XOR<XOR<ZoneUpdateToOneWithWhereWithoutRealTimeMetricsInput, ZoneUpdateWithoutRealTimeMetricsInput>, ZoneUncheckedUpdateWithoutRealTimeMetricsInput>
  }

  export type NightclubCreateNestedOneWithoutDataStreamsInput = {
    create?: XOR<NightclubCreateWithoutDataStreamsInput, NightclubUncheckedCreateWithoutDataStreamsInput>
    connectOrCreate?: NightclubCreateOrConnectWithoutDataStreamsInput
    connect?: NightclubWhereUniqueInput
  }

  export type NightclubUpdateOneRequiredWithoutDataStreamsNestedInput = {
    create?: XOR<NightclubCreateWithoutDataStreamsInput, NightclubUncheckedCreateWithoutDataStreamsInput>
    connectOrCreate?: NightclubCreateOrConnectWithoutDataStreamsInput
    upsert?: NightclubUpsertWithoutDataStreamsInput
    connect?: NightclubWhereUniqueInput
    update?: XOR<XOR<NightclubUpdateToOneWithWhereWithoutDataStreamsInput, NightclubUpdateWithoutDataStreamsInput>, NightclubUncheckedUpdateWithoutDataStreamsInput>
  }

  export type NightclubCreateNestedOneWithoutCacheEntriesInput = {
    create?: XOR<NightclubCreateWithoutCacheEntriesInput, NightclubUncheckedCreateWithoutCacheEntriesInput>
    connectOrCreate?: NightclubCreateOrConnectWithoutCacheEntriesInput
    connect?: NightclubWhereUniqueInput
  }

  export type NightclubUpdateOneRequiredWithoutCacheEntriesNestedInput = {
    create?: XOR<NightclubCreateWithoutCacheEntriesInput, NightclubUncheckedCreateWithoutCacheEntriesInput>
    connectOrCreate?: NightclubCreateOrConnectWithoutCacheEntriesInput
    upsert?: NightclubUpsertWithoutCacheEntriesInput
    connect?: NightclubWhereUniqueInput
    update?: XOR<XOR<NightclubUpdateToOneWithWhereWithoutCacheEntriesInput, NightclubUpdateWithoutCacheEntriesInput>, NightclubUncheckedUpdateWithoutCacheEntriesInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedEnumUserStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusFilter<$PrismaModel> | $Enums.UserStatus
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedEnumUserStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusWithAggregatesFilter<$PrismaModel> | $Enums.UserStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserStatusFilter<$PrismaModel>
    _max?: NestedEnumUserStatusFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumBraceletStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BraceletStatus | EnumBraceletStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BraceletStatus[] | ListEnumBraceletStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BraceletStatus[] | ListEnumBraceletStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBraceletStatusFilter<$PrismaModel> | $Enums.BraceletStatus
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumBraceletStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BraceletStatus | EnumBraceletStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BraceletStatus[] | ListEnumBraceletStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BraceletStatus[] | ListEnumBraceletStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBraceletStatusWithAggregatesFilter<$PrismaModel> | $Enums.BraceletStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBraceletStatusFilter<$PrismaModel>
    _max?: NestedEnumBraceletStatusFilter<$PrismaModel>
  }

  export type NestedEnumAlertTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AlertType | EnumAlertTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AlertType[] | ListEnumAlertTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AlertType[] | ListEnumAlertTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAlertTypeFilter<$PrismaModel> | $Enums.AlertType
  }

  export type NestedEnumAlertStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AlertStatus | EnumAlertStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AlertStatus[] | ListEnumAlertStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AlertStatus[] | ListEnumAlertStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAlertStatusFilter<$PrismaModel> | $Enums.AlertStatus
  }

  export type NestedEnumAlertTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AlertType | EnumAlertTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AlertType[] | ListEnumAlertTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AlertType[] | ListEnumAlertTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAlertTypeWithAggregatesFilter<$PrismaModel> | $Enums.AlertType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAlertTypeFilter<$PrismaModel>
    _max?: NestedEnumAlertTypeFilter<$PrismaModel>
  }

  export type NestedEnumAlertStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AlertStatus | EnumAlertStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AlertStatus[] | ListEnumAlertStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AlertStatus[] | ListEnumAlertStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAlertStatusWithAggregatesFilter<$PrismaModel> | $Enums.AlertStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAlertStatusFilter<$PrismaModel>
    _max?: NestedEnumAlertStatusFilter<$PrismaModel>
  }

  export type NestedEnumEmergencyStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EmergencyStatus | EnumEmergencyStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EmergencyStatus[] | ListEnumEmergencyStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmergencyStatus[] | ListEnumEmergencyStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEmergencyStatusFilter<$PrismaModel> | $Enums.EmergencyStatus
  }

  export type NestedEnumEmergencyStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EmergencyStatus | EnumEmergencyStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EmergencyStatus[] | ListEnumEmergencyStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EmergencyStatus[] | ListEnumEmergencyStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEmergencyStatusWithAggregatesFilter<$PrismaModel> | $Enums.EmergencyStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEmergencyStatusFilter<$PrismaModel>
    _max?: NestedEnumEmergencyStatusFilter<$PrismaModel>
  }

  export type NestedEnumSensorTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SensorType | EnumSensorTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SensorType[] | ListEnumSensorTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SensorType[] | ListEnumSensorTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSensorTypeFilter<$PrismaModel> | $Enums.SensorType
  }

  export type NestedEnumSensorStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SensorStatus | EnumSensorStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SensorStatus[] | ListEnumSensorStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SensorStatus[] | ListEnumSensorStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSensorStatusFilter<$PrismaModel> | $Enums.SensorStatus
  }

  export type NestedEnumSensorTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SensorType | EnumSensorTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SensorType[] | ListEnumSensorTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SensorType[] | ListEnumSensorTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSensorTypeWithAggregatesFilter<$PrismaModel> | $Enums.SensorType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSensorTypeFilter<$PrismaModel>
    _max?: NestedEnumSensorTypeFilter<$PrismaModel>
  }

  export type NestedEnumSensorStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SensorStatus | EnumSensorStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SensorStatus[] | ListEnumSensorStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SensorStatus[] | ListEnumSensorStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSensorStatusWithAggregatesFilter<$PrismaModel> | $Enums.SensorStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSensorStatusFilter<$PrismaModel>
    _max?: NestedEnumSensorStatusFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type FloorPlanCreateWithoutNightclubInput = {
    id?: string
    name: string
    imageUrl: string
    createdAt?: Date | string
    updatedAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    zones?: ZoneCreateNestedManyWithoutFloorPlanInput
  }

  export type FloorPlanUncheckedCreateWithoutNightclubInput = {
    id?: string
    name: string
    imageUrl: string
    createdAt?: Date | string
    updatedAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    zones?: ZoneUncheckedCreateNestedManyWithoutFloorPlanInput
  }

  export type FloorPlanCreateOrConnectWithoutNightclubInput = {
    where: FloorPlanWhereUniqueInput
    create: XOR<FloorPlanCreateWithoutNightclubInput, FloorPlanUncheckedCreateWithoutNightclubInput>
  }

  export type FloorPlanCreateManyNightclubInputEnvelope = {
    data: FloorPlanCreateManyNightclubInput | FloorPlanCreateManyNightclubInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutNightclubInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    deviceId?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    lastLocation?: NullableJsonNullValueInput | InputJsonValue
    alerts?: AlertCreateNestedManyWithoutUserInput
    emergencies?: EmergencyCreateNestedManyWithoutResponderInput
  }

  export type UserUncheckedCreateWithoutNightclubInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    deviceId?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    lastLocation?: NullableJsonNullValueInput | InputJsonValue
    alerts?: AlertUncheckedCreateNestedManyWithoutUserInput
    emergencies?: EmergencyUncheckedCreateNestedManyWithoutResponderInput
  }

  export type UserCreateOrConnectWithoutNightclubInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNightclubInput, UserUncheckedCreateWithoutNightclubInput>
  }

  export type UserCreateManyNightclubInputEnvelope = {
    data: UserCreateManyNightclubInput | UserCreateManyNightclubInput[]
    skipDuplicates?: boolean
  }

  export type BraceletCreateWithoutNightclubInput = {
    id?: string
    deviceId: string
    batteryLevel?: number | null
    status?: $Enums.BraceletStatus
    lastSeen?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    alerts?: AlertCreateNestedManyWithoutBraceletInput
    emergencies?: EmergencyCreateNestedManyWithoutBraceletInput
  }

  export type BraceletUncheckedCreateWithoutNightclubInput = {
    id?: string
    deviceId: string
    batteryLevel?: number | null
    status?: $Enums.BraceletStatus
    lastSeen?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    alerts?: AlertUncheckedCreateNestedManyWithoutBraceletInput
    emergencies?: EmergencyUncheckedCreateNestedManyWithoutBraceletInput
  }

  export type BraceletCreateOrConnectWithoutNightclubInput = {
    where: BraceletWhereUniqueInput
    create: XOR<BraceletCreateWithoutNightclubInput, BraceletUncheckedCreateWithoutNightclubInput>
  }

  export type BraceletCreateManyNightclubInputEnvelope = {
    data: BraceletCreateManyNightclubInput | BraceletCreateManyNightclubInput[]
    skipDuplicates?: boolean
  }

  export type ZoneCreateWithoutNightclubInput = {
    id?: string
    name: string
    coordinates: JsonNullValueInput | InputJsonValue
    capacity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    floorPlan: FloorPlanCreateNestedOneWithoutZonesInput
    alerts?: AlertCreateNestedManyWithoutZoneInput
    emergencies?: EmergencyCreateNestedManyWithoutZoneInput
    sensors?: SensorCreateNestedManyWithoutZoneInput
    anomalies?: AnomalyCreateNestedManyWithoutZoneInput
    behaviors?: BehaviorAnalysisCreateNestedManyWithoutZoneInput
    realTimeMetrics?: RealTimeMetricCreateNestedManyWithoutZoneInput
    predictions?: PredictionCreateNestedManyWithoutZoneInput
  }

  export type ZoneUncheckedCreateWithoutNightclubInput = {
    id?: string
    name: string
    coordinates: JsonNullValueInput | InputJsonValue
    capacity: number
    floorPlanId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    alerts?: AlertUncheckedCreateNestedManyWithoutZoneInput
    emergencies?: EmergencyUncheckedCreateNestedManyWithoutZoneInput
    sensors?: SensorUncheckedCreateNestedManyWithoutZoneInput
    anomalies?: AnomalyUncheckedCreateNestedManyWithoutZoneInput
    behaviors?: BehaviorAnalysisUncheckedCreateNestedManyWithoutZoneInput
    realTimeMetrics?: RealTimeMetricUncheckedCreateNestedManyWithoutZoneInput
    predictions?: PredictionUncheckedCreateNestedManyWithoutZoneInput
  }

  export type ZoneCreateOrConnectWithoutNightclubInput = {
    where: ZoneWhereUniqueInput
    create: XOR<ZoneCreateWithoutNightclubInput, ZoneUncheckedCreateWithoutNightclubInput>
  }

  export type ZoneCreateManyNightclubInputEnvelope = {
    data: ZoneCreateManyNightclubInput | ZoneCreateManyNightclubInput[]
    skipDuplicates?: boolean
  }

  export type EmergencyCreateWithoutNightclubInput = {
    id?: string
    status?: $Enums.EmergencyStatus
    responseTime?: number | null
    escalationDetails?: NullableJsonNullValueInput | InputJsonValue
    resolutionDetails?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    resolvedAt?: Date | string | null
    bracelet: BraceletCreateNestedOneWithoutEmergenciesInput
    zone: ZoneCreateNestedOneWithoutEmergenciesInput
    responder?: UserCreateNestedOneWithoutEmergenciesInput
  }

  export type EmergencyUncheckedCreateWithoutNightclubInput = {
    id?: string
    status?: $Enums.EmergencyStatus
    braceletId: string
    zoneId: string
    responderId?: string | null
    responseTime?: number | null
    escalationDetails?: NullableJsonNullValueInput | InputJsonValue
    resolutionDetails?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    resolvedAt?: Date | string | null
  }

  export type EmergencyCreateOrConnectWithoutNightclubInput = {
    where: EmergencyWhereUniqueInput
    create: XOR<EmergencyCreateWithoutNightclubInput, EmergencyUncheckedCreateWithoutNightclubInput>
  }

  export type EmergencyCreateManyNightclubInputEnvelope = {
    data: EmergencyCreateManyNightclubInput | EmergencyCreateManyNightclubInput[]
    skipDuplicates?: boolean
  }

  export type AnalyticsReportCreateWithoutNightclubInput = {
    id?: string
    type: string
    report: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnalyticsReportUncheckedCreateWithoutNightclubInput = {
    id?: string
    type: string
    report: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnalyticsReportCreateOrConnectWithoutNightclubInput = {
    where: AnalyticsReportWhereUniqueInput
    create: XOR<AnalyticsReportCreateWithoutNightclubInput, AnalyticsReportUncheckedCreateWithoutNightclubInput>
  }

  export type AnalyticsReportCreateManyNightclubInputEnvelope = {
    data: AnalyticsReportCreateManyNightclubInput | AnalyticsReportCreateManyNightclubInput[]
    skipDuplicates?: boolean
  }

  export type PredictionCreateWithoutNightclubInput = {
    id?: string
    type: string
    timestamp?: Date | string
    value: number
    confidence: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    zone?: ZoneCreateNestedOneWithoutPredictionsInput
    model: AIModelCreateNestedOneWithoutPredictionsInput
  }

  export type PredictionUncheckedCreateWithoutNightclubInput = {
    id?: string
    type: string
    timestamp?: Date | string
    value: number
    confidence: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    zoneId?: string | null
    modelId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PredictionCreateOrConnectWithoutNightclubInput = {
    where: PredictionWhereUniqueInput
    create: XOR<PredictionCreateWithoutNightclubInput, PredictionUncheckedCreateWithoutNightclubInput>
  }

  export type PredictionCreateManyNightclubInputEnvelope = {
    data: PredictionCreateManyNightclubInput | PredictionCreateManyNightclubInput[]
    skipDuplicates?: boolean
  }

  export type AnomalyCreateWithoutNightclubInput = {
    id?: string
    type: string
    severity: string
    status: string
    description: string
    timestamp?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    zone?: ZoneCreateNestedOneWithoutAnomaliesInput
    model: AIModelCreateNestedOneWithoutAnomaliesInput
  }

  export type AnomalyUncheckedCreateWithoutNightclubInput = {
    id?: string
    type: string
    severity: string
    status: string
    description: string
    timestamp?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    zoneId?: string | null
    modelId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnomalyCreateOrConnectWithoutNightclubInput = {
    where: AnomalyWhereUniqueInput
    create: XOR<AnomalyCreateWithoutNightclubInput, AnomalyUncheckedCreateWithoutNightclubInput>
  }

  export type AnomalyCreateManyNightclubInputEnvelope = {
    data: AnomalyCreateManyNightclubInput | AnomalyCreateManyNightclubInput[]
    skipDuplicates?: boolean
  }

  export type BehaviorAnalysisCreateWithoutNightclubInput = {
    id?: string
    type: string
    timestamp?: Date | string
    insights: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    zone?: ZoneCreateNestedOneWithoutBehaviorsInput
    model: AIModelCreateNestedOneWithoutBehaviorAnalysesInput
  }

  export type BehaviorAnalysisUncheckedCreateWithoutNightclubInput = {
    id?: string
    type: string
    timestamp?: Date | string
    insights: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    zoneId?: string | null
    modelId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BehaviorAnalysisCreateOrConnectWithoutNightclubInput = {
    where: BehaviorAnalysisWhereUniqueInput
    create: XOR<BehaviorAnalysisCreateWithoutNightclubInput, BehaviorAnalysisUncheckedCreateWithoutNightclubInput>
  }

  export type BehaviorAnalysisCreateManyNightclubInputEnvelope = {
    data: BehaviorAnalysisCreateManyNightclubInput | BehaviorAnalysisCreateManyNightclubInput[]
    skipDuplicates?: boolean
  }

  export type RealTimeMetricCreateWithoutNightclubInput = {
    id?: string
    type: string
    value: number
    timestamp?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    zone?: ZoneCreateNestedOneWithoutRealTimeMetricsInput
  }

  export type RealTimeMetricUncheckedCreateWithoutNightclubInput = {
    id?: string
    type: string
    value: number
    timestamp?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    zoneId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RealTimeMetricCreateOrConnectWithoutNightclubInput = {
    where: RealTimeMetricWhereUniqueInput
    create: XOR<RealTimeMetricCreateWithoutNightclubInput, RealTimeMetricUncheckedCreateWithoutNightclubInput>
  }

  export type RealTimeMetricCreateManyNightclubInputEnvelope = {
    data: RealTimeMetricCreateManyNightclubInput | RealTimeMetricCreateManyNightclubInput[]
    skipDuplicates?: boolean
  }

  export type DataStreamCreateWithoutNightclubInput = {
    id?: string
    type: string
    status: string
    lastUpdate?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DataStreamUncheckedCreateWithoutNightclubInput = {
    id?: string
    type: string
    status: string
    lastUpdate?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DataStreamCreateOrConnectWithoutNightclubInput = {
    where: DataStreamWhereUniqueInput
    create: XOR<DataStreamCreateWithoutNightclubInput, DataStreamUncheckedCreateWithoutNightclubInput>
  }

  export type DataStreamCreateManyNightclubInputEnvelope = {
    data: DataStreamCreateManyNightclubInput | DataStreamCreateManyNightclubInput[]
    skipDuplicates?: boolean
  }

  export type CacheEntryCreateWithoutNightclubInput = {
    id?: string
    key: string
    value: JsonNullValueInput | InputJsonValue
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CacheEntryUncheckedCreateWithoutNightclubInput = {
    id?: string
    key: string
    value: JsonNullValueInput | InputJsonValue
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CacheEntryCreateOrConnectWithoutNightclubInput = {
    where: CacheEntryWhereUniqueInput
    create: XOR<CacheEntryCreateWithoutNightclubInput, CacheEntryUncheckedCreateWithoutNightclubInput>
  }

  export type CacheEntryCreateManyNightclubInputEnvelope = {
    data: CacheEntryCreateManyNightclubInput | CacheEntryCreateManyNightclubInput[]
    skipDuplicates?: boolean
  }

  export type FloorPlanUpsertWithWhereUniqueWithoutNightclubInput = {
    where: FloorPlanWhereUniqueInput
    update: XOR<FloorPlanUpdateWithoutNightclubInput, FloorPlanUncheckedUpdateWithoutNightclubInput>
    create: XOR<FloorPlanCreateWithoutNightclubInput, FloorPlanUncheckedCreateWithoutNightclubInput>
  }

  export type FloorPlanUpdateWithWhereUniqueWithoutNightclubInput = {
    where: FloorPlanWhereUniqueInput
    data: XOR<FloorPlanUpdateWithoutNightclubInput, FloorPlanUncheckedUpdateWithoutNightclubInput>
  }

  export type FloorPlanUpdateManyWithWhereWithoutNightclubInput = {
    where: FloorPlanScalarWhereInput
    data: XOR<FloorPlanUpdateManyMutationInput, FloorPlanUncheckedUpdateManyWithoutNightclubInput>
  }

  export type FloorPlanScalarWhereInput = {
    AND?: FloorPlanScalarWhereInput | FloorPlanScalarWhereInput[]
    OR?: FloorPlanScalarWhereInput[]
    NOT?: FloorPlanScalarWhereInput | FloorPlanScalarWhereInput[]
    id?: StringFilter<"FloorPlan"> | string
    name?: StringFilter<"FloorPlan"> | string
    imageUrl?: StringFilter<"FloorPlan"> | string
    nightclubId?: StringFilter<"FloorPlan"> | string
    createdAt?: DateTimeFilter<"FloorPlan"> | Date | string
    updatedAt?: DateTimeFilter<"FloorPlan"> | Date | string
    metadata?: JsonNullableFilter<"FloorPlan">
  }

  export type UserUpsertWithWhereUniqueWithoutNightclubInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutNightclubInput, UserUncheckedUpdateWithoutNightclubInput>
    create: XOR<UserCreateWithoutNightclubInput, UserUncheckedCreateWithoutNightclubInput>
  }

  export type UserUpdateWithWhereUniqueWithoutNightclubInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutNightclubInput, UserUncheckedUpdateWithoutNightclubInput>
  }

  export type UserUpdateManyWithWhereWithoutNightclubInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutNightclubInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    status?: EnumUserStatusFilter<"User"> | $Enums.UserStatus
    deviceId?: StringNullableFilter<"User"> | string | null
    nightclubId?: StringNullableFilter<"User"> | string | null
    resetToken?: StringNullableFilter<"User"> | string | null
    resetTokenExpiry?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    lastLocation?: JsonNullableFilter<"User">
  }

  export type BraceletUpsertWithWhereUniqueWithoutNightclubInput = {
    where: BraceletWhereUniqueInput
    update: XOR<BraceletUpdateWithoutNightclubInput, BraceletUncheckedUpdateWithoutNightclubInput>
    create: XOR<BraceletCreateWithoutNightclubInput, BraceletUncheckedCreateWithoutNightclubInput>
  }

  export type BraceletUpdateWithWhereUniqueWithoutNightclubInput = {
    where: BraceletWhereUniqueInput
    data: XOR<BraceletUpdateWithoutNightclubInput, BraceletUncheckedUpdateWithoutNightclubInput>
  }

  export type BraceletUpdateManyWithWhereWithoutNightclubInput = {
    where: BraceletScalarWhereInput
    data: XOR<BraceletUpdateManyMutationInput, BraceletUncheckedUpdateManyWithoutNightclubInput>
  }

  export type BraceletScalarWhereInput = {
    AND?: BraceletScalarWhereInput | BraceletScalarWhereInput[]
    OR?: BraceletScalarWhereInput[]
    NOT?: BraceletScalarWhereInput | BraceletScalarWhereInput[]
    id?: StringFilter<"Bracelet"> | string
    deviceId?: StringFilter<"Bracelet"> | string
    batteryLevel?: IntNullableFilter<"Bracelet"> | number | null
    status?: EnumBraceletStatusFilter<"Bracelet"> | $Enums.BraceletStatus
    lastSeen?: DateTimeNullableFilter<"Bracelet"> | Date | string | null
    nightclubId?: StringFilter<"Bracelet"> | string
    metadata?: JsonNullableFilter<"Bracelet">
    createdAt?: DateTimeFilter<"Bracelet"> | Date | string
    updatedAt?: DateTimeFilter<"Bracelet"> | Date | string
  }

  export type ZoneUpsertWithWhereUniqueWithoutNightclubInput = {
    where: ZoneWhereUniqueInput
    update: XOR<ZoneUpdateWithoutNightclubInput, ZoneUncheckedUpdateWithoutNightclubInput>
    create: XOR<ZoneCreateWithoutNightclubInput, ZoneUncheckedCreateWithoutNightclubInput>
  }

  export type ZoneUpdateWithWhereUniqueWithoutNightclubInput = {
    where: ZoneWhereUniqueInput
    data: XOR<ZoneUpdateWithoutNightclubInput, ZoneUncheckedUpdateWithoutNightclubInput>
  }

  export type ZoneUpdateManyWithWhereWithoutNightclubInput = {
    where: ZoneScalarWhereInput
    data: XOR<ZoneUpdateManyMutationInput, ZoneUncheckedUpdateManyWithoutNightclubInput>
  }

  export type ZoneScalarWhereInput = {
    AND?: ZoneScalarWhereInput | ZoneScalarWhereInput[]
    OR?: ZoneScalarWhereInput[]
    NOT?: ZoneScalarWhereInput | ZoneScalarWhereInput[]
    id?: StringFilter<"Zone"> | string
    name?: StringFilter<"Zone"> | string
    coordinates?: JsonFilter<"Zone">
    capacity?: IntFilter<"Zone"> | number
    floorPlanId?: StringFilter<"Zone"> | string
    nightclubId?: StringFilter<"Zone"> | string
    createdAt?: DateTimeFilter<"Zone"> | Date | string
    updatedAt?: DateTimeFilter<"Zone"> | Date | string
  }

  export type EmergencyUpsertWithWhereUniqueWithoutNightclubInput = {
    where: EmergencyWhereUniqueInput
    update: XOR<EmergencyUpdateWithoutNightclubInput, EmergencyUncheckedUpdateWithoutNightclubInput>
    create: XOR<EmergencyCreateWithoutNightclubInput, EmergencyUncheckedCreateWithoutNightclubInput>
  }

  export type EmergencyUpdateWithWhereUniqueWithoutNightclubInput = {
    where: EmergencyWhereUniqueInput
    data: XOR<EmergencyUpdateWithoutNightclubInput, EmergencyUncheckedUpdateWithoutNightclubInput>
  }

  export type EmergencyUpdateManyWithWhereWithoutNightclubInput = {
    where: EmergencyScalarWhereInput
    data: XOR<EmergencyUpdateManyMutationInput, EmergencyUncheckedUpdateManyWithoutNightclubInput>
  }

  export type EmergencyScalarWhereInput = {
    AND?: EmergencyScalarWhereInput | EmergencyScalarWhereInput[]
    OR?: EmergencyScalarWhereInput[]
    NOT?: EmergencyScalarWhereInput | EmergencyScalarWhereInput[]
    id?: StringFilter<"Emergency"> | string
    status?: EnumEmergencyStatusFilter<"Emergency"> | $Enums.EmergencyStatus
    braceletId?: StringFilter<"Emergency"> | string
    zoneId?: StringFilter<"Emergency"> | string
    nightclubId?: StringFilter<"Emergency"> | string
    responderId?: StringNullableFilter<"Emergency"> | string | null
    responseTime?: IntNullableFilter<"Emergency"> | number | null
    escalationDetails?: JsonNullableFilter<"Emergency">
    resolutionDetails?: JsonNullableFilter<"Emergency">
    metadata?: JsonNullableFilter<"Emergency">
    createdAt?: DateTimeFilter<"Emergency"> | Date | string
    updatedAt?: DateTimeFilter<"Emergency"> | Date | string
    resolvedAt?: DateTimeNullableFilter<"Emergency"> | Date | string | null
  }

  export type AnalyticsReportUpsertWithWhereUniqueWithoutNightclubInput = {
    where: AnalyticsReportWhereUniqueInput
    update: XOR<AnalyticsReportUpdateWithoutNightclubInput, AnalyticsReportUncheckedUpdateWithoutNightclubInput>
    create: XOR<AnalyticsReportCreateWithoutNightclubInput, AnalyticsReportUncheckedCreateWithoutNightclubInput>
  }

  export type AnalyticsReportUpdateWithWhereUniqueWithoutNightclubInput = {
    where: AnalyticsReportWhereUniqueInput
    data: XOR<AnalyticsReportUpdateWithoutNightclubInput, AnalyticsReportUncheckedUpdateWithoutNightclubInput>
  }

  export type AnalyticsReportUpdateManyWithWhereWithoutNightclubInput = {
    where: AnalyticsReportScalarWhereInput
    data: XOR<AnalyticsReportUpdateManyMutationInput, AnalyticsReportUncheckedUpdateManyWithoutNightclubInput>
  }

  export type AnalyticsReportScalarWhereInput = {
    AND?: AnalyticsReportScalarWhereInput | AnalyticsReportScalarWhereInput[]
    OR?: AnalyticsReportScalarWhereInput[]
    NOT?: AnalyticsReportScalarWhereInput | AnalyticsReportScalarWhereInput[]
    id?: StringFilter<"AnalyticsReport"> | string
    nightclubId?: StringFilter<"AnalyticsReport"> | string
    type?: StringFilter<"AnalyticsReport"> | string
    report?: JsonFilter<"AnalyticsReport">
    metadata?: JsonNullableFilter<"AnalyticsReport">
    createdAt?: DateTimeFilter<"AnalyticsReport"> | Date | string
    updatedAt?: DateTimeFilter<"AnalyticsReport"> | Date | string
  }

  export type PredictionUpsertWithWhereUniqueWithoutNightclubInput = {
    where: PredictionWhereUniqueInput
    update: XOR<PredictionUpdateWithoutNightclubInput, PredictionUncheckedUpdateWithoutNightclubInput>
    create: XOR<PredictionCreateWithoutNightclubInput, PredictionUncheckedCreateWithoutNightclubInput>
  }

  export type PredictionUpdateWithWhereUniqueWithoutNightclubInput = {
    where: PredictionWhereUniqueInput
    data: XOR<PredictionUpdateWithoutNightclubInput, PredictionUncheckedUpdateWithoutNightclubInput>
  }

  export type PredictionUpdateManyWithWhereWithoutNightclubInput = {
    where: PredictionScalarWhereInput
    data: XOR<PredictionUpdateManyMutationInput, PredictionUncheckedUpdateManyWithoutNightclubInput>
  }

  export type PredictionScalarWhereInput = {
    AND?: PredictionScalarWhereInput | PredictionScalarWhereInput[]
    OR?: PredictionScalarWhereInput[]
    NOT?: PredictionScalarWhereInput | PredictionScalarWhereInput[]
    id?: StringFilter<"Prediction"> | string
    type?: StringFilter<"Prediction"> | string
    timestamp?: DateTimeFilter<"Prediction"> | Date | string
    value?: FloatFilter<"Prediction"> | number
    confidence?: FloatFilter<"Prediction"> | number
    metadata?: JsonNullableFilter<"Prediction">
    nightclubId?: StringFilter<"Prediction"> | string
    zoneId?: StringNullableFilter<"Prediction"> | string | null
    modelId?: StringFilter<"Prediction"> | string
    createdAt?: DateTimeFilter<"Prediction"> | Date | string
    updatedAt?: DateTimeFilter<"Prediction"> | Date | string
  }

  export type AnomalyUpsertWithWhereUniqueWithoutNightclubInput = {
    where: AnomalyWhereUniqueInput
    update: XOR<AnomalyUpdateWithoutNightclubInput, AnomalyUncheckedUpdateWithoutNightclubInput>
    create: XOR<AnomalyCreateWithoutNightclubInput, AnomalyUncheckedCreateWithoutNightclubInput>
  }

  export type AnomalyUpdateWithWhereUniqueWithoutNightclubInput = {
    where: AnomalyWhereUniqueInput
    data: XOR<AnomalyUpdateWithoutNightclubInput, AnomalyUncheckedUpdateWithoutNightclubInput>
  }

  export type AnomalyUpdateManyWithWhereWithoutNightclubInput = {
    where: AnomalyScalarWhereInput
    data: XOR<AnomalyUpdateManyMutationInput, AnomalyUncheckedUpdateManyWithoutNightclubInput>
  }

  export type AnomalyScalarWhereInput = {
    AND?: AnomalyScalarWhereInput | AnomalyScalarWhereInput[]
    OR?: AnomalyScalarWhereInput[]
    NOT?: AnomalyScalarWhereInput | AnomalyScalarWhereInput[]
    id?: StringFilter<"Anomaly"> | string
    type?: StringFilter<"Anomaly"> | string
    severity?: StringFilter<"Anomaly"> | string
    status?: StringFilter<"Anomaly"> | string
    description?: StringFilter<"Anomaly"> | string
    timestamp?: DateTimeFilter<"Anomaly"> | Date | string
    metadata?: JsonNullableFilter<"Anomaly">
    nightclubId?: StringFilter<"Anomaly"> | string
    zoneId?: StringNullableFilter<"Anomaly"> | string | null
    modelId?: StringFilter<"Anomaly"> | string
    createdAt?: DateTimeFilter<"Anomaly"> | Date | string
    updatedAt?: DateTimeFilter<"Anomaly"> | Date | string
  }

  export type BehaviorAnalysisUpsertWithWhereUniqueWithoutNightclubInput = {
    where: BehaviorAnalysisWhereUniqueInput
    update: XOR<BehaviorAnalysisUpdateWithoutNightclubInput, BehaviorAnalysisUncheckedUpdateWithoutNightclubInput>
    create: XOR<BehaviorAnalysisCreateWithoutNightclubInput, BehaviorAnalysisUncheckedCreateWithoutNightclubInput>
  }

  export type BehaviorAnalysisUpdateWithWhereUniqueWithoutNightclubInput = {
    where: BehaviorAnalysisWhereUniqueInput
    data: XOR<BehaviorAnalysisUpdateWithoutNightclubInput, BehaviorAnalysisUncheckedUpdateWithoutNightclubInput>
  }

  export type BehaviorAnalysisUpdateManyWithWhereWithoutNightclubInput = {
    where: BehaviorAnalysisScalarWhereInput
    data: XOR<BehaviorAnalysisUpdateManyMutationInput, BehaviorAnalysisUncheckedUpdateManyWithoutNightclubInput>
  }

  export type BehaviorAnalysisScalarWhereInput = {
    AND?: BehaviorAnalysisScalarWhereInput | BehaviorAnalysisScalarWhereInput[]
    OR?: BehaviorAnalysisScalarWhereInput[]
    NOT?: BehaviorAnalysisScalarWhereInput | BehaviorAnalysisScalarWhereInput[]
    id?: StringFilter<"BehaviorAnalysis"> | string
    type?: StringFilter<"BehaviorAnalysis"> | string
    timestamp?: DateTimeFilter<"BehaviorAnalysis"> | Date | string
    insights?: JsonFilter<"BehaviorAnalysis">
    metadata?: JsonNullableFilter<"BehaviorAnalysis">
    nightclubId?: StringFilter<"BehaviorAnalysis"> | string
    zoneId?: StringNullableFilter<"BehaviorAnalysis"> | string | null
    modelId?: StringFilter<"BehaviorAnalysis"> | string
    createdAt?: DateTimeFilter<"BehaviorAnalysis"> | Date | string
    updatedAt?: DateTimeFilter<"BehaviorAnalysis"> | Date | string
  }

  export type RealTimeMetricUpsertWithWhereUniqueWithoutNightclubInput = {
    where: RealTimeMetricWhereUniqueInput
    update: XOR<RealTimeMetricUpdateWithoutNightclubInput, RealTimeMetricUncheckedUpdateWithoutNightclubInput>
    create: XOR<RealTimeMetricCreateWithoutNightclubInput, RealTimeMetricUncheckedCreateWithoutNightclubInput>
  }

  export type RealTimeMetricUpdateWithWhereUniqueWithoutNightclubInput = {
    where: RealTimeMetricWhereUniqueInput
    data: XOR<RealTimeMetricUpdateWithoutNightclubInput, RealTimeMetricUncheckedUpdateWithoutNightclubInput>
  }

  export type RealTimeMetricUpdateManyWithWhereWithoutNightclubInput = {
    where: RealTimeMetricScalarWhereInput
    data: XOR<RealTimeMetricUpdateManyMutationInput, RealTimeMetricUncheckedUpdateManyWithoutNightclubInput>
  }

  export type RealTimeMetricScalarWhereInput = {
    AND?: RealTimeMetricScalarWhereInput | RealTimeMetricScalarWhereInput[]
    OR?: RealTimeMetricScalarWhereInput[]
    NOT?: RealTimeMetricScalarWhereInput | RealTimeMetricScalarWhereInput[]
    id?: StringFilter<"RealTimeMetric"> | string
    type?: StringFilter<"RealTimeMetric"> | string
    value?: FloatFilter<"RealTimeMetric"> | number
    timestamp?: DateTimeFilter<"RealTimeMetric"> | Date | string
    metadata?: JsonNullableFilter<"RealTimeMetric">
    nightclubId?: StringFilter<"RealTimeMetric"> | string
    zoneId?: StringNullableFilter<"RealTimeMetric"> | string | null
    createdAt?: DateTimeFilter<"RealTimeMetric"> | Date | string
    updatedAt?: DateTimeFilter<"RealTimeMetric"> | Date | string
  }

  export type DataStreamUpsertWithWhereUniqueWithoutNightclubInput = {
    where: DataStreamWhereUniqueInput
    update: XOR<DataStreamUpdateWithoutNightclubInput, DataStreamUncheckedUpdateWithoutNightclubInput>
    create: XOR<DataStreamCreateWithoutNightclubInput, DataStreamUncheckedCreateWithoutNightclubInput>
  }

  export type DataStreamUpdateWithWhereUniqueWithoutNightclubInput = {
    where: DataStreamWhereUniqueInput
    data: XOR<DataStreamUpdateWithoutNightclubInput, DataStreamUncheckedUpdateWithoutNightclubInput>
  }

  export type DataStreamUpdateManyWithWhereWithoutNightclubInput = {
    where: DataStreamScalarWhereInput
    data: XOR<DataStreamUpdateManyMutationInput, DataStreamUncheckedUpdateManyWithoutNightclubInput>
  }

  export type DataStreamScalarWhereInput = {
    AND?: DataStreamScalarWhereInput | DataStreamScalarWhereInput[]
    OR?: DataStreamScalarWhereInput[]
    NOT?: DataStreamScalarWhereInput | DataStreamScalarWhereInput[]
    id?: StringFilter<"DataStream"> | string
    type?: StringFilter<"DataStream"> | string
    status?: StringFilter<"DataStream"> | string
    lastUpdate?: DateTimeFilter<"DataStream"> | Date | string
    metadata?: JsonNullableFilter<"DataStream">
    nightclubId?: StringFilter<"DataStream"> | string
    createdAt?: DateTimeFilter<"DataStream"> | Date | string
    updatedAt?: DateTimeFilter<"DataStream"> | Date | string
  }

  export type CacheEntryUpsertWithWhereUniqueWithoutNightclubInput = {
    where: CacheEntryWhereUniqueInput
    update: XOR<CacheEntryUpdateWithoutNightclubInput, CacheEntryUncheckedUpdateWithoutNightclubInput>
    create: XOR<CacheEntryCreateWithoutNightclubInput, CacheEntryUncheckedCreateWithoutNightclubInput>
  }

  export type CacheEntryUpdateWithWhereUniqueWithoutNightclubInput = {
    where: CacheEntryWhereUniqueInput
    data: XOR<CacheEntryUpdateWithoutNightclubInput, CacheEntryUncheckedUpdateWithoutNightclubInput>
  }

  export type CacheEntryUpdateManyWithWhereWithoutNightclubInput = {
    where: CacheEntryScalarWhereInput
    data: XOR<CacheEntryUpdateManyMutationInput, CacheEntryUncheckedUpdateManyWithoutNightclubInput>
  }

  export type CacheEntryScalarWhereInput = {
    AND?: CacheEntryScalarWhereInput | CacheEntryScalarWhereInput[]
    OR?: CacheEntryScalarWhereInput[]
    NOT?: CacheEntryScalarWhereInput | CacheEntryScalarWhereInput[]
    id?: StringFilter<"CacheEntry"> | string
    key?: StringFilter<"CacheEntry"> | string
    value?: JsonFilter<"CacheEntry">
    expiresAt?: DateTimeNullableFilter<"CacheEntry"> | Date | string | null
    createdAt?: DateTimeFilter<"CacheEntry"> | Date | string
    updatedAt?: DateTimeFilter<"CacheEntry"> | Date | string
    nightclubId?: StringFilter<"CacheEntry"> | string
  }

  export type NightclubCreateWithoutUsersInput = {
    id?: string
    name: string
    address: string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    floorPlans?: FloorPlanCreateNestedManyWithoutNightclubInput
    bracelets?: BraceletCreateNestedManyWithoutNightclubInput
    zones?: ZoneCreateNestedManyWithoutNightclubInput
    emergencies?: EmergencyCreateNestedManyWithoutNightclubInput
    analyticsReports?: AnalyticsReportCreateNestedManyWithoutNightclubInput
    predictions?: PredictionCreateNestedManyWithoutNightclubInput
    anomalies?: AnomalyCreateNestedManyWithoutNightclubInput
    behaviors?: BehaviorAnalysisCreateNestedManyWithoutNightclubInput
    realTimeMetrics?: RealTimeMetricCreateNestedManyWithoutNightclubInput
    dataStreams?: DataStreamCreateNestedManyWithoutNightclubInput
    cacheEntries?: CacheEntryCreateNestedManyWithoutNightclubInput
  }

  export type NightclubUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    address: string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    floorPlans?: FloorPlanUncheckedCreateNestedManyWithoutNightclubInput
    bracelets?: BraceletUncheckedCreateNestedManyWithoutNightclubInput
    zones?: ZoneUncheckedCreateNestedManyWithoutNightclubInput
    emergencies?: EmergencyUncheckedCreateNestedManyWithoutNightclubInput
    analyticsReports?: AnalyticsReportUncheckedCreateNestedManyWithoutNightclubInput
    predictions?: PredictionUncheckedCreateNestedManyWithoutNightclubInput
    anomalies?: AnomalyUncheckedCreateNestedManyWithoutNightclubInput
    behaviors?: BehaviorAnalysisUncheckedCreateNestedManyWithoutNightclubInput
    realTimeMetrics?: RealTimeMetricUncheckedCreateNestedManyWithoutNightclubInput
    dataStreams?: DataStreamUncheckedCreateNestedManyWithoutNightclubInput
    cacheEntries?: CacheEntryUncheckedCreateNestedManyWithoutNightclubInput
  }

  export type NightclubCreateOrConnectWithoutUsersInput = {
    where: NightclubWhereUniqueInput
    create: XOR<NightclubCreateWithoutUsersInput, NightclubUncheckedCreateWithoutUsersInput>
  }

  export type AlertCreateWithoutUserInput = {
    id?: string
    type: $Enums.AlertType
    status?: $Enums.AlertStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    resolvedAt?: Date | string | null
    bracelet: BraceletCreateNestedOneWithoutAlertsInput
    zone: ZoneCreateNestedOneWithoutAlertsInput
  }

  export type AlertUncheckedCreateWithoutUserInput = {
    id?: string
    type: $Enums.AlertType
    status?: $Enums.AlertStatus
    braceletId: string
    zoneId: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    resolvedAt?: Date | string | null
  }

  export type AlertCreateOrConnectWithoutUserInput = {
    where: AlertWhereUniqueInput
    create: XOR<AlertCreateWithoutUserInput, AlertUncheckedCreateWithoutUserInput>
  }

  export type AlertCreateManyUserInputEnvelope = {
    data: AlertCreateManyUserInput | AlertCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type EmergencyCreateWithoutResponderInput = {
    id?: string
    status?: $Enums.EmergencyStatus
    responseTime?: number | null
    escalationDetails?: NullableJsonNullValueInput | InputJsonValue
    resolutionDetails?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    resolvedAt?: Date | string | null
    bracelet: BraceletCreateNestedOneWithoutEmergenciesInput
    zone: ZoneCreateNestedOneWithoutEmergenciesInput
    nightclub: NightclubCreateNestedOneWithoutEmergenciesInput
  }

  export type EmergencyUncheckedCreateWithoutResponderInput = {
    id?: string
    status?: $Enums.EmergencyStatus
    braceletId: string
    zoneId: string
    nightclubId: string
    responseTime?: number | null
    escalationDetails?: NullableJsonNullValueInput | InputJsonValue
    resolutionDetails?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    resolvedAt?: Date | string | null
  }

  export type EmergencyCreateOrConnectWithoutResponderInput = {
    where: EmergencyWhereUniqueInput
    create: XOR<EmergencyCreateWithoutResponderInput, EmergencyUncheckedCreateWithoutResponderInput>
  }

  export type EmergencyCreateManyResponderInputEnvelope = {
    data: EmergencyCreateManyResponderInput | EmergencyCreateManyResponderInput[]
    skipDuplicates?: boolean
  }

  export type NightclubUpsertWithoutUsersInput = {
    update: XOR<NightclubUpdateWithoutUsersInput, NightclubUncheckedUpdateWithoutUsersInput>
    create: XOR<NightclubCreateWithoutUsersInput, NightclubUncheckedCreateWithoutUsersInput>
    where?: NightclubWhereInput
  }

  export type NightclubUpdateToOneWithWhereWithoutUsersInput = {
    where?: NightclubWhereInput
    data: XOR<NightclubUpdateWithoutUsersInput, NightclubUncheckedUpdateWithoutUsersInput>
  }

  export type NightclubUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    floorPlans?: FloorPlanUpdateManyWithoutNightclubNestedInput
    bracelets?: BraceletUpdateManyWithoutNightclubNestedInput
    zones?: ZoneUpdateManyWithoutNightclubNestedInput
    emergencies?: EmergencyUpdateManyWithoutNightclubNestedInput
    analyticsReports?: AnalyticsReportUpdateManyWithoutNightclubNestedInput
    predictions?: PredictionUpdateManyWithoutNightclubNestedInput
    anomalies?: AnomalyUpdateManyWithoutNightclubNestedInput
    behaviors?: BehaviorAnalysisUpdateManyWithoutNightclubNestedInput
    realTimeMetrics?: RealTimeMetricUpdateManyWithoutNightclubNestedInput
    dataStreams?: DataStreamUpdateManyWithoutNightclubNestedInput
    cacheEntries?: CacheEntryUpdateManyWithoutNightclubNestedInput
  }

  export type NightclubUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    floorPlans?: FloorPlanUncheckedUpdateManyWithoutNightclubNestedInput
    bracelets?: BraceletUncheckedUpdateManyWithoutNightclubNestedInput
    zones?: ZoneUncheckedUpdateManyWithoutNightclubNestedInput
    emergencies?: EmergencyUncheckedUpdateManyWithoutNightclubNestedInput
    analyticsReports?: AnalyticsReportUncheckedUpdateManyWithoutNightclubNestedInput
    predictions?: PredictionUncheckedUpdateManyWithoutNightclubNestedInput
    anomalies?: AnomalyUncheckedUpdateManyWithoutNightclubNestedInput
    behaviors?: BehaviorAnalysisUncheckedUpdateManyWithoutNightclubNestedInput
    realTimeMetrics?: RealTimeMetricUncheckedUpdateManyWithoutNightclubNestedInput
    dataStreams?: DataStreamUncheckedUpdateManyWithoutNightclubNestedInput
    cacheEntries?: CacheEntryUncheckedUpdateManyWithoutNightclubNestedInput
  }

  export type AlertUpsertWithWhereUniqueWithoutUserInput = {
    where: AlertWhereUniqueInput
    update: XOR<AlertUpdateWithoutUserInput, AlertUncheckedUpdateWithoutUserInput>
    create: XOR<AlertCreateWithoutUserInput, AlertUncheckedCreateWithoutUserInput>
  }

  export type AlertUpdateWithWhereUniqueWithoutUserInput = {
    where: AlertWhereUniqueInput
    data: XOR<AlertUpdateWithoutUserInput, AlertUncheckedUpdateWithoutUserInput>
  }

  export type AlertUpdateManyWithWhereWithoutUserInput = {
    where: AlertScalarWhereInput
    data: XOR<AlertUpdateManyMutationInput, AlertUncheckedUpdateManyWithoutUserInput>
  }

  export type AlertScalarWhereInput = {
    AND?: AlertScalarWhereInput | AlertScalarWhereInput[]
    OR?: AlertScalarWhereInput[]
    NOT?: AlertScalarWhereInput | AlertScalarWhereInput[]
    id?: StringFilter<"Alert"> | string
    type?: EnumAlertTypeFilter<"Alert"> | $Enums.AlertType
    status?: EnumAlertStatusFilter<"Alert"> | $Enums.AlertStatus
    braceletId?: StringFilter<"Alert"> | string
    userId?: StringFilter<"Alert"> | string
    zoneId?: StringFilter<"Alert"> | string
    metadata?: JsonNullableFilter<"Alert">
    createdAt?: DateTimeFilter<"Alert"> | Date | string
    updatedAt?: DateTimeFilter<"Alert"> | Date | string
    resolvedAt?: DateTimeNullableFilter<"Alert"> | Date | string | null
  }

  export type EmergencyUpsertWithWhereUniqueWithoutResponderInput = {
    where: EmergencyWhereUniqueInput
    update: XOR<EmergencyUpdateWithoutResponderInput, EmergencyUncheckedUpdateWithoutResponderInput>
    create: XOR<EmergencyCreateWithoutResponderInput, EmergencyUncheckedCreateWithoutResponderInput>
  }

  export type EmergencyUpdateWithWhereUniqueWithoutResponderInput = {
    where: EmergencyWhereUniqueInput
    data: XOR<EmergencyUpdateWithoutResponderInput, EmergencyUncheckedUpdateWithoutResponderInput>
  }

  export type EmergencyUpdateManyWithWhereWithoutResponderInput = {
    where: EmergencyScalarWhereInput
    data: XOR<EmergencyUpdateManyMutationInput, EmergencyUncheckedUpdateManyWithoutResponderInput>
  }

  export type NightclubCreateWithoutFloorPlansInput = {
    id?: string
    name: string
    address: string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutNightclubInput
    bracelets?: BraceletCreateNestedManyWithoutNightclubInput
    zones?: ZoneCreateNestedManyWithoutNightclubInput
    emergencies?: EmergencyCreateNestedManyWithoutNightclubInput
    analyticsReports?: AnalyticsReportCreateNestedManyWithoutNightclubInput
    predictions?: PredictionCreateNestedManyWithoutNightclubInput
    anomalies?: AnomalyCreateNestedManyWithoutNightclubInput
    behaviors?: BehaviorAnalysisCreateNestedManyWithoutNightclubInput
    realTimeMetrics?: RealTimeMetricCreateNestedManyWithoutNightclubInput
    dataStreams?: DataStreamCreateNestedManyWithoutNightclubInput
    cacheEntries?: CacheEntryCreateNestedManyWithoutNightclubInput
  }

  export type NightclubUncheckedCreateWithoutFloorPlansInput = {
    id?: string
    name: string
    address: string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutNightclubInput
    bracelets?: BraceletUncheckedCreateNestedManyWithoutNightclubInput
    zones?: ZoneUncheckedCreateNestedManyWithoutNightclubInput
    emergencies?: EmergencyUncheckedCreateNestedManyWithoutNightclubInput
    analyticsReports?: AnalyticsReportUncheckedCreateNestedManyWithoutNightclubInput
    predictions?: PredictionUncheckedCreateNestedManyWithoutNightclubInput
    anomalies?: AnomalyUncheckedCreateNestedManyWithoutNightclubInput
    behaviors?: BehaviorAnalysisUncheckedCreateNestedManyWithoutNightclubInput
    realTimeMetrics?: RealTimeMetricUncheckedCreateNestedManyWithoutNightclubInput
    dataStreams?: DataStreamUncheckedCreateNestedManyWithoutNightclubInput
    cacheEntries?: CacheEntryUncheckedCreateNestedManyWithoutNightclubInput
  }

  export type NightclubCreateOrConnectWithoutFloorPlansInput = {
    where: NightclubWhereUniqueInput
    create: XOR<NightclubCreateWithoutFloorPlansInput, NightclubUncheckedCreateWithoutFloorPlansInput>
  }

  export type ZoneCreateWithoutFloorPlanInput = {
    id?: string
    name: string
    coordinates: JsonNullValueInput | InputJsonValue
    capacity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    nightclub: NightclubCreateNestedOneWithoutZonesInput
    alerts?: AlertCreateNestedManyWithoutZoneInput
    emergencies?: EmergencyCreateNestedManyWithoutZoneInput
    sensors?: SensorCreateNestedManyWithoutZoneInput
    anomalies?: AnomalyCreateNestedManyWithoutZoneInput
    behaviors?: BehaviorAnalysisCreateNestedManyWithoutZoneInput
    realTimeMetrics?: RealTimeMetricCreateNestedManyWithoutZoneInput
    predictions?: PredictionCreateNestedManyWithoutZoneInput
  }

  export type ZoneUncheckedCreateWithoutFloorPlanInput = {
    id?: string
    name: string
    coordinates: JsonNullValueInput | InputJsonValue
    capacity: number
    nightclubId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    alerts?: AlertUncheckedCreateNestedManyWithoutZoneInput
    emergencies?: EmergencyUncheckedCreateNestedManyWithoutZoneInput
    sensors?: SensorUncheckedCreateNestedManyWithoutZoneInput
    anomalies?: AnomalyUncheckedCreateNestedManyWithoutZoneInput
    behaviors?: BehaviorAnalysisUncheckedCreateNestedManyWithoutZoneInput
    realTimeMetrics?: RealTimeMetricUncheckedCreateNestedManyWithoutZoneInput
    predictions?: PredictionUncheckedCreateNestedManyWithoutZoneInput
  }

  export type ZoneCreateOrConnectWithoutFloorPlanInput = {
    where: ZoneWhereUniqueInput
    create: XOR<ZoneCreateWithoutFloorPlanInput, ZoneUncheckedCreateWithoutFloorPlanInput>
  }

  export type ZoneCreateManyFloorPlanInputEnvelope = {
    data: ZoneCreateManyFloorPlanInput | ZoneCreateManyFloorPlanInput[]
    skipDuplicates?: boolean
  }

  export type NightclubUpsertWithoutFloorPlansInput = {
    update: XOR<NightclubUpdateWithoutFloorPlansInput, NightclubUncheckedUpdateWithoutFloorPlansInput>
    create: XOR<NightclubCreateWithoutFloorPlansInput, NightclubUncheckedCreateWithoutFloorPlansInput>
    where?: NightclubWhereInput
  }

  export type NightclubUpdateToOneWithWhereWithoutFloorPlansInput = {
    where?: NightclubWhereInput
    data: XOR<NightclubUpdateWithoutFloorPlansInput, NightclubUncheckedUpdateWithoutFloorPlansInput>
  }

  export type NightclubUpdateWithoutFloorPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutNightclubNestedInput
    bracelets?: BraceletUpdateManyWithoutNightclubNestedInput
    zones?: ZoneUpdateManyWithoutNightclubNestedInput
    emergencies?: EmergencyUpdateManyWithoutNightclubNestedInput
    analyticsReports?: AnalyticsReportUpdateManyWithoutNightclubNestedInput
    predictions?: PredictionUpdateManyWithoutNightclubNestedInput
    anomalies?: AnomalyUpdateManyWithoutNightclubNestedInput
    behaviors?: BehaviorAnalysisUpdateManyWithoutNightclubNestedInput
    realTimeMetrics?: RealTimeMetricUpdateManyWithoutNightclubNestedInput
    dataStreams?: DataStreamUpdateManyWithoutNightclubNestedInput
    cacheEntries?: CacheEntryUpdateManyWithoutNightclubNestedInput
  }

  export type NightclubUncheckedUpdateWithoutFloorPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutNightclubNestedInput
    bracelets?: BraceletUncheckedUpdateManyWithoutNightclubNestedInput
    zones?: ZoneUncheckedUpdateManyWithoutNightclubNestedInput
    emergencies?: EmergencyUncheckedUpdateManyWithoutNightclubNestedInput
    analyticsReports?: AnalyticsReportUncheckedUpdateManyWithoutNightclubNestedInput
    predictions?: PredictionUncheckedUpdateManyWithoutNightclubNestedInput
    anomalies?: AnomalyUncheckedUpdateManyWithoutNightclubNestedInput
    behaviors?: BehaviorAnalysisUncheckedUpdateManyWithoutNightclubNestedInput
    realTimeMetrics?: RealTimeMetricUncheckedUpdateManyWithoutNightclubNestedInput
    dataStreams?: DataStreamUncheckedUpdateManyWithoutNightclubNestedInput
    cacheEntries?: CacheEntryUncheckedUpdateManyWithoutNightclubNestedInput
  }

  export type ZoneUpsertWithWhereUniqueWithoutFloorPlanInput = {
    where: ZoneWhereUniqueInput
    update: XOR<ZoneUpdateWithoutFloorPlanInput, ZoneUncheckedUpdateWithoutFloorPlanInput>
    create: XOR<ZoneCreateWithoutFloorPlanInput, ZoneUncheckedCreateWithoutFloorPlanInput>
  }

  export type ZoneUpdateWithWhereUniqueWithoutFloorPlanInput = {
    where: ZoneWhereUniqueInput
    data: XOR<ZoneUpdateWithoutFloorPlanInput, ZoneUncheckedUpdateWithoutFloorPlanInput>
  }

  export type ZoneUpdateManyWithWhereWithoutFloorPlanInput = {
    where: ZoneScalarWhereInput
    data: XOR<ZoneUpdateManyMutationInput, ZoneUncheckedUpdateManyWithoutFloorPlanInput>
  }

  export type FloorPlanCreateWithoutZonesInput = {
    id?: string
    name: string
    imageUrl: string
    createdAt?: Date | string
    updatedAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    nightclub: NightclubCreateNestedOneWithoutFloorPlansInput
  }

  export type FloorPlanUncheckedCreateWithoutZonesInput = {
    id?: string
    name: string
    imageUrl: string
    nightclubId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type FloorPlanCreateOrConnectWithoutZonesInput = {
    where: FloorPlanWhereUniqueInput
    create: XOR<FloorPlanCreateWithoutZonesInput, FloorPlanUncheckedCreateWithoutZonesInput>
  }

  export type NightclubCreateWithoutZonesInput = {
    id?: string
    name: string
    address: string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    floorPlans?: FloorPlanCreateNestedManyWithoutNightclubInput
    users?: UserCreateNestedManyWithoutNightclubInput
    bracelets?: BraceletCreateNestedManyWithoutNightclubInput
    emergencies?: EmergencyCreateNestedManyWithoutNightclubInput
    analyticsReports?: AnalyticsReportCreateNestedManyWithoutNightclubInput
    predictions?: PredictionCreateNestedManyWithoutNightclubInput
    anomalies?: AnomalyCreateNestedManyWithoutNightclubInput
    behaviors?: BehaviorAnalysisCreateNestedManyWithoutNightclubInput
    realTimeMetrics?: RealTimeMetricCreateNestedManyWithoutNightclubInput
    dataStreams?: DataStreamCreateNestedManyWithoutNightclubInput
    cacheEntries?: CacheEntryCreateNestedManyWithoutNightclubInput
  }

  export type NightclubUncheckedCreateWithoutZonesInput = {
    id?: string
    name: string
    address: string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    floorPlans?: FloorPlanUncheckedCreateNestedManyWithoutNightclubInput
    users?: UserUncheckedCreateNestedManyWithoutNightclubInput
    bracelets?: BraceletUncheckedCreateNestedManyWithoutNightclubInput
    emergencies?: EmergencyUncheckedCreateNestedManyWithoutNightclubInput
    analyticsReports?: AnalyticsReportUncheckedCreateNestedManyWithoutNightclubInput
    predictions?: PredictionUncheckedCreateNestedManyWithoutNightclubInput
    anomalies?: AnomalyUncheckedCreateNestedManyWithoutNightclubInput
    behaviors?: BehaviorAnalysisUncheckedCreateNestedManyWithoutNightclubInput
    realTimeMetrics?: RealTimeMetricUncheckedCreateNestedManyWithoutNightclubInput
    dataStreams?: DataStreamUncheckedCreateNestedManyWithoutNightclubInput
    cacheEntries?: CacheEntryUncheckedCreateNestedManyWithoutNightclubInput
  }

  export type NightclubCreateOrConnectWithoutZonesInput = {
    where: NightclubWhereUniqueInput
    create: XOR<NightclubCreateWithoutZonesInput, NightclubUncheckedCreateWithoutZonesInput>
  }

  export type AlertCreateWithoutZoneInput = {
    id?: string
    type: $Enums.AlertType
    status?: $Enums.AlertStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    resolvedAt?: Date | string | null
    bracelet: BraceletCreateNestedOneWithoutAlertsInput
    user: UserCreateNestedOneWithoutAlertsInput
  }

  export type AlertUncheckedCreateWithoutZoneInput = {
    id?: string
    type: $Enums.AlertType
    status?: $Enums.AlertStatus
    braceletId: string
    userId: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    resolvedAt?: Date | string | null
  }

  export type AlertCreateOrConnectWithoutZoneInput = {
    where: AlertWhereUniqueInput
    create: XOR<AlertCreateWithoutZoneInput, AlertUncheckedCreateWithoutZoneInput>
  }

  export type AlertCreateManyZoneInputEnvelope = {
    data: AlertCreateManyZoneInput | AlertCreateManyZoneInput[]
    skipDuplicates?: boolean
  }

  export type EmergencyCreateWithoutZoneInput = {
    id?: string
    status?: $Enums.EmergencyStatus
    responseTime?: number | null
    escalationDetails?: NullableJsonNullValueInput | InputJsonValue
    resolutionDetails?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    resolvedAt?: Date | string | null
    bracelet: BraceletCreateNestedOneWithoutEmergenciesInput
    nightclub: NightclubCreateNestedOneWithoutEmergenciesInput
    responder?: UserCreateNestedOneWithoutEmergenciesInput
  }

  export type EmergencyUncheckedCreateWithoutZoneInput = {
    id?: string
    status?: $Enums.EmergencyStatus
    braceletId: string
    nightclubId: string
    responderId?: string | null
    responseTime?: number | null
    escalationDetails?: NullableJsonNullValueInput | InputJsonValue
    resolutionDetails?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    resolvedAt?: Date | string | null
  }

  export type EmergencyCreateOrConnectWithoutZoneInput = {
    where: EmergencyWhereUniqueInput
    create: XOR<EmergencyCreateWithoutZoneInput, EmergencyUncheckedCreateWithoutZoneInput>
  }

  export type EmergencyCreateManyZoneInputEnvelope = {
    data: EmergencyCreateManyZoneInput | EmergencyCreateManyZoneInput[]
    skipDuplicates?: boolean
  }

  export type SensorCreateWithoutZoneInput = {
    id?: string
    type: $Enums.SensorType
    status?: $Enums.SensorStatus
    data?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    lastReading?: Date | string | null
  }

  export type SensorUncheckedCreateWithoutZoneInput = {
    id?: string
    type: $Enums.SensorType
    status?: $Enums.SensorStatus
    data?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    lastReading?: Date | string | null
  }

  export type SensorCreateOrConnectWithoutZoneInput = {
    where: SensorWhereUniqueInput
    create: XOR<SensorCreateWithoutZoneInput, SensorUncheckedCreateWithoutZoneInput>
  }

  export type SensorCreateManyZoneInputEnvelope = {
    data: SensorCreateManyZoneInput | SensorCreateManyZoneInput[]
    skipDuplicates?: boolean
  }

  export type AnomalyCreateWithoutZoneInput = {
    id?: string
    type: string
    severity: string
    status: string
    description: string
    timestamp?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    nightclub: NightclubCreateNestedOneWithoutAnomaliesInput
    model: AIModelCreateNestedOneWithoutAnomaliesInput
  }

  export type AnomalyUncheckedCreateWithoutZoneInput = {
    id?: string
    type: string
    severity: string
    status: string
    description: string
    timestamp?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    nightclubId: string
    modelId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnomalyCreateOrConnectWithoutZoneInput = {
    where: AnomalyWhereUniqueInput
    create: XOR<AnomalyCreateWithoutZoneInput, AnomalyUncheckedCreateWithoutZoneInput>
  }

  export type AnomalyCreateManyZoneInputEnvelope = {
    data: AnomalyCreateManyZoneInput | AnomalyCreateManyZoneInput[]
    skipDuplicates?: boolean
  }

  export type BehaviorAnalysisCreateWithoutZoneInput = {
    id?: string
    type: string
    timestamp?: Date | string
    insights: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    nightclub: NightclubCreateNestedOneWithoutBehaviorsInput
    model: AIModelCreateNestedOneWithoutBehaviorAnalysesInput
  }

  export type BehaviorAnalysisUncheckedCreateWithoutZoneInput = {
    id?: string
    type: string
    timestamp?: Date | string
    insights: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    nightclubId: string
    modelId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BehaviorAnalysisCreateOrConnectWithoutZoneInput = {
    where: BehaviorAnalysisWhereUniqueInput
    create: XOR<BehaviorAnalysisCreateWithoutZoneInput, BehaviorAnalysisUncheckedCreateWithoutZoneInput>
  }

  export type BehaviorAnalysisCreateManyZoneInputEnvelope = {
    data: BehaviorAnalysisCreateManyZoneInput | BehaviorAnalysisCreateManyZoneInput[]
    skipDuplicates?: boolean
  }

  export type RealTimeMetricCreateWithoutZoneInput = {
    id?: string
    type: string
    value: number
    timestamp?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    nightclub: NightclubCreateNestedOneWithoutRealTimeMetricsInput
  }

  export type RealTimeMetricUncheckedCreateWithoutZoneInput = {
    id?: string
    type: string
    value: number
    timestamp?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    nightclubId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RealTimeMetricCreateOrConnectWithoutZoneInput = {
    where: RealTimeMetricWhereUniqueInput
    create: XOR<RealTimeMetricCreateWithoutZoneInput, RealTimeMetricUncheckedCreateWithoutZoneInput>
  }

  export type RealTimeMetricCreateManyZoneInputEnvelope = {
    data: RealTimeMetricCreateManyZoneInput | RealTimeMetricCreateManyZoneInput[]
    skipDuplicates?: boolean
  }

  export type PredictionCreateWithoutZoneInput = {
    id?: string
    type: string
    timestamp?: Date | string
    value: number
    confidence: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    nightclub: NightclubCreateNestedOneWithoutPredictionsInput
    model: AIModelCreateNestedOneWithoutPredictionsInput
  }

  export type PredictionUncheckedCreateWithoutZoneInput = {
    id?: string
    type: string
    timestamp?: Date | string
    value: number
    confidence: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    nightclubId: string
    modelId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PredictionCreateOrConnectWithoutZoneInput = {
    where: PredictionWhereUniqueInput
    create: XOR<PredictionCreateWithoutZoneInput, PredictionUncheckedCreateWithoutZoneInput>
  }

  export type PredictionCreateManyZoneInputEnvelope = {
    data: PredictionCreateManyZoneInput | PredictionCreateManyZoneInput[]
    skipDuplicates?: boolean
  }

  export type FloorPlanUpsertWithoutZonesInput = {
    update: XOR<FloorPlanUpdateWithoutZonesInput, FloorPlanUncheckedUpdateWithoutZonesInput>
    create: XOR<FloorPlanCreateWithoutZonesInput, FloorPlanUncheckedCreateWithoutZonesInput>
    where?: FloorPlanWhereInput
  }

  export type FloorPlanUpdateToOneWithWhereWithoutZonesInput = {
    where?: FloorPlanWhereInput
    data: XOR<FloorPlanUpdateWithoutZonesInput, FloorPlanUncheckedUpdateWithoutZonesInput>
  }

  export type FloorPlanUpdateWithoutZonesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    nightclub?: NightclubUpdateOneRequiredWithoutFloorPlansNestedInput
  }

  export type FloorPlanUncheckedUpdateWithoutZonesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    nightclubId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type NightclubUpsertWithoutZonesInput = {
    update: XOR<NightclubUpdateWithoutZonesInput, NightclubUncheckedUpdateWithoutZonesInput>
    create: XOR<NightclubCreateWithoutZonesInput, NightclubUncheckedCreateWithoutZonesInput>
    where?: NightclubWhereInput
  }

  export type NightclubUpdateToOneWithWhereWithoutZonesInput = {
    where?: NightclubWhereInput
    data: XOR<NightclubUpdateWithoutZonesInput, NightclubUncheckedUpdateWithoutZonesInput>
  }

  export type NightclubUpdateWithoutZonesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    floorPlans?: FloorPlanUpdateManyWithoutNightclubNestedInput
    users?: UserUpdateManyWithoutNightclubNestedInput
    bracelets?: BraceletUpdateManyWithoutNightclubNestedInput
    emergencies?: EmergencyUpdateManyWithoutNightclubNestedInput
    analyticsReports?: AnalyticsReportUpdateManyWithoutNightclubNestedInput
    predictions?: PredictionUpdateManyWithoutNightclubNestedInput
    anomalies?: AnomalyUpdateManyWithoutNightclubNestedInput
    behaviors?: BehaviorAnalysisUpdateManyWithoutNightclubNestedInput
    realTimeMetrics?: RealTimeMetricUpdateManyWithoutNightclubNestedInput
    dataStreams?: DataStreamUpdateManyWithoutNightclubNestedInput
    cacheEntries?: CacheEntryUpdateManyWithoutNightclubNestedInput
  }

  export type NightclubUncheckedUpdateWithoutZonesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    floorPlans?: FloorPlanUncheckedUpdateManyWithoutNightclubNestedInput
    users?: UserUncheckedUpdateManyWithoutNightclubNestedInput
    bracelets?: BraceletUncheckedUpdateManyWithoutNightclubNestedInput
    emergencies?: EmergencyUncheckedUpdateManyWithoutNightclubNestedInput
    analyticsReports?: AnalyticsReportUncheckedUpdateManyWithoutNightclubNestedInput
    predictions?: PredictionUncheckedUpdateManyWithoutNightclubNestedInput
    anomalies?: AnomalyUncheckedUpdateManyWithoutNightclubNestedInput
    behaviors?: BehaviorAnalysisUncheckedUpdateManyWithoutNightclubNestedInput
    realTimeMetrics?: RealTimeMetricUncheckedUpdateManyWithoutNightclubNestedInput
    dataStreams?: DataStreamUncheckedUpdateManyWithoutNightclubNestedInput
    cacheEntries?: CacheEntryUncheckedUpdateManyWithoutNightclubNestedInput
  }

  export type AlertUpsertWithWhereUniqueWithoutZoneInput = {
    where: AlertWhereUniqueInput
    update: XOR<AlertUpdateWithoutZoneInput, AlertUncheckedUpdateWithoutZoneInput>
    create: XOR<AlertCreateWithoutZoneInput, AlertUncheckedCreateWithoutZoneInput>
  }

  export type AlertUpdateWithWhereUniqueWithoutZoneInput = {
    where: AlertWhereUniqueInput
    data: XOR<AlertUpdateWithoutZoneInput, AlertUncheckedUpdateWithoutZoneInput>
  }

  export type AlertUpdateManyWithWhereWithoutZoneInput = {
    where: AlertScalarWhereInput
    data: XOR<AlertUpdateManyMutationInput, AlertUncheckedUpdateManyWithoutZoneInput>
  }

  export type EmergencyUpsertWithWhereUniqueWithoutZoneInput = {
    where: EmergencyWhereUniqueInput
    update: XOR<EmergencyUpdateWithoutZoneInput, EmergencyUncheckedUpdateWithoutZoneInput>
    create: XOR<EmergencyCreateWithoutZoneInput, EmergencyUncheckedCreateWithoutZoneInput>
  }

  export type EmergencyUpdateWithWhereUniqueWithoutZoneInput = {
    where: EmergencyWhereUniqueInput
    data: XOR<EmergencyUpdateWithoutZoneInput, EmergencyUncheckedUpdateWithoutZoneInput>
  }

  export type EmergencyUpdateManyWithWhereWithoutZoneInput = {
    where: EmergencyScalarWhereInput
    data: XOR<EmergencyUpdateManyMutationInput, EmergencyUncheckedUpdateManyWithoutZoneInput>
  }

  export type SensorUpsertWithWhereUniqueWithoutZoneInput = {
    where: SensorWhereUniqueInput
    update: XOR<SensorUpdateWithoutZoneInput, SensorUncheckedUpdateWithoutZoneInput>
    create: XOR<SensorCreateWithoutZoneInput, SensorUncheckedCreateWithoutZoneInput>
  }

  export type SensorUpdateWithWhereUniqueWithoutZoneInput = {
    where: SensorWhereUniqueInput
    data: XOR<SensorUpdateWithoutZoneInput, SensorUncheckedUpdateWithoutZoneInput>
  }

  export type SensorUpdateManyWithWhereWithoutZoneInput = {
    where: SensorScalarWhereInput
    data: XOR<SensorUpdateManyMutationInput, SensorUncheckedUpdateManyWithoutZoneInput>
  }

  export type SensorScalarWhereInput = {
    AND?: SensorScalarWhereInput | SensorScalarWhereInput[]
    OR?: SensorScalarWhereInput[]
    NOT?: SensorScalarWhereInput | SensorScalarWhereInput[]
    id?: StringFilter<"Sensor"> | string
    type?: EnumSensorTypeFilter<"Sensor"> | $Enums.SensorType
    status?: EnumSensorStatusFilter<"Sensor"> | $Enums.SensorStatus
    zoneId?: StringFilter<"Sensor"> | string
    data?: JsonNullableFilter<"Sensor">
    metadata?: JsonNullableFilter<"Sensor">
    createdAt?: DateTimeFilter<"Sensor"> | Date | string
    updatedAt?: DateTimeFilter<"Sensor"> | Date | string
    lastReading?: DateTimeNullableFilter<"Sensor"> | Date | string | null
  }

  export type AnomalyUpsertWithWhereUniqueWithoutZoneInput = {
    where: AnomalyWhereUniqueInput
    update: XOR<AnomalyUpdateWithoutZoneInput, AnomalyUncheckedUpdateWithoutZoneInput>
    create: XOR<AnomalyCreateWithoutZoneInput, AnomalyUncheckedCreateWithoutZoneInput>
  }

  export type AnomalyUpdateWithWhereUniqueWithoutZoneInput = {
    where: AnomalyWhereUniqueInput
    data: XOR<AnomalyUpdateWithoutZoneInput, AnomalyUncheckedUpdateWithoutZoneInput>
  }

  export type AnomalyUpdateManyWithWhereWithoutZoneInput = {
    where: AnomalyScalarWhereInput
    data: XOR<AnomalyUpdateManyMutationInput, AnomalyUncheckedUpdateManyWithoutZoneInput>
  }

  export type BehaviorAnalysisUpsertWithWhereUniqueWithoutZoneInput = {
    where: BehaviorAnalysisWhereUniqueInput
    update: XOR<BehaviorAnalysisUpdateWithoutZoneInput, BehaviorAnalysisUncheckedUpdateWithoutZoneInput>
    create: XOR<BehaviorAnalysisCreateWithoutZoneInput, BehaviorAnalysisUncheckedCreateWithoutZoneInput>
  }

  export type BehaviorAnalysisUpdateWithWhereUniqueWithoutZoneInput = {
    where: BehaviorAnalysisWhereUniqueInput
    data: XOR<BehaviorAnalysisUpdateWithoutZoneInput, BehaviorAnalysisUncheckedUpdateWithoutZoneInput>
  }

  export type BehaviorAnalysisUpdateManyWithWhereWithoutZoneInput = {
    where: BehaviorAnalysisScalarWhereInput
    data: XOR<BehaviorAnalysisUpdateManyMutationInput, BehaviorAnalysisUncheckedUpdateManyWithoutZoneInput>
  }

  export type RealTimeMetricUpsertWithWhereUniqueWithoutZoneInput = {
    where: RealTimeMetricWhereUniqueInput
    update: XOR<RealTimeMetricUpdateWithoutZoneInput, RealTimeMetricUncheckedUpdateWithoutZoneInput>
    create: XOR<RealTimeMetricCreateWithoutZoneInput, RealTimeMetricUncheckedCreateWithoutZoneInput>
  }

  export type RealTimeMetricUpdateWithWhereUniqueWithoutZoneInput = {
    where: RealTimeMetricWhereUniqueInput
    data: XOR<RealTimeMetricUpdateWithoutZoneInput, RealTimeMetricUncheckedUpdateWithoutZoneInput>
  }

  export type RealTimeMetricUpdateManyWithWhereWithoutZoneInput = {
    where: RealTimeMetricScalarWhereInput
    data: XOR<RealTimeMetricUpdateManyMutationInput, RealTimeMetricUncheckedUpdateManyWithoutZoneInput>
  }

  export type PredictionUpsertWithWhereUniqueWithoutZoneInput = {
    where: PredictionWhereUniqueInput
    update: XOR<PredictionUpdateWithoutZoneInput, PredictionUncheckedUpdateWithoutZoneInput>
    create: XOR<PredictionCreateWithoutZoneInput, PredictionUncheckedCreateWithoutZoneInput>
  }

  export type PredictionUpdateWithWhereUniqueWithoutZoneInput = {
    where: PredictionWhereUniqueInput
    data: XOR<PredictionUpdateWithoutZoneInput, PredictionUncheckedUpdateWithoutZoneInput>
  }

  export type PredictionUpdateManyWithWhereWithoutZoneInput = {
    where: PredictionScalarWhereInput
    data: XOR<PredictionUpdateManyMutationInput, PredictionUncheckedUpdateManyWithoutZoneInput>
  }

  export type NightclubCreateWithoutBraceletsInput = {
    id?: string
    name: string
    address: string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    floorPlans?: FloorPlanCreateNestedManyWithoutNightclubInput
    users?: UserCreateNestedManyWithoutNightclubInput
    zones?: ZoneCreateNestedManyWithoutNightclubInput
    emergencies?: EmergencyCreateNestedManyWithoutNightclubInput
    analyticsReports?: AnalyticsReportCreateNestedManyWithoutNightclubInput
    predictions?: PredictionCreateNestedManyWithoutNightclubInput
    anomalies?: AnomalyCreateNestedManyWithoutNightclubInput
    behaviors?: BehaviorAnalysisCreateNestedManyWithoutNightclubInput
    realTimeMetrics?: RealTimeMetricCreateNestedManyWithoutNightclubInput
    dataStreams?: DataStreamCreateNestedManyWithoutNightclubInput
    cacheEntries?: CacheEntryCreateNestedManyWithoutNightclubInput
  }

  export type NightclubUncheckedCreateWithoutBraceletsInput = {
    id?: string
    name: string
    address: string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    floorPlans?: FloorPlanUncheckedCreateNestedManyWithoutNightclubInput
    users?: UserUncheckedCreateNestedManyWithoutNightclubInput
    zones?: ZoneUncheckedCreateNestedManyWithoutNightclubInput
    emergencies?: EmergencyUncheckedCreateNestedManyWithoutNightclubInput
    analyticsReports?: AnalyticsReportUncheckedCreateNestedManyWithoutNightclubInput
    predictions?: PredictionUncheckedCreateNestedManyWithoutNightclubInput
    anomalies?: AnomalyUncheckedCreateNestedManyWithoutNightclubInput
    behaviors?: BehaviorAnalysisUncheckedCreateNestedManyWithoutNightclubInput
    realTimeMetrics?: RealTimeMetricUncheckedCreateNestedManyWithoutNightclubInput
    dataStreams?: DataStreamUncheckedCreateNestedManyWithoutNightclubInput
    cacheEntries?: CacheEntryUncheckedCreateNestedManyWithoutNightclubInput
  }

  export type NightclubCreateOrConnectWithoutBraceletsInput = {
    where: NightclubWhereUniqueInput
    create: XOR<NightclubCreateWithoutBraceletsInput, NightclubUncheckedCreateWithoutBraceletsInput>
  }

  export type AlertCreateWithoutBraceletInput = {
    id?: string
    type: $Enums.AlertType
    status?: $Enums.AlertStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    resolvedAt?: Date | string | null
    user: UserCreateNestedOneWithoutAlertsInput
    zone: ZoneCreateNestedOneWithoutAlertsInput
  }

  export type AlertUncheckedCreateWithoutBraceletInput = {
    id?: string
    type: $Enums.AlertType
    status?: $Enums.AlertStatus
    userId: string
    zoneId: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    resolvedAt?: Date | string | null
  }

  export type AlertCreateOrConnectWithoutBraceletInput = {
    where: AlertWhereUniqueInput
    create: XOR<AlertCreateWithoutBraceletInput, AlertUncheckedCreateWithoutBraceletInput>
  }

  export type AlertCreateManyBraceletInputEnvelope = {
    data: AlertCreateManyBraceletInput | AlertCreateManyBraceletInput[]
    skipDuplicates?: boolean
  }

  export type EmergencyCreateWithoutBraceletInput = {
    id?: string
    status?: $Enums.EmergencyStatus
    responseTime?: number | null
    escalationDetails?: NullableJsonNullValueInput | InputJsonValue
    resolutionDetails?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    resolvedAt?: Date | string | null
    zone: ZoneCreateNestedOneWithoutEmergenciesInput
    nightclub: NightclubCreateNestedOneWithoutEmergenciesInput
    responder?: UserCreateNestedOneWithoutEmergenciesInput
  }

  export type EmergencyUncheckedCreateWithoutBraceletInput = {
    id?: string
    status?: $Enums.EmergencyStatus
    zoneId: string
    nightclubId: string
    responderId?: string | null
    responseTime?: number | null
    escalationDetails?: NullableJsonNullValueInput | InputJsonValue
    resolutionDetails?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    resolvedAt?: Date | string | null
  }

  export type EmergencyCreateOrConnectWithoutBraceletInput = {
    where: EmergencyWhereUniqueInput
    create: XOR<EmergencyCreateWithoutBraceletInput, EmergencyUncheckedCreateWithoutBraceletInput>
  }

  export type EmergencyCreateManyBraceletInputEnvelope = {
    data: EmergencyCreateManyBraceletInput | EmergencyCreateManyBraceletInput[]
    skipDuplicates?: boolean
  }

  export type NightclubUpsertWithoutBraceletsInput = {
    update: XOR<NightclubUpdateWithoutBraceletsInput, NightclubUncheckedUpdateWithoutBraceletsInput>
    create: XOR<NightclubCreateWithoutBraceletsInput, NightclubUncheckedCreateWithoutBraceletsInput>
    where?: NightclubWhereInput
  }

  export type NightclubUpdateToOneWithWhereWithoutBraceletsInput = {
    where?: NightclubWhereInput
    data: XOR<NightclubUpdateWithoutBraceletsInput, NightclubUncheckedUpdateWithoutBraceletsInput>
  }

  export type NightclubUpdateWithoutBraceletsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    floorPlans?: FloorPlanUpdateManyWithoutNightclubNestedInput
    users?: UserUpdateManyWithoutNightclubNestedInput
    zones?: ZoneUpdateManyWithoutNightclubNestedInput
    emergencies?: EmergencyUpdateManyWithoutNightclubNestedInput
    analyticsReports?: AnalyticsReportUpdateManyWithoutNightclubNestedInput
    predictions?: PredictionUpdateManyWithoutNightclubNestedInput
    anomalies?: AnomalyUpdateManyWithoutNightclubNestedInput
    behaviors?: BehaviorAnalysisUpdateManyWithoutNightclubNestedInput
    realTimeMetrics?: RealTimeMetricUpdateManyWithoutNightclubNestedInput
    dataStreams?: DataStreamUpdateManyWithoutNightclubNestedInput
    cacheEntries?: CacheEntryUpdateManyWithoutNightclubNestedInput
  }

  export type NightclubUncheckedUpdateWithoutBraceletsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    floorPlans?: FloorPlanUncheckedUpdateManyWithoutNightclubNestedInput
    users?: UserUncheckedUpdateManyWithoutNightclubNestedInput
    zones?: ZoneUncheckedUpdateManyWithoutNightclubNestedInput
    emergencies?: EmergencyUncheckedUpdateManyWithoutNightclubNestedInput
    analyticsReports?: AnalyticsReportUncheckedUpdateManyWithoutNightclubNestedInput
    predictions?: PredictionUncheckedUpdateManyWithoutNightclubNestedInput
    anomalies?: AnomalyUncheckedUpdateManyWithoutNightclubNestedInput
    behaviors?: BehaviorAnalysisUncheckedUpdateManyWithoutNightclubNestedInput
    realTimeMetrics?: RealTimeMetricUncheckedUpdateManyWithoutNightclubNestedInput
    dataStreams?: DataStreamUncheckedUpdateManyWithoutNightclubNestedInput
    cacheEntries?: CacheEntryUncheckedUpdateManyWithoutNightclubNestedInput
  }

  export type AlertUpsertWithWhereUniqueWithoutBraceletInput = {
    where: AlertWhereUniqueInput
    update: XOR<AlertUpdateWithoutBraceletInput, AlertUncheckedUpdateWithoutBraceletInput>
    create: XOR<AlertCreateWithoutBraceletInput, AlertUncheckedCreateWithoutBraceletInput>
  }

  export type AlertUpdateWithWhereUniqueWithoutBraceletInput = {
    where: AlertWhereUniqueInput
    data: XOR<AlertUpdateWithoutBraceletInput, AlertUncheckedUpdateWithoutBraceletInput>
  }

  export type AlertUpdateManyWithWhereWithoutBraceletInput = {
    where: AlertScalarWhereInput
    data: XOR<AlertUpdateManyMutationInput, AlertUncheckedUpdateManyWithoutBraceletInput>
  }

  export type EmergencyUpsertWithWhereUniqueWithoutBraceletInput = {
    where: EmergencyWhereUniqueInput
    update: XOR<EmergencyUpdateWithoutBraceletInput, EmergencyUncheckedUpdateWithoutBraceletInput>
    create: XOR<EmergencyCreateWithoutBraceletInput, EmergencyUncheckedCreateWithoutBraceletInput>
  }

  export type EmergencyUpdateWithWhereUniqueWithoutBraceletInput = {
    where: EmergencyWhereUniqueInput
    data: XOR<EmergencyUpdateWithoutBraceletInput, EmergencyUncheckedUpdateWithoutBraceletInput>
  }

  export type EmergencyUpdateManyWithWhereWithoutBraceletInput = {
    where: EmergencyScalarWhereInput
    data: XOR<EmergencyUpdateManyMutationInput, EmergencyUncheckedUpdateManyWithoutBraceletInput>
  }

  export type BraceletCreateWithoutAlertsInput = {
    id?: string
    deviceId: string
    batteryLevel?: number | null
    status?: $Enums.BraceletStatus
    lastSeen?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    nightclub: NightclubCreateNestedOneWithoutBraceletsInput
    emergencies?: EmergencyCreateNestedManyWithoutBraceletInput
  }

  export type BraceletUncheckedCreateWithoutAlertsInput = {
    id?: string
    deviceId: string
    batteryLevel?: number | null
    status?: $Enums.BraceletStatus
    lastSeen?: Date | string | null
    nightclubId: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    emergencies?: EmergencyUncheckedCreateNestedManyWithoutBraceletInput
  }

  export type BraceletCreateOrConnectWithoutAlertsInput = {
    where: BraceletWhereUniqueInput
    create: XOR<BraceletCreateWithoutAlertsInput, BraceletUncheckedCreateWithoutAlertsInput>
  }

  export type UserCreateWithoutAlertsInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    deviceId?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    lastLocation?: NullableJsonNullValueInput | InputJsonValue
    nightclub?: NightclubCreateNestedOneWithoutUsersInput
    emergencies?: EmergencyCreateNestedManyWithoutResponderInput
  }

  export type UserUncheckedCreateWithoutAlertsInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    deviceId?: string | null
    nightclubId?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    lastLocation?: NullableJsonNullValueInput | InputJsonValue
    emergencies?: EmergencyUncheckedCreateNestedManyWithoutResponderInput
  }

  export type UserCreateOrConnectWithoutAlertsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAlertsInput, UserUncheckedCreateWithoutAlertsInput>
  }

  export type ZoneCreateWithoutAlertsInput = {
    id?: string
    name: string
    coordinates: JsonNullValueInput | InputJsonValue
    capacity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    floorPlan: FloorPlanCreateNestedOneWithoutZonesInput
    nightclub: NightclubCreateNestedOneWithoutZonesInput
    emergencies?: EmergencyCreateNestedManyWithoutZoneInput
    sensors?: SensorCreateNestedManyWithoutZoneInput
    anomalies?: AnomalyCreateNestedManyWithoutZoneInput
    behaviors?: BehaviorAnalysisCreateNestedManyWithoutZoneInput
    realTimeMetrics?: RealTimeMetricCreateNestedManyWithoutZoneInput
    predictions?: PredictionCreateNestedManyWithoutZoneInput
  }

  export type ZoneUncheckedCreateWithoutAlertsInput = {
    id?: string
    name: string
    coordinates: JsonNullValueInput | InputJsonValue
    capacity: number
    floorPlanId: string
    nightclubId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    emergencies?: EmergencyUncheckedCreateNestedManyWithoutZoneInput
    sensors?: SensorUncheckedCreateNestedManyWithoutZoneInput
    anomalies?: AnomalyUncheckedCreateNestedManyWithoutZoneInput
    behaviors?: BehaviorAnalysisUncheckedCreateNestedManyWithoutZoneInput
    realTimeMetrics?: RealTimeMetricUncheckedCreateNestedManyWithoutZoneInput
    predictions?: PredictionUncheckedCreateNestedManyWithoutZoneInput
  }

  export type ZoneCreateOrConnectWithoutAlertsInput = {
    where: ZoneWhereUniqueInput
    create: XOR<ZoneCreateWithoutAlertsInput, ZoneUncheckedCreateWithoutAlertsInput>
  }

  export type BraceletUpsertWithoutAlertsInput = {
    update: XOR<BraceletUpdateWithoutAlertsInput, BraceletUncheckedUpdateWithoutAlertsInput>
    create: XOR<BraceletCreateWithoutAlertsInput, BraceletUncheckedCreateWithoutAlertsInput>
    where?: BraceletWhereInput
  }

  export type BraceletUpdateToOneWithWhereWithoutAlertsInput = {
    where?: BraceletWhereInput
    data: XOR<BraceletUpdateWithoutAlertsInput, BraceletUncheckedUpdateWithoutAlertsInput>
  }

  export type BraceletUpdateWithoutAlertsInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    batteryLevel?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumBraceletStatusFieldUpdateOperationsInput | $Enums.BraceletStatus
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nightclub?: NightclubUpdateOneRequiredWithoutBraceletsNestedInput
    emergencies?: EmergencyUpdateManyWithoutBraceletNestedInput
  }

  export type BraceletUncheckedUpdateWithoutAlertsInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    batteryLevel?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumBraceletStatusFieldUpdateOperationsInput | $Enums.BraceletStatus
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nightclubId?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emergencies?: EmergencyUncheckedUpdateManyWithoutBraceletNestedInput
  }

  export type UserUpsertWithoutAlertsInput = {
    update: XOR<UserUpdateWithoutAlertsInput, UserUncheckedUpdateWithoutAlertsInput>
    create: XOR<UserCreateWithoutAlertsInput, UserUncheckedCreateWithoutAlertsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAlertsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAlertsInput, UserUncheckedUpdateWithoutAlertsInput>
  }

  export type UserUpdateWithoutAlertsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLocation?: NullableJsonNullValueInput | InputJsonValue
    nightclub?: NightclubUpdateOneWithoutUsersNestedInput
    emergencies?: EmergencyUpdateManyWithoutResponderNestedInput
  }

  export type UserUncheckedUpdateWithoutAlertsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    nightclubId?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLocation?: NullableJsonNullValueInput | InputJsonValue
    emergencies?: EmergencyUncheckedUpdateManyWithoutResponderNestedInput
  }

  export type ZoneUpsertWithoutAlertsInput = {
    update: XOR<ZoneUpdateWithoutAlertsInput, ZoneUncheckedUpdateWithoutAlertsInput>
    create: XOR<ZoneCreateWithoutAlertsInput, ZoneUncheckedCreateWithoutAlertsInput>
    where?: ZoneWhereInput
  }

  export type ZoneUpdateToOneWithWhereWithoutAlertsInput = {
    where?: ZoneWhereInput
    data: XOR<ZoneUpdateWithoutAlertsInput, ZoneUncheckedUpdateWithoutAlertsInput>
  }

  export type ZoneUpdateWithoutAlertsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    coordinates?: JsonNullValueInput | InputJsonValue
    capacity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    floorPlan?: FloorPlanUpdateOneRequiredWithoutZonesNestedInput
    nightclub?: NightclubUpdateOneRequiredWithoutZonesNestedInput
    emergencies?: EmergencyUpdateManyWithoutZoneNestedInput
    sensors?: SensorUpdateManyWithoutZoneNestedInput
    anomalies?: AnomalyUpdateManyWithoutZoneNestedInput
    behaviors?: BehaviorAnalysisUpdateManyWithoutZoneNestedInput
    realTimeMetrics?: RealTimeMetricUpdateManyWithoutZoneNestedInput
    predictions?: PredictionUpdateManyWithoutZoneNestedInput
  }

  export type ZoneUncheckedUpdateWithoutAlertsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    coordinates?: JsonNullValueInput | InputJsonValue
    capacity?: IntFieldUpdateOperationsInput | number
    floorPlanId?: StringFieldUpdateOperationsInput | string
    nightclubId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    emergencies?: EmergencyUncheckedUpdateManyWithoutZoneNestedInput
    sensors?: SensorUncheckedUpdateManyWithoutZoneNestedInput
    anomalies?: AnomalyUncheckedUpdateManyWithoutZoneNestedInput
    behaviors?: BehaviorAnalysisUncheckedUpdateManyWithoutZoneNestedInput
    realTimeMetrics?: RealTimeMetricUncheckedUpdateManyWithoutZoneNestedInput
    predictions?: PredictionUncheckedUpdateManyWithoutZoneNestedInput
  }

  export type BraceletCreateWithoutEmergenciesInput = {
    id?: string
    deviceId: string
    batteryLevel?: number | null
    status?: $Enums.BraceletStatus
    lastSeen?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    nightclub: NightclubCreateNestedOneWithoutBraceletsInput
    alerts?: AlertCreateNestedManyWithoutBraceletInput
  }

  export type BraceletUncheckedCreateWithoutEmergenciesInput = {
    id?: string
    deviceId: string
    batteryLevel?: number | null
    status?: $Enums.BraceletStatus
    lastSeen?: Date | string | null
    nightclubId: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    alerts?: AlertUncheckedCreateNestedManyWithoutBraceletInput
  }

  export type BraceletCreateOrConnectWithoutEmergenciesInput = {
    where: BraceletWhereUniqueInput
    create: XOR<BraceletCreateWithoutEmergenciesInput, BraceletUncheckedCreateWithoutEmergenciesInput>
  }

  export type ZoneCreateWithoutEmergenciesInput = {
    id?: string
    name: string
    coordinates: JsonNullValueInput | InputJsonValue
    capacity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    floorPlan: FloorPlanCreateNestedOneWithoutZonesInput
    nightclub: NightclubCreateNestedOneWithoutZonesInput
    alerts?: AlertCreateNestedManyWithoutZoneInput
    sensors?: SensorCreateNestedManyWithoutZoneInput
    anomalies?: AnomalyCreateNestedManyWithoutZoneInput
    behaviors?: BehaviorAnalysisCreateNestedManyWithoutZoneInput
    realTimeMetrics?: RealTimeMetricCreateNestedManyWithoutZoneInput
    predictions?: PredictionCreateNestedManyWithoutZoneInput
  }

  export type ZoneUncheckedCreateWithoutEmergenciesInput = {
    id?: string
    name: string
    coordinates: JsonNullValueInput | InputJsonValue
    capacity: number
    floorPlanId: string
    nightclubId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    alerts?: AlertUncheckedCreateNestedManyWithoutZoneInput
    sensors?: SensorUncheckedCreateNestedManyWithoutZoneInput
    anomalies?: AnomalyUncheckedCreateNestedManyWithoutZoneInput
    behaviors?: BehaviorAnalysisUncheckedCreateNestedManyWithoutZoneInput
    realTimeMetrics?: RealTimeMetricUncheckedCreateNestedManyWithoutZoneInput
    predictions?: PredictionUncheckedCreateNestedManyWithoutZoneInput
  }

  export type ZoneCreateOrConnectWithoutEmergenciesInput = {
    where: ZoneWhereUniqueInput
    create: XOR<ZoneCreateWithoutEmergenciesInput, ZoneUncheckedCreateWithoutEmergenciesInput>
  }

  export type NightclubCreateWithoutEmergenciesInput = {
    id?: string
    name: string
    address: string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    floorPlans?: FloorPlanCreateNestedManyWithoutNightclubInput
    users?: UserCreateNestedManyWithoutNightclubInput
    bracelets?: BraceletCreateNestedManyWithoutNightclubInput
    zones?: ZoneCreateNestedManyWithoutNightclubInput
    analyticsReports?: AnalyticsReportCreateNestedManyWithoutNightclubInput
    predictions?: PredictionCreateNestedManyWithoutNightclubInput
    anomalies?: AnomalyCreateNestedManyWithoutNightclubInput
    behaviors?: BehaviorAnalysisCreateNestedManyWithoutNightclubInput
    realTimeMetrics?: RealTimeMetricCreateNestedManyWithoutNightclubInput
    dataStreams?: DataStreamCreateNestedManyWithoutNightclubInput
    cacheEntries?: CacheEntryCreateNestedManyWithoutNightclubInput
  }

  export type NightclubUncheckedCreateWithoutEmergenciesInput = {
    id?: string
    name: string
    address: string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    floorPlans?: FloorPlanUncheckedCreateNestedManyWithoutNightclubInput
    users?: UserUncheckedCreateNestedManyWithoutNightclubInput
    bracelets?: BraceletUncheckedCreateNestedManyWithoutNightclubInput
    zones?: ZoneUncheckedCreateNestedManyWithoutNightclubInput
    analyticsReports?: AnalyticsReportUncheckedCreateNestedManyWithoutNightclubInput
    predictions?: PredictionUncheckedCreateNestedManyWithoutNightclubInput
    anomalies?: AnomalyUncheckedCreateNestedManyWithoutNightclubInput
    behaviors?: BehaviorAnalysisUncheckedCreateNestedManyWithoutNightclubInput
    realTimeMetrics?: RealTimeMetricUncheckedCreateNestedManyWithoutNightclubInput
    dataStreams?: DataStreamUncheckedCreateNestedManyWithoutNightclubInput
    cacheEntries?: CacheEntryUncheckedCreateNestedManyWithoutNightclubInput
  }

  export type NightclubCreateOrConnectWithoutEmergenciesInput = {
    where: NightclubWhereUniqueInput
    create: XOR<NightclubCreateWithoutEmergenciesInput, NightclubUncheckedCreateWithoutEmergenciesInput>
  }

  export type UserCreateWithoutEmergenciesInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    deviceId?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    lastLocation?: NullableJsonNullValueInput | InputJsonValue
    nightclub?: NightclubCreateNestedOneWithoutUsersInput
    alerts?: AlertCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutEmergenciesInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    deviceId?: string | null
    nightclubId?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    lastLocation?: NullableJsonNullValueInput | InputJsonValue
    alerts?: AlertUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEmergenciesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEmergenciesInput, UserUncheckedCreateWithoutEmergenciesInput>
  }

  export type BraceletUpsertWithoutEmergenciesInput = {
    update: XOR<BraceletUpdateWithoutEmergenciesInput, BraceletUncheckedUpdateWithoutEmergenciesInput>
    create: XOR<BraceletCreateWithoutEmergenciesInput, BraceletUncheckedCreateWithoutEmergenciesInput>
    where?: BraceletWhereInput
  }

  export type BraceletUpdateToOneWithWhereWithoutEmergenciesInput = {
    where?: BraceletWhereInput
    data: XOR<BraceletUpdateWithoutEmergenciesInput, BraceletUncheckedUpdateWithoutEmergenciesInput>
  }

  export type BraceletUpdateWithoutEmergenciesInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    batteryLevel?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumBraceletStatusFieldUpdateOperationsInput | $Enums.BraceletStatus
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nightclub?: NightclubUpdateOneRequiredWithoutBraceletsNestedInput
    alerts?: AlertUpdateManyWithoutBraceletNestedInput
  }

  export type BraceletUncheckedUpdateWithoutEmergenciesInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    batteryLevel?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumBraceletStatusFieldUpdateOperationsInput | $Enums.BraceletStatus
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nightclubId?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    alerts?: AlertUncheckedUpdateManyWithoutBraceletNestedInput
  }

  export type ZoneUpsertWithoutEmergenciesInput = {
    update: XOR<ZoneUpdateWithoutEmergenciesInput, ZoneUncheckedUpdateWithoutEmergenciesInput>
    create: XOR<ZoneCreateWithoutEmergenciesInput, ZoneUncheckedCreateWithoutEmergenciesInput>
    where?: ZoneWhereInput
  }

  export type ZoneUpdateToOneWithWhereWithoutEmergenciesInput = {
    where?: ZoneWhereInput
    data: XOR<ZoneUpdateWithoutEmergenciesInput, ZoneUncheckedUpdateWithoutEmergenciesInput>
  }

  export type ZoneUpdateWithoutEmergenciesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    coordinates?: JsonNullValueInput | InputJsonValue
    capacity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    floorPlan?: FloorPlanUpdateOneRequiredWithoutZonesNestedInput
    nightclub?: NightclubUpdateOneRequiredWithoutZonesNestedInput
    alerts?: AlertUpdateManyWithoutZoneNestedInput
    sensors?: SensorUpdateManyWithoutZoneNestedInput
    anomalies?: AnomalyUpdateManyWithoutZoneNestedInput
    behaviors?: BehaviorAnalysisUpdateManyWithoutZoneNestedInput
    realTimeMetrics?: RealTimeMetricUpdateManyWithoutZoneNestedInput
    predictions?: PredictionUpdateManyWithoutZoneNestedInput
  }

  export type ZoneUncheckedUpdateWithoutEmergenciesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    coordinates?: JsonNullValueInput | InputJsonValue
    capacity?: IntFieldUpdateOperationsInput | number
    floorPlanId?: StringFieldUpdateOperationsInput | string
    nightclubId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    alerts?: AlertUncheckedUpdateManyWithoutZoneNestedInput
    sensors?: SensorUncheckedUpdateManyWithoutZoneNestedInput
    anomalies?: AnomalyUncheckedUpdateManyWithoutZoneNestedInput
    behaviors?: BehaviorAnalysisUncheckedUpdateManyWithoutZoneNestedInput
    realTimeMetrics?: RealTimeMetricUncheckedUpdateManyWithoutZoneNestedInput
    predictions?: PredictionUncheckedUpdateManyWithoutZoneNestedInput
  }

  export type NightclubUpsertWithoutEmergenciesInput = {
    update: XOR<NightclubUpdateWithoutEmergenciesInput, NightclubUncheckedUpdateWithoutEmergenciesInput>
    create: XOR<NightclubCreateWithoutEmergenciesInput, NightclubUncheckedCreateWithoutEmergenciesInput>
    where?: NightclubWhereInput
  }

  export type NightclubUpdateToOneWithWhereWithoutEmergenciesInput = {
    where?: NightclubWhereInput
    data: XOR<NightclubUpdateWithoutEmergenciesInput, NightclubUncheckedUpdateWithoutEmergenciesInput>
  }

  export type NightclubUpdateWithoutEmergenciesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    floorPlans?: FloorPlanUpdateManyWithoutNightclubNestedInput
    users?: UserUpdateManyWithoutNightclubNestedInput
    bracelets?: BraceletUpdateManyWithoutNightclubNestedInput
    zones?: ZoneUpdateManyWithoutNightclubNestedInput
    analyticsReports?: AnalyticsReportUpdateManyWithoutNightclubNestedInput
    predictions?: PredictionUpdateManyWithoutNightclubNestedInput
    anomalies?: AnomalyUpdateManyWithoutNightclubNestedInput
    behaviors?: BehaviorAnalysisUpdateManyWithoutNightclubNestedInput
    realTimeMetrics?: RealTimeMetricUpdateManyWithoutNightclubNestedInput
    dataStreams?: DataStreamUpdateManyWithoutNightclubNestedInput
    cacheEntries?: CacheEntryUpdateManyWithoutNightclubNestedInput
  }

  export type NightclubUncheckedUpdateWithoutEmergenciesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    floorPlans?: FloorPlanUncheckedUpdateManyWithoutNightclubNestedInput
    users?: UserUncheckedUpdateManyWithoutNightclubNestedInput
    bracelets?: BraceletUncheckedUpdateManyWithoutNightclubNestedInput
    zones?: ZoneUncheckedUpdateManyWithoutNightclubNestedInput
    analyticsReports?: AnalyticsReportUncheckedUpdateManyWithoutNightclubNestedInput
    predictions?: PredictionUncheckedUpdateManyWithoutNightclubNestedInput
    anomalies?: AnomalyUncheckedUpdateManyWithoutNightclubNestedInput
    behaviors?: BehaviorAnalysisUncheckedUpdateManyWithoutNightclubNestedInput
    realTimeMetrics?: RealTimeMetricUncheckedUpdateManyWithoutNightclubNestedInput
    dataStreams?: DataStreamUncheckedUpdateManyWithoutNightclubNestedInput
    cacheEntries?: CacheEntryUncheckedUpdateManyWithoutNightclubNestedInput
  }

  export type UserUpsertWithoutEmergenciesInput = {
    update: XOR<UserUpdateWithoutEmergenciesInput, UserUncheckedUpdateWithoutEmergenciesInput>
    create: XOR<UserCreateWithoutEmergenciesInput, UserUncheckedCreateWithoutEmergenciesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEmergenciesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEmergenciesInput, UserUncheckedUpdateWithoutEmergenciesInput>
  }

  export type UserUpdateWithoutEmergenciesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLocation?: NullableJsonNullValueInput | InputJsonValue
    nightclub?: NightclubUpdateOneWithoutUsersNestedInput
    alerts?: AlertUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEmergenciesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    nightclubId?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLocation?: NullableJsonNullValueInput | InputJsonValue
    alerts?: AlertUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ZoneCreateWithoutSensorsInput = {
    id?: string
    name: string
    coordinates: JsonNullValueInput | InputJsonValue
    capacity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    floorPlan: FloorPlanCreateNestedOneWithoutZonesInput
    nightclub: NightclubCreateNestedOneWithoutZonesInput
    alerts?: AlertCreateNestedManyWithoutZoneInput
    emergencies?: EmergencyCreateNestedManyWithoutZoneInput
    anomalies?: AnomalyCreateNestedManyWithoutZoneInput
    behaviors?: BehaviorAnalysisCreateNestedManyWithoutZoneInput
    realTimeMetrics?: RealTimeMetricCreateNestedManyWithoutZoneInput
    predictions?: PredictionCreateNestedManyWithoutZoneInput
  }

  export type ZoneUncheckedCreateWithoutSensorsInput = {
    id?: string
    name: string
    coordinates: JsonNullValueInput | InputJsonValue
    capacity: number
    floorPlanId: string
    nightclubId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    alerts?: AlertUncheckedCreateNestedManyWithoutZoneInput
    emergencies?: EmergencyUncheckedCreateNestedManyWithoutZoneInput
    anomalies?: AnomalyUncheckedCreateNestedManyWithoutZoneInput
    behaviors?: BehaviorAnalysisUncheckedCreateNestedManyWithoutZoneInput
    realTimeMetrics?: RealTimeMetricUncheckedCreateNestedManyWithoutZoneInput
    predictions?: PredictionUncheckedCreateNestedManyWithoutZoneInput
  }

  export type ZoneCreateOrConnectWithoutSensorsInput = {
    where: ZoneWhereUniqueInput
    create: XOR<ZoneCreateWithoutSensorsInput, ZoneUncheckedCreateWithoutSensorsInput>
  }

  export type ZoneUpsertWithoutSensorsInput = {
    update: XOR<ZoneUpdateWithoutSensorsInput, ZoneUncheckedUpdateWithoutSensorsInput>
    create: XOR<ZoneCreateWithoutSensorsInput, ZoneUncheckedCreateWithoutSensorsInput>
    where?: ZoneWhereInput
  }

  export type ZoneUpdateToOneWithWhereWithoutSensorsInput = {
    where?: ZoneWhereInput
    data: XOR<ZoneUpdateWithoutSensorsInput, ZoneUncheckedUpdateWithoutSensorsInput>
  }

  export type ZoneUpdateWithoutSensorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    coordinates?: JsonNullValueInput | InputJsonValue
    capacity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    floorPlan?: FloorPlanUpdateOneRequiredWithoutZonesNestedInput
    nightclub?: NightclubUpdateOneRequiredWithoutZonesNestedInput
    alerts?: AlertUpdateManyWithoutZoneNestedInput
    emergencies?: EmergencyUpdateManyWithoutZoneNestedInput
    anomalies?: AnomalyUpdateManyWithoutZoneNestedInput
    behaviors?: BehaviorAnalysisUpdateManyWithoutZoneNestedInput
    realTimeMetrics?: RealTimeMetricUpdateManyWithoutZoneNestedInput
    predictions?: PredictionUpdateManyWithoutZoneNestedInput
  }

  export type ZoneUncheckedUpdateWithoutSensorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    coordinates?: JsonNullValueInput | InputJsonValue
    capacity?: IntFieldUpdateOperationsInput | number
    floorPlanId?: StringFieldUpdateOperationsInput | string
    nightclubId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    alerts?: AlertUncheckedUpdateManyWithoutZoneNestedInput
    emergencies?: EmergencyUncheckedUpdateManyWithoutZoneNestedInput
    anomalies?: AnomalyUncheckedUpdateManyWithoutZoneNestedInput
    behaviors?: BehaviorAnalysisUncheckedUpdateManyWithoutZoneNestedInput
    realTimeMetrics?: RealTimeMetricUncheckedUpdateManyWithoutZoneNestedInput
    predictions?: PredictionUncheckedUpdateManyWithoutZoneNestedInput
  }

  export type NightclubCreateWithoutAnalyticsReportsInput = {
    id?: string
    name: string
    address: string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    floorPlans?: FloorPlanCreateNestedManyWithoutNightclubInput
    users?: UserCreateNestedManyWithoutNightclubInput
    bracelets?: BraceletCreateNestedManyWithoutNightclubInput
    zones?: ZoneCreateNestedManyWithoutNightclubInput
    emergencies?: EmergencyCreateNestedManyWithoutNightclubInput
    predictions?: PredictionCreateNestedManyWithoutNightclubInput
    anomalies?: AnomalyCreateNestedManyWithoutNightclubInput
    behaviors?: BehaviorAnalysisCreateNestedManyWithoutNightclubInput
    realTimeMetrics?: RealTimeMetricCreateNestedManyWithoutNightclubInput
    dataStreams?: DataStreamCreateNestedManyWithoutNightclubInput
    cacheEntries?: CacheEntryCreateNestedManyWithoutNightclubInput
  }

  export type NightclubUncheckedCreateWithoutAnalyticsReportsInput = {
    id?: string
    name: string
    address: string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    floorPlans?: FloorPlanUncheckedCreateNestedManyWithoutNightclubInput
    users?: UserUncheckedCreateNestedManyWithoutNightclubInput
    bracelets?: BraceletUncheckedCreateNestedManyWithoutNightclubInput
    zones?: ZoneUncheckedCreateNestedManyWithoutNightclubInput
    emergencies?: EmergencyUncheckedCreateNestedManyWithoutNightclubInput
    predictions?: PredictionUncheckedCreateNestedManyWithoutNightclubInput
    anomalies?: AnomalyUncheckedCreateNestedManyWithoutNightclubInput
    behaviors?: BehaviorAnalysisUncheckedCreateNestedManyWithoutNightclubInput
    realTimeMetrics?: RealTimeMetricUncheckedCreateNestedManyWithoutNightclubInput
    dataStreams?: DataStreamUncheckedCreateNestedManyWithoutNightclubInput
    cacheEntries?: CacheEntryUncheckedCreateNestedManyWithoutNightclubInput
  }

  export type NightclubCreateOrConnectWithoutAnalyticsReportsInput = {
    where: NightclubWhereUniqueInput
    create: XOR<NightclubCreateWithoutAnalyticsReportsInput, NightclubUncheckedCreateWithoutAnalyticsReportsInput>
  }

  export type NightclubUpsertWithoutAnalyticsReportsInput = {
    update: XOR<NightclubUpdateWithoutAnalyticsReportsInput, NightclubUncheckedUpdateWithoutAnalyticsReportsInput>
    create: XOR<NightclubCreateWithoutAnalyticsReportsInput, NightclubUncheckedCreateWithoutAnalyticsReportsInput>
    where?: NightclubWhereInput
  }

  export type NightclubUpdateToOneWithWhereWithoutAnalyticsReportsInput = {
    where?: NightclubWhereInput
    data: XOR<NightclubUpdateWithoutAnalyticsReportsInput, NightclubUncheckedUpdateWithoutAnalyticsReportsInput>
  }

  export type NightclubUpdateWithoutAnalyticsReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    floorPlans?: FloorPlanUpdateManyWithoutNightclubNestedInput
    users?: UserUpdateManyWithoutNightclubNestedInput
    bracelets?: BraceletUpdateManyWithoutNightclubNestedInput
    zones?: ZoneUpdateManyWithoutNightclubNestedInput
    emergencies?: EmergencyUpdateManyWithoutNightclubNestedInput
    predictions?: PredictionUpdateManyWithoutNightclubNestedInput
    anomalies?: AnomalyUpdateManyWithoutNightclubNestedInput
    behaviors?: BehaviorAnalysisUpdateManyWithoutNightclubNestedInput
    realTimeMetrics?: RealTimeMetricUpdateManyWithoutNightclubNestedInput
    dataStreams?: DataStreamUpdateManyWithoutNightclubNestedInput
    cacheEntries?: CacheEntryUpdateManyWithoutNightclubNestedInput
  }

  export type NightclubUncheckedUpdateWithoutAnalyticsReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    floorPlans?: FloorPlanUncheckedUpdateManyWithoutNightclubNestedInput
    users?: UserUncheckedUpdateManyWithoutNightclubNestedInput
    bracelets?: BraceletUncheckedUpdateManyWithoutNightclubNestedInput
    zones?: ZoneUncheckedUpdateManyWithoutNightclubNestedInput
    emergencies?: EmergencyUncheckedUpdateManyWithoutNightclubNestedInput
    predictions?: PredictionUncheckedUpdateManyWithoutNightclubNestedInput
    anomalies?: AnomalyUncheckedUpdateManyWithoutNightclubNestedInput
    behaviors?: BehaviorAnalysisUncheckedUpdateManyWithoutNightclubNestedInput
    realTimeMetrics?: RealTimeMetricUncheckedUpdateManyWithoutNightclubNestedInput
    dataStreams?: DataStreamUncheckedUpdateManyWithoutNightclubNestedInput
    cacheEntries?: CacheEntryUncheckedUpdateManyWithoutNightclubNestedInput
  }

  export type PredictionCreateWithoutModelInput = {
    id?: string
    type: string
    timestamp?: Date | string
    value: number
    confidence: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    nightclub: NightclubCreateNestedOneWithoutPredictionsInput
    zone?: ZoneCreateNestedOneWithoutPredictionsInput
  }

  export type PredictionUncheckedCreateWithoutModelInput = {
    id?: string
    type: string
    timestamp?: Date | string
    value: number
    confidence: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    nightclubId: string
    zoneId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PredictionCreateOrConnectWithoutModelInput = {
    where: PredictionWhereUniqueInput
    create: XOR<PredictionCreateWithoutModelInput, PredictionUncheckedCreateWithoutModelInput>
  }

  export type PredictionCreateManyModelInputEnvelope = {
    data: PredictionCreateManyModelInput | PredictionCreateManyModelInput[]
    skipDuplicates?: boolean
  }

  export type AnomalyCreateWithoutModelInput = {
    id?: string
    type: string
    severity: string
    status: string
    description: string
    timestamp?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    nightclub: NightclubCreateNestedOneWithoutAnomaliesInput
    zone?: ZoneCreateNestedOneWithoutAnomaliesInput
  }

  export type AnomalyUncheckedCreateWithoutModelInput = {
    id?: string
    type: string
    severity: string
    status: string
    description: string
    timestamp?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    nightclubId: string
    zoneId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnomalyCreateOrConnectWithoutModelInput = {
    where: AnomalyWhereUniqueInput
    create: XOR<AnomalyCreateWithoutModelInput, AnomalyUncheckedCreateWithoutModelInput>
  }

  export type AnomalyCreateManyModelInputEnvelope = {
    data: AnomalyCreateManyModelInput | AnomalyCreateManyModelInput[]
    skipDuplicates?: boolean
  }

  export type BehaviorAnalysisCreateWithoutModelInput = {
    id?: string
    type: string
    timestamp?: Date | string
    insights: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    nightclub: NightclubCreateNestedOneWithoutBehaviorsInput
    zone?: ZoneCreateNestedOneWithoutBehaviorsInput
  }

  export type BehaviorAnalysisUncheckedCreateWithoutModelInput = {
    id?: string
    type: string
    timestamp?: Date | string
    insights: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    nightclubId: string
    zoneId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BehaviorAnalysisCreateOrConnectWithoutModelInput = {
    where: BehaviorAnalysisWhereUniqueInput
    create: XOR<BehaviorAnalysisCreateWithoutModelInput, BehaviorAnalysisUncheckedCreateWithoutModelInput>
  }

  export type BehaviorAnalysisCreateManyModelInputEnvelope = {
    data: BehaviorAnalysisCreateManyModelInput | BehaviorAnalysisCreateManyModelInput[]
    skipDuplicates?: boolean
  }

  export type PredictionUpsertWithWhereUniqueWithoutModelInput = {
    where: PredictionWhereUniqueInput
    update: XOR<PredictionUpdateWithoutModelInput, PredictionUncheckedUpdateWithoutModelInput>
    create: XOR<PredictionCreateWithoutModelInput, PredictionUncheckedCreateWithoutModelInput>
  }

  export type PredictionUpdateWithWhereUniqueWithoutModelInput = {
    where: PredictionWhereUniqueInput
    data: XOR<PredictionUpdateWithoutModelInput, PredictionUncheckedUpdateWithoutModelInput>
  }

  export type PredictionUpdateManyWithWhereWithoutModelInput = {
    where: PredictionScalarWhereInput
    data: XOR<PredictionUpdateManyMutationInput, PredictionUncheckedUpdateManyWithoutModelInput>
  }

  export type AnomalyUpsertWithWhereUniqueWithoutModelInput = {
    where: AnomalyWhereUniqueInput
    update: XOR<AnomalyUpdateWithoutModelInput, AnomalyUncheckedUpdateWithoutModelInput>
    create: XOR<AnomalyCreateWithoutModelInput, AnomalyUncheckedCreateWithoutModelInput>
  }

  export type AnomalyUpdateWithWhereUniqueWithoutModelInput = {
    where: AnomalyWhereUniqueInput
    data: XOR<AnomalyUpdateWithoutModelInput, AnomalyUncheckedUpdateWithoutModelInput>
  }

  export type AnomalyUpdateManyWithWhereWithoutModelInput = {
    where: AnomalyScalarWhereInput
    data: XOR<AnomalyUpdateManyMutationInput, AnomalyUncheckedUpdateManyWithoutModelInput>
  }

  export type BehaviorAnalysisUpsertWithWhereUniqueWithoutModelInput = {
    where: BehaviorAnalysisWhereUniqueInput
    update: XOR<BehaviorAnalysisUpdateWithoutModelInput, BehaviorAnalysisUncheckedUpdateWithoutModelInput>
    create: XOR<BehaviorAnalysisCreateWithoutModelInput, BehaviorAnalysisUncheckedCreateWithoutModelInput>
  }

  export type BehaviorAnalysisUpdateWithWhereUniqueWithoutModelInput = {
    where: BehaviorAnalysisWhereUniqueInput
    data: XOR<BehaviorAnalysisUpdateWithoutModelInput, BehaviorAnalysisUncheckedUpdateWithoutModelInput>
  }

  export type BehaviorAnalysisUpdateManyWithWhereWithoutModelInput = {
    where: BehaviorAnalysisScalarWhereInput
    data: XOR<BehaviorAnalysisUpdateManyMutationInput, BehaviorAnalysisUncheckedUpdateManyWithoutModelInput>
  }

  export type NightclubCreateWithoutPredictionsInput = {
    id?: string
    name: string
    address: string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    floorPlans?: FloorPlanCreateNestedManyWithoutNightclubInput
    users?: UserCreateNestedManyWithoutNightclubInput
    bracelets?: BraceletCreateNestedManyWithoutNightclubInput
    zones?: ZoneCreateNestedManyWithoutNightclubInput
    emergencies?: EmergencyCreateNestedManyWithoutNightclubInput
    analyticsReports?: AnalyticsReportCreateNestedManyWithoutNightclubInput
    anomalies?: AnomalyCreateNestedManyWithoutNightclubInput
    behaviors?: BehaviorAnalysisCreateNestedManyWithoutNightclubInput
    realTimeMetrics?: RealTimeMetricCreateNestedManyWithoutNightclubInput
    dataStreams?: DataStreamCreateNestedManyWithoutNightclubInput
    cacheEntries?: CacheEntryCreateNestedManyWithoutNightclubInput
  }

  export type NightclubUncheckedCreateWithoutPredictionsInput = {
    id?: string
    name: string
    address: string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    floorPlans?: FloorPlanUncheckedCreateNestedManyWithoutNightclubInput
    users?: UserUncheckedCreateNestedManyWithoutNightclubInput
    bracelets?: BraceletUncheckedCreateNestedManyWithoutNightclubInput
    zones?: ZoneUncheckedCreateNestedManyWithoutNightclubInput
    emergencies?: EmergencyUncheckedCreateNestedManyWithoutNightclubInput
    analyticsReports?: AnalyticsReportUncheckedCreateNestedManyWithoutNightclubInput
    anomalies?: AnomalyUncheckedCreateNestedManyWithoutNightclubInput
    behaviors?: BehaviorAnalysisUncheckedCreateNestedManyWithoutNightclubInput
    realTimeMetrics?: RealTimeMetricUncheckedCreateNestedManyWithoutNightclubInput
    dataStreams?: DataStreamUncheckedCreateNestedManyWithoutNightclubInput
    cacheEntries?: CacheEntryUncheckedCreateNestedManyWithoutNightclubInput
  }

  export type NightclubCreateOrConnectWithoutPredictionsInput = {
    where: NightclubWhereUniqueInput
    create: XOR<NightclubCreateWithoutPredictionsInput, NightclubUncheckedCreateWithoutPredictionsInput>
  }

  export type ZoneCreateWithoutPredictionsInput = {
    id?: string
    name: string
    coordinates: JsonNullValueInput | InputJsonValue
    capacity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    floorPlan: FloorPlanCreateNestedOneWithoutZonesInput
    nightclub: NightclubCreateNestedOneWithoutZonesInput
    alerts?: AlertCreateNestedManyWithoutZoneInput
    emergencies?: EmergencyCreateNestedManyWithoutZoneInput
    sensors?: SensorCreateNestedManyWithoutZoneInput
    anomalies?: AnomalyCreateNestedManyWithoutZoneInput
    behaviors?: BehaviorAnalysisCreateNestedManyWithoutZoneInput
    realTimeMetrics?: RealTimeMetricCreateNestedManyWithoutZoneInput
  }

  export type ZoneUncheckedCreateWithoutPredictionsInput = {
    id?: string
    name: string
    coordinates: JsonNullValueInput | InputJsonValue
    capacity: number
    floorPlanId: string
    nightclubId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    alerts?: AlertUncheckedCreateNestedManyWithoutZoneInput
    emergencies?: EmergencyUncheckedCreateNestedManyWithoutZoneInput
    sensors?: SensorUncheckedCreateNestedManyWithoutZoneInput
    anomalies?: AnomalyUncheckedCreateNestedManyWithoutZoneInput
    behaviors?: BehaviorAnalysisUncheckedCreateNestedManyWithoutZoneInput
    realTimeMetrics?: RealTimeMetricUncheckedCreateNestedManyWithoutZoneInput
  }

  export type ZoneCreateOrConnectWithoutPredictionsInput = {
    where: ZoneWhereUniqueInput
    create: XOR<ZoneCreateWithoutPredictionsInput, ZoneUncheckedCreateWithoutPredictionsInput>
  }

  export type AIModelCreateWithoutPredictionsInput = {
    id?: string
    type: string
    name: string
    version: string
    status: string
    config: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    anomalies?: AnomalyCreateNestedManyWithoutModelInput
    behaviorAnalyses?: BehaviorAnalysisCreateNestedManyWithoutModelInput
  }

  export type AIModelUncheckedCreateWithoutPredictionsInput = {
    id?: string
    type: string
    name: string
    version: string
    status: string
    config: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    anomalies?: AnomalyUncheckedCreateNestedManyWithoutModelInput
    behaviorAnalyses?: BehaviorAnalysisUncheckedCreateNestedManyWithoutModelInput
  }

  export type AIModelCreateOrConnectWithoutPredictionsInput = {
    where: AIModelWhereUniqueInput
    create: XOR<AIModelCreateWithoutPredictionsInput, AIModelUncheckedCreateWithoutPredictionsInput>
  }

  export type NightclubUpsertWithoutPredictionsInput = {
    update: XOR<NightclubUpdateWithoutPredictionsInput, NightclubUncheckedUpdateWithoutPredictionsInput>
    create: XOR<NightclubCreateWithoutPredictionsInput, NightclubUncheckedCreateWithoutPredictionsInput>
    where?: NightclubWhereInput
  }

  export type NightclubUpdateToOneWithWhereWithoutPredictionsInput = {
    where?: NightclubWhereInput
    data: XOR<NightclubUpdateWithoutPredictionsInput, NightclubUncheckedUpdateWithoutPredictionsInput>
  }

  export type NightclubUpdateWithoutPredictionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    floorPlans?: FloorPlanUpdateManyWithoutNightclubNestedInput
    users?: UserUpdateManyWithoutNightclubNestedInput
    bracelets?: BraceletUpdateManyWithoutNightclubNestedInput
    zones?: ZoneUpdateManyWithoutNightclubNestedInput
    emergencies?: EmergencyUpdateManyWithoutNightclubNestedInput
    analyticsReports?: AnalyticsReportUpdateManyWithoutNightclubNestedInput
    anomalies?: AnomalyUpdateManyWithoutNightclubNestedInput
    behaviors?: BehaviorAnalysisUpdateManyWithoutNightclubNestedInput
    realTimeMetrics?: RealTimeMetricUpdateManyWithoutNightclubNestedInput
    dataStreams?: DataStreamUpdateManyWithoutNightclubNestedInput
    cacheEntries?: CacheEntryUpdateManyWithoutNightclubNestedInput
  }

  export type NightclubUncheckedUpdateWithoutPredictionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    floorPlans?: FloorPlanUncheckedUpdateManyWithoutNightclubNestedInput
    users?: UserUncheckedUpdateManyWithoutNightclubNestedInput
    bracelets?: BraceletUncheckedUpdateManyWithoutNightclubNestedInput
    zones?: ZoneUncheckedUpdateManyWithoutNightclubNestedInput
    emergencies?: EmergencyUncheckedUpdateManyWithoutNightclubNestedInput
    analyticsReports?: AnalyticsReportUncheckedUpdateManyWithoutNightclubNestedInput
    anomalies?: AnomalyUncheckedUpdateManyWithoutNightclubNestedInput
    behaviors?: BehaviorAnalysisUncheckedUpdateManyWithoutNightclubNestedInput
    realTimeMetrics?: RealTimeMetricUncheckedUpdateManyWithoutNightclubNestedInput
    dataStreams?: DataStreamUncheckedUpdateManyWithoutNightclubNestedInput
    cacheEntries?: CacheEntryUncheckedUpdateManyWithoutNightclubNestedInput
  }

  export type ZoneUpsertWithoutPredictionsInput = {
    update: XOR<ZoneUpdateWithoutPredictionsInput, ZoneUncheckedUpdateWithoutPredictionsInput>
    create: XOR<ZoneCreateWithoutPredictionsInput, ZoneUncheckedCreateWithoutPredictionsInput>
    where?: ZoneWhereInput
  }

  export type ZoneUpdateToOneWithWhereWithoutPredictionsInput = {
    where?: ZoneWhereInput
    data: XOR<ZoneUpdateWithoutPredictionsInput, ZoneUncheckedUpdateWithoutPredictionsInput>
  }

  export type ZoneUpdateWithoutPredictionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    coordinates?: JsonNullValueInput | InputJsonValue
    capacity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    floorPlan?: FloorPlanUpdateOneRequiredWithoutZonesNestedInput
    nightclub?: NightclubUpdateOneRequiredWithoutZonesNestedInput
    alerts?: AlertUpdateManyWithoutZoneNestedInput
    emergencies?: EmergencyUpdateManyWithoutZoneNestedInput
    sensors?: SensorUpdateManyWithoutZoneNestedInput
    anomalies?: AnomalyUpdateManyWithoutZoneNestedInput
    behaviors?: BehaviorAnalysisUpdateManyWithoutZoneNestedInput
    realTimeMetrics?: RealTimeMetricUpdateManyWithoutZoneNestedInput
  }

  export type ZoneUncheckedUpdateWithoutPredictionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    coordinates?: JsonNullValueInput | InputJsonValue
    capacity?: IntFieldUpdateOperationsInput | number
    floorPlanId?: StringFieldUpdateOperationsInput | string
    nightclubId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    alerts?: AlertUncheckedUpdateManyWithoutZoneNestedInput
    emergencies?: EmergencyUncheckedUpdateManyWithoutZoneNestedInput
    sensors?: SensorUncheckedUpdateManyWithoutZoneNestedInput
    anomalies?: AnomalyUncheckedUpdateManyWithoutZoneNestedInput
    behaviors?: BehaviorAnalysisUncheckedUpdateManyWithoutZoneNestedInput
    realTimeMetrics?: RealTimeMetricUncheckedUpdateManyWithoutZoneNestedInput
  }

  export type AIModelUpsertWithoutPredictionsInput = {
    update: XOR<AIModelUpdateWithoutPredictionsInput, AIModelUncheckedUpdateWithoutPredictionsInput>
    create: XOR<AIModelCreateWithoutPredictionsInput, AIModelUncheckedCreateWithoutPredictionsInput>
    where?: AIModelWhereInput
  }

  export type AIModelUpdateToOneWithWhereWithoutPredictionsInput = {
    where?: AIModelWhereInput
    data: XOR<AIModelUpdateWithoutPredictionsInput, AIModelUncheckedUpdateWithoutPredictionsInput>
  }

  export type AIModelUpdateWithoutPredictionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    anomalies?: AnomalyUpdateManyWithoutModelNestedInput
    behaviorAnalyses?: BehaviorAnalysisUpdateManyWithoutModelNestedInput
  }

  export type AIModelUncheckedUpdateWithoutPredictionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    anomalies?: AnomalyUncheckedUpdateManyWithoutModelNestedInput
    behaviorAnalyses?: BehaviorAnalysisUncheckedUpdateManyWithoutModelNestedInput
  }

  export type NightclubCreateWithoutAnomaliesInput = {
    id?: string
    name: string
    address: string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    floorPlans?: FloorPlanCreateNestedManyWithoutNightclubInput
    users?: UserCreateNestedManyWithoutNightclubInput
    bracelets?: BraceletCreateNestedManyWithoutNightclubInput
    zones?: ZoneCreateNestedManyWithoutNightclubInput
    emergencies?: EmergencyCreateNestedManyWithoutNightclubInput
    analyticsReports?: AnalyticsReportCreateNestedManyWithoutNightclubInput
    predictions?: PredictionCreateNestedManyWithoutNightclubInput
    behaviors?: BehaviorAnalysisCreateNestedManyWithoutNightclubInput
    realTimeMetrics?: RealTimeMetricCreateNestedManyWithoutNightclubInput
    dataStreams?: DataStreamCreateNestedManyWithoutNightclubInput
    cacheEntries?: CacheEntryCreateNestedManyWithoutNightclubInput
  }

  export type NightclubUncheckedCreateWithoutAnomaliesInput = {
    id?: string
    name: string
    address: string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    floorPlans?: FloorPlanUncheckedCreateNestedManyWithoutNightclubInput
    users?: UserUncheckedCreateNestedManyWithoutNightclubInput
    bracelets?: BraceletUncheckedCreateNestedManyWithoutNightclubInput
    zones?: ZoneUncheckedCreateNestedManyWithoutNightclubInput
    emergencies?: EmergencyUncheckedCreateNestedManyWithoutNightclubInput
    analyticsReports?: AnalyticsReportUncheckedCreateNestedManyWithoutNightclubInput
    predictions?: PredictionUncheckedCreateNestedManyWithoutNightclubInput
    behaviors?: BehaviorAnalysisUncheckedCreateNestedManyWithoutNightclubInput
    realTimeMetrics?: RealTimeMetricUncheckedCreateNestedManyWithoutNightclubInput
    dataStreams?: DataStreamUncheckedCreateNestedManyWithoutNightclubInput
    cacheEntries?: CacheEntryUncheckedCreateNestedManyWithoutNightclubInput
  }

  export type NightclubCreateOrConnectWithoutAnomaliesInput = {
    where: NightclubWhereUniqueInput
    create: XOR<NightclubCreateWithoutAnomaliesInput, NightclubUncheckedCreateWithoutAnomaliesInput>
  }

  export type ZoneCreateWithoutAnomaliesInput = {
    id?: string
    name: string
    coordinates: JsonNullValueInput | InputJsonValue
    capacity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    floorPlan: FloorPlanCreateNestedOneWithoutZonesInput
    nightclub: NightclubCreateNestedOneWithoutZonesInput
    alerts?: AlertCreateNestedManyWithoutZoneInput
    emergencies?: EmergencyCreateNestedManyWithoutZoneInput
    sensors?: SensorCreateNestedManyWithoutZoneInput
    behaviors?: BehaviorAnalysisCreateNestedManyWithoutZoneInput
    realTimeMetrics?: RealTimeMetricCreateNestedManyWithoutZoneInput
    predictions?: PredictionCreateNestedManyWithoutZoneInput
  }

  export type ZoneUncheckedCreateWithoutAnomaliesInput = {
    id?: string
    name: string
    coordinates: JsonNullValueInput | InputJsonValue
    capacity: number
    floorPlanId: string
    nightclubId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    alerts?: AlertUncheckedCreateNestedManyWithoutZoneInput
    emergencies?: EmergencyUncheckedCreateNestedManyWithoutZoneInput
    sensors?: SensorUncheckedCreateNestedManyWithoutZoneInput
    behaviors?: BehaviorAnalysisUncheckedCreateNestedManyWithoutZoneInput
    realTimeMetrics?: RealTimeMetricUncheckedCreateNestedManyWithoutZoneInput
    predictions?: PredictionUncheckedCreateNestedManyWithoutZoneInput
  }

  export type ZoneCreateOrConnectWithoutAnomaliesInput = {
    where: ZoneWhereUniqueInput
    create: XOR<ZoneCreateWithoutAnomaliesInput, ZoneUncheckedCreateWithoutAnomaliesInput>
  }

  export type AIModelCreateWithoutAnomaliesInput = {
    id?: string
    type: string
    name: string
    version: string
    status: string
    config: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    predictions?: PredictionCreateNestedManyWithoutModelInput
    behaviorAnalyses?: BehaviorAnalysisCreateNestedManyWithoutModelInput
  }

  export type AIModelUncheckedCreateWithoutAnomaliesInput = {
    id?: string
    type: string
    name: string
    version: string
    status: string
    config: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    predictions?: PredictionUncheckedCreateNestedManyWithoutModelInput
    behaviorAnalyses?: BehaviorAnalysisUncheckedCreateNestedManyWithoutModelInput
  }

  export type AIModelCreateOrConnectWithoutAnomaliesInput = {
    where: AIModelWhereUniqueInput
    create: XOR<AIModelCreateWithoutAnomaliesInput, AIModelUncheckedCreateWithoutAnomaliesInput>
  }

  export type NightclubUpsertWithoutAnomaliesInput = {
    update: XOR<NightclubUpdateWithoutAnomaliesInput, NightclubUncheckedUpdateWithoutAnomaliesInput>
    create: XOR<NightclubCreateWithoutAnomaliesInput, NightclubUncheckedCreateWithoutAnomaliesInput>
    where?: NightclubWhereInput
  }

  export type NightclubUpdateToOneWithWhereWithoutAnomaliesInput = {
    where?: NightclubWhereInput
    data: XOR<NightclubUpdateWithoutAnomaliesInput, NightclubUncheckedUpdateWithoutAnomaliesInput>
  }

  export type NightclubUpdateWithoutAnomaliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    floorPlans?: FloorPlanUpdateManyWithoutNightclubNestedInput
    users?: UserUpdateManyWithoutNightclubNestedInput
    bracelets?: BraceletUpdateManyWithoutNightclubNestedInput
    zones?: ZoneUpdateManyWithoutNightclubNestedInput
    emergencies?: EmergencyUpdateManyWithoutNightclubNestedInput
    analyticsReports?: AnalyticsReportUpdateManyWithoutNightclubNestedInput
    predictions?: PredictionUpdateManyWithoutNightclubNestedInput
    behaviors?: BehaviorAnalysisUpdateManyWithoutNightclubNestedInput
    realTimeMetrics?: RealTimeMetricUpdateManyWithoutNightclubNestedInput
    dataStreams?: DataStreamUpdateManyWithoutNightclubNestedInput
    cacheEntries?: CacheEntryUpdateManyWithoutNightclubNestedInput
  }

  export type NightclubUncheckedUpdateWithoutAnomaliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    floorPlans?: FloorPlanUncheckedUpdateManyWithoutNightclubNestedInput
    users?: UserUncheckedUpdateManyWithoutNightclubNestedInput
    bracelets?: BraceletUncheckedUpdateManyWithoutNightclubNestedInput
    zones?: ZoneUncheckedUpdateManyWithoutNightclubNestedInput
    emergencies?: EmergencyUncheckedUpdateManyWithoutNightclubNestedInput
    analyticsReports?: AnalyticsReportUncheckedUpdateManyWithoutNightclubNestedInput
    predictions?: PredictionUncheckedUpdateManyWithoutNightclubNestedInput
    behaviors?: BehaviorAnalysisUncheckedUpdateManyWithoutNightclubNestedInput
    realTimeMetrics?: RealTimeMetricUncheckedUpdateManyWithoutNightclubNestedInput
    dataStreams?: DataStreamUncheckedUpdateManyWithoutNightclubNestedInput
    cacheEntries?: CacheEntryUncheckedUpdateManyWithoutNightclubNestedInput
  }

  export type ZoneUpsertWithoutAnomaliesInput = {
    update: XOR<ZoneUpdateWithoutAnomaliesInput, ZoneUncheckedUpdateWithoutAnomaliesInput>
    create: XOR<ZoneCreateWithoutAnomaliesInput, ZoneUncheckedCreateWithoutAnomaliesInput>
    where?: ZoneWhereInput
  }

  export type ZoneUpdateToOneWithWhereWithoutAnomaliesInput = {
    where?: ZoneWhereInput
    data: XOR<ZoneUpdateWithoutAnomaliesInput, ZoneUncheckedUpdateWithoutAnomaliesInput>
  }

  export type ZoneUpdateWithoutAnomaliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    coordinates?: JsonNullValueInput | InputJsonValue
    capacity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    floorPlan?: FloorPlanUpdateOneRequiredWithoutZonesNestedInput
    nightclub?: NightclubUpdateOneRequiredWithoutZonesNestedInput
    alerts?: AlertUpdateManyWithoutZoneNestedInput
    emergencies?: EmergencyUpdateManyWithoutZoneNestedInput
    sensors?: SensorUpdateManyWithoutZoneNestedInput
    behaviors?: BehaviorAnalysisUpdateManyWithoutZoneNestedInput
    realTimeMetrics?: RealTimeMetricUpdateManyWithoutZoneNestedInput
    predictions?: PredictionUpdateManyWithoutZoneNestedInput
  }

  export type ZoneUncheckedUpdateWithoutAnomaliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    coordinates?: JsonNullValueInput | InputJsonValue
    capacity?: IntFieldUpdateOperationsInput | number
    floorPlanId?: StringFieldUpdateOperationsInput | string
    nightclubId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    alerts?: AlertUncheckedUpdateManyWithoutZoneNestedInput
    emergencies?: EmergencyUncheckedUpdateManyWithoutZoneNestedInput
    sensors?: SensorUncheckedUpdateManyWithoutZoneNestedInput
    behaviors?: BehaviorAnalysisUncheckedUpdateManyWithoutZoneNestedInput
    realTimeMetrics?: RealTimeMetricUncheckedUpdateManyWithoutZoneNestedInput
    predictions?: PredictionUncheckedUpdateManyWithoutZoneNestedInput
  }

  export type AIModelUpsertWithoutAnomaliesInput = {
    update: XOR<AIModelUpdateWithoutAnomaliesInput, AIModelUncheckedUpdateWithoutAnomaliesInput>
    create: XOR<AIModelCreateWithoutAnomaliesInput, AIModelUncheckedCreateWithoutAnomaliesInput>
    where?: AIModelWhereInput
  }

  export type AIModelUpdateToOneWithWhereWithoutAnomaliesInput = {
    where?: AIModelWhereInput
    data: XOR<AIModelUpdateWithoutAnomaliesInput, AIModelUncheckedUpdateWithoutAnomaliesInput>
  }

  export type AIModelUpdateWithoutAnomaliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    predictions?: PredictionUpdateManyWithoutModelNestedInput
    behaviorAnalyses?: BehaviorAnalysisUpdateManyWithoutModelNestedInput
  }

  export type AIModelUncheckedUpdateWithoutAnomaliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    predictions?: PredictionUncheckedUpdateManyWithoutModelNestedInput
    behaviorAnalyses?: BehaviorAnalysisUncheckedUpdateManyWithoutModelNestedInput
  }

  export type NightclubCreateWithoutBehaviorsInput = {
    id?: string
    name: string
    address: string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    floorPlans?: FloorPlanCreateNestedManyWithoutNightclubInput
    users?: UserCreateNestedManyWithoutNightclubInput
    bracelets?: BraceletCreateNestedManyWithoutNightclubInput
    zones?: ZoneCreateNestedManyWithoutNightclubInput
    emergencies?: EmergencyCreateNestedManyWithoutNightclubInput
    analyticsReports?: AnalyticsReportCreateNestedManyWithoutNightclubInput
    predictions?: PredictionCreateNestedManyWithoutNightclubInput
    anomalies?: AnomalyCreateNestedManyWithoutNightclubInput
    realTimeMetrics?: RealTimeMetricCreateNestedManyWithoutNightclubInput
    dataStreams?: DataStreamCreateNestedManyWithoutNightclubInput
    cacheEntries?: CacheEntryCreateNestedManyWithoutNightclubInput
  }

  export type NightclubUncheckedCreateWithoutBehaviorsInput = {
    id?: string
    name: string
    address: string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    floorPlans?: FloorPlanUncheckedCreateNestedManyWithoutNightclubInput
    users?: UserUncheckedCreateNestedManyWithoutNightclubInput
    bracelets?: BraceletUncheckedCreateNestedManyWithoutNightclubInput
    zones?: ZoneUncheckedCreateNestedManyWithoutNightclubInput
    emergencies?: EmergencyUncheckedCreateNestedManyWithoutNightclubInput
    analyticsReports?: AnalyticsReportUncheckedCreateNestedManyWithoutNightclubInput
    predictions?: PredictionUncheckedCreateNestedManyWithoutNightclubInput
    anomalies?: AnomalyUncheckedCreateNestedManyWithoutNightclubInput
    realTimeMetrics?: RealTimeMetricUncheckedCreateNestedManyWithoutNightclubInput
    dataStreams?: DataStreamUncheckedCreateNestedManyWithoutNightclubInput
    cacheEntries?: CacheEntryUncheckedCreateNestedManyWithoutNightclubInput
  }

  export type NightclubCreateOrConnectWithoutBehaviorsInput = {
    where: NightclubWhereUniqueInput
    create: XOR<NightclubCreateWithoutBehaviorsInput, NightclubUncheckedCreateWithoutBehaviorsInput>
  }

  export type ZoneCreateWithoutBehaviorsInput = {
    id?: string
    name: string
    coordinates: JsonNullValueInput | InputJsonValue
    capacity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    floorPlan: FloorPlanCreateNestedOneWithoutZonesInput
    nightclub: NightclubCreateNestedOneWithoutZonesInput
    alerts?: AlertCreateNestedManyWithoutZoneInput
    emergencies?: EmergencyCreateNestedManyWithoutZoneInput
    sensors?: SensorCreateNestedManyWithoutZoneInput
    anomalies?: AnomalyCreateNestedManyWithoutZoneInput
    realTimeMetrics?: RealTimeMetricCreateNestedManyWithoutZoneInput
    predictions?: PredictionCreateNestedManyWithoutZoneInput
  }

  export type ZoneUncheckedCreateWithoutBehaviorsInput = {
    id?: string
    name: string
    coordinates: JsonNullValueInput | InputJsonValue
    capacity: number
    floorPlanId: string
    nightclubId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    alerts?: AlertUncheckedCreateNestedManyWithoutZoneInput
    emergencies?: EmergencyUncheckedCreateNestedManyWithoutZoneInput
    sensors?: SensorUncheckedCreateNestedManyWithoutZoneInput
    anomalies?: AnomalyUncheckedCreateNestedManyWithoutZoneInput
    realTimeMetrics?: RealTimeMetricUncheckedCreateNestedManyWithoutZoneInput
    predictions?: PredictionUncheckedCreateNestedManyWithoutZoneInput
  }

  export type ZoneCreateOrConnectWithoutBehaviorsInput = {
    where: ZoneWhereUniqueInput
    create: XOR<ZoneCreateWithoutBehaviorsInput, ZoneUncheckedCreateWithoutBehaviorsInput>
  }

  export type AIModelCreateWithoutBehaviorAnalysesInput = {
    id?: string
    type: string
    name: string
    version: string
    status: string
    config: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    predictions?: PredictionCreateNestedManyWithoutModelInput
    anomalies?: AnomalyCreateNestedManyWithoutModelInput
  }

  export type AIModelUncheckedCreateWithoutBehaviorAnalysesInput = {
    id?: string
    type: string
    name: string
    version: string
    status: string
    config: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    predictions?: PredictionUncheckedCreateNestedManyWithoutModelInput
    anomalies?: AnomalyUncheckedCreateNestedManyWithoutModelInput
  }

  export type AIModelCreateOrConnectWithoutBehaviorAnalysesInput = {
    where: AIModelWhereUniqueInput
    create: XOR<AIModelCreateWithoutBehaviorAnalysesInput, AIModelUncheckedCreateWithoutBehaviorAnalysesInput>
  }

  export type NightclubUpsertWithoutBehaviorsInput = {
    update: XOR<NightclubUpdateWithoutBehaviorsInput, NightclubUncheckedUpdateWithoutBehaviorsInput>
    create: XOR<NightclubCreateWithoutBehaviorsInput, NightclubUncheckedCreateWithoutBehaviorsInput>
    where?: NightclubWhereInput
  }

  export type NightclubUpdateToOneWithWhereWithoutBehaviorsInput = {
    where?: NightclubWhereInput
    data: XOR<NightclubUpdateWithoutBehaviorsInput, NightclubUncheckedUpdateWithoutBehaviorsInput>
  }

  export type NightclubUpdateWithoutBehaviorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    floorPlans?: FloorPlanUpdateManyWithoutNightclubNestedInput
    users?: UserUpdateManyWithoutNightclubNestedInput
    bracelets?: BraceletUpdateManyWithoutNightclubNestedInput
    zones?: ZoneUpdateManyWithoutNightclubNestedInput
    emergencies?: EmergencyUpdateManyWithoutNightclubNestedInput
    analyticsReports?: AnalyticsReportUpdateManyWithoutNightclubNestedInput
    predictions?: PredictionUpdateManyWithoutNightclubNestedInput
    anomalies?: AnomalyUpdateManyWithoutNightclubNestedInput
    realTimeMetrics?: RealTimeMetricUpdateManyWithoutNightclubNestedInput
    dataStreams?: DataStreamUpdateManyWithoutNightclubNestedInput
    cacheEntries?: CacheEntryUpdateManyWithoutNightclubNestedInput
  }

  export type NightclubUncheckedUpdateWithoutBehaviorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    floorPlans?: FloorPlanUncheckedUpdateManyWithoutNightclubNestedInput
    users?: UserUncheckedUpdateManyWithoutNightclubNestedInput
    bracelets?: BraceletUncheckedUpdateManyWithoutNightclubNestedInput
    zones?: ZoneUncheckedUpdateManyWithoutNightclubNestedInput
    emergencies?: EmergencyUncheckedUpdateManyWithoutNightclubNestedInput
    analyticsReports?: AnalyticsReportUncheckedUpdateManyWithoutNightclubNestedInput
    predictions?: PredictionUncheckedUpdateManyWithoutNightclubNestedInput
    anomalies?: AnomalyUncheckedUpdateManyWithoutNightclubNestedInput
    realTimeMetrics?: RealTimeMetricUncheckedUpdateManyWithoutNightclubNestedInput
    dataStreams?: DataStreamUncheckedUpdateManyWithoutNightclubNestedInput
    cacheEntries?: CacheEntryUncheckedUpdateManyWithoutNightclubNestedInput
  }

  export type ZoneUpsertWithoutBehaviorsInput = {
    update: XOR<ZoneUpdateWithoutBehaviorsInput, ZoneUncheckedUpdateWithoutBehaviorsInput>
    create: XOR<ZoneCreateWithoutBehaviorsInput, ZoneUncheckedCreateWithoutBehaviorsInput>
    where?: ZoneWhereInput
  }

  export type ZoneUpdateToOneWithWhereWithoutBehaviorsInput = {
    where?: ZoneWhereInput
    data: XOR<ZoneUpdateWithoutBehaviorsInput, ZoneUncheckedUpdateWithoutBehaviorsInput>
  }

  export type ZoneUpdateWithoutBehaviorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    coordinates?: JsonNullValueInput | InputJsonValue
    capacity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    floorPlan?: FloorPlanUpdateOneRequiredWithoutZonesNestedInput
    nightclub?: NightclubUpdateOneRequiredWithoutZonesNestedInput
    alerts?: AlertUpdateManyWithoutZoneNestedInput
    emergencies?: EmergencyUpdateManyWithoutZoneNestedInput
    sensors?: SensorUpdateManyWithoutZoneNestedInput
    anomalies?: AnomalyUpdateManyWithoutZoneNestedInput
    realTimeMetrics?: RealTimeMetricUpdateManyWithoutZoneNestedInput
    predictions?: PredictionUpdateManyWithoutZoneNestedInput
  }

  export type ZoneUncheckedUpdateWithoutBehaviorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    coordinates?: JsonNullValueInput | InputJsonValue
    capacity?: IntFieldUpdateOperationsInput | number
    floorPlanId?: StringFieldUpdateOperationsInput | string
    nightclubId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    alerts?: AlertUncheckedUpdateManyWithoutZoneNestedInput
    emergencies?: EmergencyUncheckedUpdateManyWithoutZoneNestedInput
    sensors?: SensorUncheckedUpdateManyWithoutZoneNestedInput
    anomalies?: AnomalyUncheckedUpdateManyWithoutZoneNestedInput
    realTimeMetrics?: RealTimeMetricUncheckedUpdateManyWithoutZoneNestedInput
    predictions?: PredictionUncheckedUpdateManyWithoutZoneNestedInput
  }

  export type AIModelUpsertWithoutBehaviorAnalysesInput = {
    update: XOR<AIModelUpdateWithoutBehaviorAnalysesInput, AIModelUncheckedUpdateWithoutBehaviorAnalysesInput>
    create: XOR<AIModelCreateWithoutBehaviorAnalysesInput, AIModelUncheckedCreateWithoutBehaviorAnalysesInput>
    where?: AIModelWhereInput
  }

  export type AIModelUpdateToOneWithWhereWithoutBehaviorAnalysesInput = {
    where?: AIModelWhereInput
    data: XOR<AIModelUpdateWithoutBehaviorAnalysesInput, AIModelUncheckedUpdateWithoutBehaviorAnalysesInput>
  }

  export type AIModelUpdateWithoutBehaviorAnalysesInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    predictions?: PredictionUpdateManyWithoutModelNestedInput
    anomalies?: AnomalyUpdateManyWithoutModelNestedInput
  }

  export type AIModelUncheckedUpdateWithoutBehaviorAnalysesInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    version?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    predictions?: PredictionUncheckedUpdateManyWithoutModelNestedInput
    anomalies?: AnomalyUncheckedUpdateManyWithoutModelNestedInput
  }

  export type NightclubCreateWithoutRealTimeMetricsInput = {
    id?: string
    name: string
    address: string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    floorPlans?: FloorPlanCreateNestedManyWithoutNightclubInput
    users?: UserCreateNestedManyWithoutNightclubInput
    bracelets?: BraceletCreateNestedManyWithoutNightclubInput
    zones?: ZoneCreateNestedManyWithoutNightclubInput
    emergencies?: EmergencyCreateNestedManyWithoutNightclubInput
    analyticsReports?: AnalyticsReportCreateNestedManyWithoutNightclubInput
    predictions?: PredictionCreateNestedManyWithoutNightclubInput
    anomalies?: AnomalyCreateNestedManyWithoutNightclubInput
    behaviors?: BehaviorAnalysisCreateNestedManyWithoutNightclubInput
    dataStreams?: DataStreamCreateNestedManyWithoutNightclubInput
    cacheEntries?: CacheEntryCreateNestedManyWithoutNightclubInput
  }

  export type NightclubUncheckedCreateWithoutRealTimeMetricsInput = {
    id?: string
    name: string
    address: string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    floorPlans?: FloorPlanUncheckedCreateNestedManyWithoutNightclubInput
    users?: UserUncheckedCreateNestedManyWithoutNightclubInput
    bracelets?: BraceletUncheckedCreateNestedManyWithoutNightclubInput
    zones?: ZoneUncheckedCreateNestedManyWithoutNightclubInput
    emergencies?: EmergencyUncheckedCreateNestedManyWithoutNightclubInput
    analyticsReports?: AnalyticsReportUncheckedCreateNestedManyWithoutNightclubInput
    predictions?: PredictionUncheckedCreateNestedManyWithoutNightclubInput
    anomalies?: AnomalyUncheckedCreateNestedManyWithoutNightclubInput
    behaviors?: BehaviorAnalysisUncheckedCreateNestedManyWithoutNightclubInput
    dataStreams?: DataStreamUncheckedCreateNestedManyWithoutNightclubInput
    cacheEntries?: CacheEntryUncheckedCreateNestedManyWithoutNightclubInput
  }

  export type NightclubCreateOrConnectWithoutRealTimeMetricsInput = {
    where: NightclubWhereUniqueInput
    create: XOR<NightclubCreateWithoutRealTimeMetricsInput, NightclubUncheckedCreateWithoutRealTimeMetricsInput>
  }

  export type ZoneCreateWithoutRealTimeMetricsInput = {
    id?: string
    name: string
    coordinates: JsonNullValueInput | InputJsonValue
    capacity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    floorPlan: FloorPlanCreateNestedOneWithoutZonesInput
    nightclub: NightclubCreateNestedOneWithoutZonesInput
    alerts?: AlertCreateNestedManyWithoutZoneInput
    emergencies?: EmergencyCreateNestedManyWithoutZoneInput
    sensors?: SensorCreateNestedManyWithoutZoneInput
    anomalies?: AnomalyCreateNestedManyWithoutZoneInput
    behaviors?: BehaviorAnalysisCreateNestedManyWithoutZoneInput
    predictions?: PredictionCreateNestedManyWithoutZoneInput
  }

  export type ZoneUncheckedCreateWithoutRealTimeMetricsInput = {
    id?: string
    name: string
    coordinates: JsonNullValueInput | InputJsonValue
    capacity: number
    floorPlanId: string
    nightclubId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    alerts?: AlertUncheckedCreateNestedManyWithoutZoneInput
    emergencies?: EmergencyUncheckedCreateNestedManyWithoutZoneInput
    sensors?: SensorUncheckedCreateNestedManyWithoutZoneInput
    anomalies?: AnomalyUncheckedCreateNestedManyWithoutZoneInput
    behaviors?: BehaviorAnalysisUncheckedCreateNestedManyWithoutZoneInput
    predictions?: PredictionUncheckedCreateNestedManyWithoutZoneInput
  }

  export type ZoneCreateOrConnectWithoutRealTimeMetricsInput = {
    where: ZoneWhereUniqueInput
    create: XOR<ZoneCreateWithoutRealTimeMetricsInput, ZoneUncheckedCreateWithoutRealTimeMetricsInput>
  }

  export type NightclubUpsertWithoutRealTimeMetricsInput = {
    update: XOR<NightclubUpdateWithoutRealTimeMetricsInput, NightclubUncheckedUpdateWithoutRealTimeMetricsInput>
    create: XOR<NightclubCreateWithoutRealTimeMetricsInput, NightclubUncheckedCreateWithoutRealTimeMetricsInput>
    where?: NightclubWhereInput
  }

  export type NightclubUpdateToOneWithWhereWithoutRealTimeMetricsInput = {
    where?: NightclubWhereInput
    data: XOR<NightclubUpdateWithoutRealTimeMetricsInput, NightclubUncheckedUpdateWithoutRealTimeMetricsInput>
  }

  export type NightclubUpdateWithoutRealTimeMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    floorPlans?: FloorPlanUpdateManyWithoutNightclubNestedInput
    users?: UserUpdateManyWithoutNightclubNestedInput
    bracelets?: BraceletUpdateManyWithoutNightclubNestedInput
    zones?: ZoneUpdateManyWithoutNightclubNestedInput
    emergencies?: EmergencyUpdateManyWithoutNightclubNestedInput
    analyticsReports?: AnalyticsReportUpdateManyWithoutNightclubNestedInput
    predictions?: PredictionUpdateManyWithoutNightclubNestedInput
    anomalies?: AnomalyUpdateManyWithoutNightclubNestedInput
    behaviors?: BehaviorAnalysisUpdateManyWithoutNightclubNestedInput
    dataStreams?: DataStreamUpdateManyWithoutNightclubNestedInput
    cacheEntries?: CacheEntryUpdateManyWithoutNightclubNestedInput
  }

  export type NightclubUncheckedUpdateWithoutRealTimeMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    floorPlans?: FloorPlanUncheckedUpdateManyWithoutNightclubNestedInput
    users?: UserUncheckedUpdateManyWithoutNightclubNestedInput
    bracelets?: BraceletUncheckedUpdateManyWithoutNightclubNestedInput
    zones?: ZoneUncheckedUpdateManyWithoutNightclubNestedInput
    emergencies?: EmergencyUncheckedUpdateManyWithoutNightclubNestedInput
    analyticsReports?: AnalyticsReportUncheckedUpdateManyWithoutNightclubNestedInput
    predictions?: PredictionUncheckedUpdateManyWithoutNightclubNestedInput
    anomalies?: AnomalyUncheckedUpdateManyWithoutNightclubNestedInput
    behaviors?: BehaviorAnalysisUncheckedUpdateManyWithoutNightclubNestedInput
    dataStreams?: DataStreamUncheckedUpdateManyWithoutNightclubNestedInput
    cacheEntries?: CacheEntryUncheckedUpdateManyWithoutNightclubNestedInput
  }

  export type ZoneUpsertWithoutRealTimeMetricsInput = {
    update: XOR<ZoneUpdateWithoutRealTimeMetricsInput, ZoneUncheckedUpdateWithoutRealTimeMetricsInput>
    create: XOR<ZoneCreateWithoutRealTimeMetricsInput, ZoneUncheckedCreateWithoutRealTimeMetricsInput>
    where?: ZoneWhereInput
  }

  export type ZoneUpdateToOneWithWhereWithoutRealTimeMetricsInput = {
    where?: ZoneWhereInput
    data: XOR<ZoneUpdateWithoutRealTimeMetricsInput, ZoneUncheckedUpdateWithoutRealTimeMetricsInput>
  }

  export type ZoneUpdateWithoutRealTimeMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    coordinates?: JsonNullValueInput | InputJsonValue
    capacity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    floorPlan?: FloorPlanUpdateOneRequiredWithoutZonesNestedInput
    nightclub?: NightclubUpdateOneRequiredWithoutZonesNestedInput
    alerts?: AlertUpdateManyWithoutZoneNestedInput
    emergencies?: EmergencyUpdateManyWithoutZoneNestedInput
    sensors?: SensorUpdateManyWithoutZoneNestedInput
    anomalies?: AnomalyUpdateManyWithoutZoneNestedInput
    behaviors?: BehaviorAnalysisUpdateManyWithoutZoneNestedInput
    predictions?: PredictionUpdateManyWithoutZoneNestedInput
  }

  export type ZoneUncheckedUpdateWithoutRealTimeMetricsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    coordinates?: JsonNullValueInput | InputJsonValue
    capacity?: IntFieldUpdateOperationsInput | number
    floorPlanId?: StringFieldUpdateOperationsInput | string
    nightclubId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    alerts?: AlertUncheckedUpdateManyWithoutZoneNestedInput
    emergencies?: EmergencyUncheckedUpdateManyWithoutZoneNestedInput
    sensors?: SensorUncheckedUpdateManyWithoutZoneNestedInput
    anomalies?: AnomalyUncheckedUpdateManyWithoutZoneNestedInput
    behaviors?: BehaviorAnalysisUncheckedUpdateManyWithoutZoneNestedInput
    predictions?: PredictionUncheckedUpdateManyWithoutZoneNestedInput
  }

  export type NightclubCreateWithoutDataStreamsInput = {
    id?: string
    name: string
    address: string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    floorPlans?: FloorPlanCreateNestedManyWithoutNightclubInput
    users?: UserCreateNestedManyWithoutNightclubInput
    bracelets?: BraceletCreateNestedManyWithoutNightclubInput
    zones?: ZoneCreateNestedManyWithoutNightclubInput
    emergencies?: EmergencyCreateNestedManyWithoutNightclubInput
    analyticsReports?: AnalyticsReportCreateNestedManyWithoutNightclubInput
    predictions?: PredictionCreateNestedManyWithoutNightclubInput
    anomalies?: AnomalyCreateNestedManyWithoutNightclubInput
    behaviors?: BehaviorAnalysisCreateNestedManyWithoutNightclubInput
    realTimeMetrics?: RealTimeMetricCreateNestedManyWithoutNightclubInput
    cacheEntries?: CacheEntryCreateNestedManyWithoutNightclubInput
  }

  export type NightclubUncheckedCreateWithoutDataStreamsInput = {
    id?: string
    name: string
    address: string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    floorPlans?: FloorPlanUncheckedCreateNestedManyWithoutNightclubInput
    users?: UserUncheckedCreateNestedManyWithoutNightclubInput
    bracelets?: BraceletUncheckedCreateNestedManyWithoutNightclubInput
    zones?: ZoneUncheckedCreateNestedManyWithoutNightclubInput
    emergencies?: EmergencyUncheckedCreateNestedManyWithoutNightclubInput
    analyticsReports?: AnalyticsReportUncheckedCreateNestedManyWithoutNightclubInput
    predictions?: PredictionUncheckedCreateNestedManyWithoutNightclubInput
    anomalies?: AnomalyUncheckedCreateNestedManyWithoutNightclubInput
    behaviors?: BehaviorAnalysisUncheckedCreateNestedManyWithoutNightclubInput
    realTimeMetrics?: RealTimeMetricUncheckedCreateNestedManyWithoutNightclubInput
    cacheEntries?: CacheEntryUncheckedCreateNestedManyWithoutNightclubInput
  }

  export type NightclubCreateOrConnectWithoutDataStreamsInput = {
    where: NightclubWhereUniqueInput
    create: XOR<NightclubCreateWithoutDataStreamsInput, NightclubUncheckedCreateWithoutDataStreamsInput>
  }

  export type NightclubUpsertWithoutDataStreamsInput = {
    update: XOR<NightclubUpdateWithoutDataStreamsInput, NightclubUncheckedUpdateWithoutDataStreamsInput>
    create: XOR<NightclubCreateWithoutDataStreamsInput, NightclubUncheckedCreateWithoutDataStreamsInput>
    where?: NightclubWhereInput
  }

  export type NightclubUpdateToOneWithWhereWithoutDataStreamsInput = {
    where?: NightclubWhereInput
    data: XOR<NightclubUpdateWithoutDataStreamsInput, NightclubUncheckedUpdateWithoutDataStreamsInput>
  }

  export type NightclubUpdateWithoutDataStreamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    floorPlans?: FloorPlanUpdateManyWithoutNightclubNestedInput
    users?: UserUpdateManyWithoutNightclubNestedInput
    bracelets?: BraceletUpdateManyWithoutNightclubNestedInput
    zones?: ZoneUpdateManyWithoutNightclubNestedInput
    emergencies?: EmergencyUpdateManyWithoutNightclubNestedInput
    analyticsReports?: AnalyticsReportUpdateManyWithoutNightclubNestedInput
    predictions?: PredictionUpdateManyWithoutNightclubNestedInput
    anomalies?: AnomalyUpdateManyWithoutNightclubNestedInput
    behaviors?: BehaviorAnalysisUpdateManyWithoutNightclubNestedInput
    realTimeMetrics?: RealTimeMetricUpdateManyWithoutNightclubNestedInput
    cacheEntries?: CacheEntryUpdateManyWithoutNightclubNestedInput
  }

  export type NightclubUncheckedUpdateWithoutDataStreamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    floorPlans?: FloorPlanUncheckedUpdateManyWithoutNightclubNestedInput
    users?: UserUncheckedUpdateManyWithoutNightclubNestedInput
    bracelets?: BraceletUncheckedUpdateManyWithoutNightclubNestedInput
    zones?: ZoneUncheckedUpdateManyWithoutNightclubNestedInput
    emergencies?: EmergencyUncheckedUpdateManyWithoutNightclubNestedInput
    analyticsReports?: AnalyticsReportUncheckedUpdateManyWithoutNightclubNestedInput
    predictions?: PredictionUncheckedUpdateManyWithoutNightclubNestedInput
    anomalies?: AnomalyUncheckedUpdateManyWithoutNightclubNestedInput
    behaviors?: BehaviorAnalysisUncheckedUpdateManyWithoutNightclubNestedInput
    realTimeMetrics?: RealTimeMetricUncheckedUpdateManyWithoutNightclubNestedInput
    cacheEntries?: CacheEntryUncheckedUpdateManyWithoutNightclubNestedInput
  }

  export type NightclubCreateWithoutCacheEntriesInput = {
    id?: string
    name: string
    address: string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    floorPlans?: FloorPlanCreateNestedManyWithoutNightclubInput
    users?: UserCreateNestedManyWithoutNightclubInput
    bracelets?: BraceletCreateNestedManyWithoutNightclubInput
    zones?: ZoneCreateNestedManyWithoutNightclubInput
    emergencies?: EmergencyCreateNestedManyWithoutNightclubInput
    analyticsReports?: AnalyticsReportCreateNestedManyWithoutNightclubInput
    predictions?: PredictionCreateNestedManyWithoutNightclubInput
    anomalies?: AnomalyCreateNestedManyWithoutNightclubInput
    behaviors?: BehaviorAnalysisCreateNestedManyWithoutNightclubInput
    realTimeMetrics?: RealTimeMetricCreateNestedManyWithoutNightclubInput
    dataStreams?: DataStreamCreateNestedManyWithoutNightclubInput
  }

  export type NightclubUncheckedCreateWithoutCacheEntriesInput = {
    id?: string
    name: string
    address: string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    floorPlans?: FloorPlanUncheckedCreateNestedManyWithoutNightclubInput
    users?: UserUncheckedCreateNestedManyWithoutNightclubInput
    bracelets?: BraceletUncheckedCreateNestedManyWithoutNightclubInput
    zones?: ZoneUncheckedCreateNestedManyWithoutNightclubInput
    emergencies?: EmergencyUncheckedCreateNestedManyWithoutNightclubInput
    analyticsReports?: AnalyticsReportUncheckedCreateNestedManyWithoutNightclubInput
    predictions?: PredictionUncheckedCreateNestedManyWithoutNightclubInput
    anomalies?: AnomalyUncheckedCreateNestedManyWithoutNightclubInput
    behaviors?: BehaviorAnalysisUncheckedCreateNestedManyWithoutNightclubInput
    realTimeMetrics?: RealTimeMetricUncheckedCreateNestedManyWithoutNightclubInput
    dataStreams?: DataStreamUncheckedCreateNestedManyWithoutNightclubInput
  }

  export type NightclubCreateOrConnectWithoutCacheEntriesInput = {
    where: NightclubWhereUniqueInput
    create: XOR<NightclubCreateWithoutCacheEntriesInput, NightclubUncheckedCreateWithoutCacheEntriesInput>
  }

  export type NightclubUpsertWithoutCacheEntriesInput = {
    update: XOR<NightclubUpdateWithoutCacheEntriesInput, NightclubUncheckedUpdateWithoutCacheEntriesInput>
    create: XOR<NightclubCreateWithoutCacheEntriesInput, NightclubUncheckedCreateWithoutCacheEntriesInput>
    where?: NightclubWhereInput
  }

  export type NightclubUpdateToOneWithWhereWithoutCacheEntriesInput = {
    where?: NightclubWhereInput
    data: XOR<NightclubUpdateWithoutCacheEntriesInput, NightclubUncheckedUpdateWithoutCacheEntriesInput>
  }

  export type NightclubUpdateWithoutCacheEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    floorPlans?: FloorPlanUpdateManyWithoutNightclubNestedInput
    users?: UserUpdateManyWithoutNightclubNestedInput
    bracelets?: BraceletUpdateManyWithoutNightclubNestedInput
    zones?: ZoneUpdateManyWithoutNightclubNestedInput
    emergencies?: EmergencyUpdateManyWithoutNightclubNestedInput
    analyticsReports?: AnalyticsReportUpdateManyWithoutNightclubNestedInput
    predictions?: PredictionUpdateManyWithoutNightclubNestedInput
    anomalies?: AnomalyUpdateManyWithoutNightclubNestedInput
    behaviors?: BehaviorAnalysisUpdateManyWithoutNightclubNestedInput
    realTimeMetrics?: RealTimeMetricUpdateManyWithoutNightclubNestedInput
    dataStreams?: DataStreamUpdateManyWithoutNightclubNestedInput
  }

  export type NightclubUncheckedUpdateWithoutCacheEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    floorPlans?: FloorPlanUncheckedUpdateManyWithoutNightclubNestedInput
    users?: UserUncheckedUpdateManyWithoutNightclubNestedInput
    bracelets?: BraceletUncheckedUpdateManyWithoutNightclubNestedInput
    zones?: ZoneUncheckedUpdateManyWithoutNightclubNestedInput
    emergencies?: EmergencyUncheckedUpdateManyWithoutNightclubNestedInput
    analyticsReports?: AnalyticsReportUncheckedUpdateManyWithoutNightclubNestedInput
    predictions?: PredictionUncheckedUpdateManyWithoutNightclubNestedInput
    anomalies?: AnomalyUncheckedUpdateManyWithoutNightclubNestedInput
    behaviors?: BehaviorAnalysisUncheckedUpdateManyWithoutNightclubNestedInput
    realTimeMetrics?: RealTimeMetricUncheckedUpdateManyWithoutNightclubNestedInput
    dataStreams?: DataStreamUncheckedUpdateManyWithoutNightclubNestedInput
  }

  export type FloorPlanCreateManyNightclubInput = {
    id?: string
    name: string
    imageUrl: string
    createdAt?: Date | string
    updatedAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserCreateManyNightclubInput = {
    id?: string
    email: string
    password: string
    name: string
    role?: $Enums.UserRole
    status?: $Enums.UserStatus
    deviceId?: string | null
    resetToken?: string | null
    resetTokenExpiry?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lastLogin?: Date | string | null
    lastLocation?: NullableJsonNullValueInput | InputJsonValue
  }

  export type BraceletCreateManyNightclubInput = {
    id?: string
    deviceId: string
    batteryLevel?: number | null
    status?: $Enums.BraceletStatus
    lastSeen?: Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ZoneCreateManyNightclubInput = {
    id?: string
    name: string
    coordinates: JsonNullValueInput | InputJsonValue
    capacity: number
    floorPlanId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmergencyCreateManyNightclubInput = {
    id?: string
    status?: $Enums.EmergencyStatus
    braceletId: string
    zoneId: string
    responderId?: string | null
    responseTime?: number | null
    escalationDetails?: NullableJsonNullValueInput | InputJsonValue
    resolutionDetails?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    resolvedAt?: Date | string | null
  }

  export type AnalyticsReportCreateManyNightclubInput = {
    id?: string
    type: string
    report: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PredictionCreateManyNightclubInput = {
    id?: string
    type: string
    timestamp?: Date | string
    value: number
    confidence: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    zoneId?: string | null
    modelId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnomalyCreateManyNightclubInput = {
    id?: string
    type: string
    severity: string
    status: string
    description: string
    timestamp?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    zoneId?: string | null
    modelId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BehaviorAnalysisCreateManyNightclubInput = {
    id?: string
    type: string
    timestamp?: Date | string
    insights: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    zoneId?: string | null
    modelId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RealTimeMetricCreateManyNightclubInput = {
    id?: string
    type: string
    value: number
    timestamp?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    zoneId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DataStreamCreateManyNightclubInput = {
    id?: string
    type: string
    status: string
    lastUpdate?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CacheEntryCreateManyNightclubInput = {
    id?: string
    key: string
    value: JsonNullValueInput | InputJsonValue
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FloorPlanUpdateWithoutNightclubInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    zones?: ZoneUpdateManyWithoutFloorPlanNestedInput
  }

  export type FloorPlanUncheckedUpdateWithoutNightclubInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    zones?: ZoneUncheckedUpdateManyWithoutFloorPlanNestedInput
  }

  export type FloorPlanUncheckedUpdateManyWithoutNightclubInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    imageUrl?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserUpdateWithoutNightclubInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLocation?: NullableJsonNullValueInput | InputJsonValue
    alerts?: AlertUpdateManyWithoutUserNestedInput
    emergencies?: EmergencyUpdateManyWithoutResponderNestedInput
  }

  export type UserUncheckedUpdateWithoutNightclubInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLocation?: NullableJsonNullValueInput | InputJsonValue
    alerts?: AlertUncheckedUpdateManyWithoutUserNestedInput
    emergencies?: EmergencyUncheckedUpdateManyWithoutResponderNestedInput
  }

  export type UserUncheckedUpdateManyWithoutNightclubInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    resetToken?: NullableStringFieldUpdateOperationsInput | string | null
    resetTokenExpiry?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastLocation?: NullableJsonNullValueInput | InputJsonValue
  }

  export type BraceletUpdateWithoutNightclubInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    batteryLevel?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumBraceletStatusFieldUpdateOperationsInput | $Enums.BraceletStatus
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    alerts?: AlertUpdateManyWithoutBraceletNestedInput
    emergencies?: EmergencyUpdateManyWithoutBraceletNestedInput
  }

  export type BraceletUncheckedUpdateWithoutNightclubInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    batteryLevel?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumBraceletStatusFieldUpdateOperationsInput | $Enums.BraceletStatus
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    alerts?: AlertUncheckedUpdateManyWithoutBraceletNestedInput
    emergencies?: EmergencyUncheckedUpdateManyWithoutBraceletNestedInput
  }

  export type BraceletUncheckedUpdateManyWithoutNightclubInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceId?: StringFieldUpdateOperationsInput | string
    batteryLevel?: NullableIntFieldUpdateOperationsInput | number | null
    status?: EnumBraceletStatusFieldUpdateOperationsInput | $Enums.BraceletStatus
    lastSeen?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ZoneUpdateWithoutNightclubInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    coordinates?: JsonNullValueInput | InputJsonValue
    capacity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    floorPlan?: FloorPlanUpdateOneRequiredWithoutZonesNestedInput
    alerts?: AlertUpdateManyWithoutZoneNestedInput
    emergencies?: EmergencyUpdateManyWithoutZoneNestedInput
    sensors?: SensorUpdateManyWithoutZoneNestedInput
    anomalies?: AnomalyUpdateManyWithoutZoneNestedInput
    behaviors?: BehaviorAnalysisUpdateManyWithoutZoneNestedInput
    realTimeMetrics?: RealTimeMetricUpdateManyWithoutZoneNestedInput
    predictions?: PredictionUpdateManyWithoutZoneNestedInput
  }

  export type ZoneUncheckedUpdateWithoutNightclubInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    coordinates?: JsonNullValueInput | InputJsonValue
    capacity?: IntFieldUpdateOperationsInput | number
    floorPlanId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    alerts?: AlertUncheckedUpdateManyWithoutZoneNestedInput
    emergencies?: EmergencyUncheckedUpdateManyWithoutZoneNestedInput
    sensors?: SensorUncheckedUpdateManyWithoutZoneNestedInput
    anomalies?: AnomalyUncheckedUpdateManyWithoutZoneNestedInput
    behaviors?: BehaviorAnalysisUncheckedUpdateManyWithoutZoneNestedInput
    realTimeMetrics?: RealTimeMetricUncheckedUpdateManyWithoutZoneNestedInput
    predictions?: PredictionUncheckedUpdateManyWithoutZoneNestedInput
  }

  export type ZoneUncheckedUpdateManyWithoutNightclubInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    coordinates?: JsonNullValueInput | InputJsonValue
    capacity?: IntFieldUpdateOperationsInput | number
    floorPlanId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmergencyUpdateWithoutNightclubInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumEmergencyStatusFieldUpdateOperationsInput | $Enums.EmergencyStatus
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    escalationDetails?: NullableJsonNullValueInput | InputJsonValue
    resolutionDetails?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bracelet?: BraceletUpdateOneRequiredWithoutEmergenciesNestedInput
    zone?: ZoneUpdateOneRequiredWithoutEmergenciesNestedInput
    responder?: UserUpdateOneWithoutEmergenciesNestedInput
  }

  export type EmergencyUncheckedUpdateWithoutNightclubInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumEmergencyStatusFieldUpdateOperationsInput | $Enums.EmergencyStatus
    braceletId?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    responderId?: NullableStringFieldUpdateOperationsInput | string | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    escalationDetails?: NullableJsonNullValueInput | InputJsonValue
    resolutionDetails?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmergencyUncheckedUpdateManyWithoutNightclubInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumEmergencyStatusFieldUpdateOperationsInput | $Enums.EmergencyStatus
    braceletId?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    responderId?: NullableStringFieldUpdateOperationsInput | string | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    escalationDetails?: NullableJsonNullValueInput | InputJsonValue
    resolutionDetails?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AnalyticsReportUpdateWithoutNightclubInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    report?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsReportUncheckedUpdateWithoutNightclubInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    report?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnalyticsReportUncheckedUpdateManyWithoutNightclubInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    report?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PredictionUpdateWithoutNightclubInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: FloatFieldUpdateOperationsInput | number
    confidence?: FloatFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    zone?: ZoneUpdateOneWithoutPredictionsNestedInput
    model?: AIModelUpdateOneRequiredWithoutPredictionsNestedInput
  }

  export type PredictionUncheckedUpdateWithoutNightclubInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: FloatFieldUpdateOperationsInput | number
    confidence?: FloatFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    zoneId?: NullableStringFieldUpdateOperationsInput | string | null
    modelId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PredictionUncheckedUpdateManyWithoutNightclubInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: FloatFieldUpdateOperationsInput | number
    confidence?: FloatFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    zoneId?: NullableStringFieldUpdateOperationsInput | string | null
    modelId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnomalyUpdateWithoutNightclubInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    zone?: ZoneUpdateOneWithoutAnomaliesNestedInput
    model?: AIModelUpdateOneRequiredWithoutAnomaliesNestedInput
  }

  export type AnomalyUncheckedUpdateWithoutNightclubInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    zoneId?: NullableStringFieldUpdateOperationsInput | string | null
    modelId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnomalyUncheckedUpdateManyWithoutNightclubInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    zoneId?: NullableStringFieldUpdateOperationsInput | string | null
    modelId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BehaviorAnalysisUpdateWithoutNightclubInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    insights?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    zone?: ZoneUpdateOneWithoutBehaviorsNestedInput
    model?: AIModelUpdateOneRequiredWithoutBehaviorAnalysesNestedInput
  }

  export type BehaviorAnalysisUncheckedUpdateWithoutNightclubInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    insights?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    zoneId?: NullableStringFieldUpdateOperationsInput | string | null
    modelId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BehaviorAnalysisUncheckedUpdateManyWithoutNightclubInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    insights?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    zoneId?: NullableStringFieldUpdateOperationsInput | string | null
    modelId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RealTimeMetricUpdateWithoutNightclubInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    zone?: ZoneUpdateOneWithoutRealTimeMetricsNestedInput
  }

  export type RealTimeMetricUncheckedUpdateWithoutNightclubInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    zoneId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RealTimeMetricUncheckedUpdateManyWithoutNightclubInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    zoneId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DataStreamUpdateWithoutNightclubInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DataStreamUncheckedUpdateWithoutNightclubInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DataStreamUncheckedUpdateManyWithoutNightclubInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    lastUpdate?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CacheEntryUpdateWithoutNightclubInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CacheEntryUncheckedUpdateWithoutNightclubInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CacheEntryUncheckedUpdateManyWithoutNightclubInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlertCreateManyUserInput = {
    id?: string
    type: $Enums.AlertType
    status?: $Enums.AlertStatus
    braceletId: string
    zoneId: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    resolvedAt?: Date | string | null
  }

  export type EmergencyCreateManyResponderInput = {
    id?: string
    status?: $Enums.EmergencyStatus
    braceletId: string
    zoneId: string
    nightclubId: string
    responseTime?: number | null
    escalationDetails?: NullableJsonNullValueInput | InputJsonValue
    resolutionDetails?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    resolvedAt?: Date | string | null
  }

  export type AlertUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAlertTypeFieldUpdateOperationsInput | $Enums.AlertType
    status?: EnumAlertStatusFieldUpdateOperationsInput | $Enums.AlertStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bracelet?: BraceletUpdateOneRequiredWithoutAlertsNestedInput
    zone?: ZoneUpdateOneRequiredWithoutAlertsNestedInput
  }

  export type AlertUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAlertTypeFieldUpdateOperationsInput | $Enums.AlertType
    status?: EnumAlertStatusFieldUpdateOperationsInput | $Enums.AlertStatus
    braceletId?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AlertUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAlertTypeFieldUpdateOperationsInput | $Enums.AlertType
    status?: EnumAlertStatusFieldUpdateOperationsInput | $Enums.AlertStatus
    braceletId?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmergencyUpdateWithoutResponderInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumEmergencyStatusFieldUpdateOperationsInput | $Enums.EmergencyStatus
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    escalationDetails?: NullableJsonNullValueInput | InputJsonValue
    resolutionDetails?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bracelet?: BraceletUpdateOneRequiredWithoutEmergenciesNestedInput
    zone?: ZoneUpdateOneRequiredWithoutEmergenciesNestedInput
    nightclub?: NightclubUpdateOneRequiredWithoutEmergenciesNestedInput
  }

  export type EmergencyUncheckedUpdateWithoutResponderInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumEmergencyStatusFieldUpdateOperationsInput | $Enums.EmergencyStatus
    braceletId?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    nightclubId?: StringFieldUpdateOperationsInput | string
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    escalationDetails?: NullableJsonNullValueInput | InputJsonValue
    resolutionDetails?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmergencyUncheckedUpdateManyWithoutResponderInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumEmergencyStatusFieldUpdateOperationsInput | $Enums.EmergencyStatus
    braceletId?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    nightclubId?: StringFieldUpdateOperationsInput | string
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    escalationDetails?: NullableJsonNullValueInput | InputJsonValue
    resolutionDetails?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ZoneCreateManyFloorPlanInput = {
    id?: string
    name: string
    coordinates: JsonNullValueInput | InputJsonValue
    capacity: number
    nightclubId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ZoneUpdateWithoutFloorPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    coordinates?: JsonNullValueInput | InputJsonValue
    capacity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nightclub?: NightclubUpdateOneRequiredWithoutZonesNestedInput
    alerts?: AlertUpdateManyWithoutZoneNestedInput
    emergencies?: EmergencyUpdateManyWithoutZoneNestedInput
    sensors?: SensorUpdateManyWithoutZoneNestedInput
    anomalies?: AnomalyUpdateManyWithoutZoneNestedInput
    behaviors?: BehaviorAnalysisUpdateManyWithoutZoneNestedInput
    realTimeMetrics?: RealTimeMetricUpdateManyWithoutZoneNestedInput
    predictions?: PredictionUpdateManyWithoutZoneNestedInput
  }

  export type ZoneUncheckedUpdateWithoutFloorPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    coordinates?: JsonNullValueInput | InputJsonValue
    capacity?: IntFieldUpdateOperationsInput | number
    nightclubId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    alerts?: AlertUncheckedUpdateManyWithoutZoneNestedInput
    emergencies?: EmergencyUncheckedUpdateManyWithoutZoneNestedInput
    sensors?: SensorUncheckedUpdateManyWithoutZoneNestedInput
    anomalies?: AnomalyUncheckedUpdateManyWithoutZoneNestedInput
    behaviors?: BehaviorAnalysisUncheckedUpdateManyWithoutZoneNestedInput
    realTimeMetrics?: RealTimeMetricUncheckedUpdateManyWithoutZoneNestedInput
    predictions?: PredictionUncheckedUpdateManyWithoutZoneNestedInput
  }

  export type ZoneUncheckedUpdateManyWithoutFloorPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    coordinates?: JsonNullValueInput | InputJsonValue
    capacity?: IntFieldUpdateOperationsInput | number
    nightclubId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlertCreateManyZoneInput = {
    id?: string
    type: $Enums.AlertType
    status?: $Enums.AlertStatus
    braceletId: string
    userId: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    resolvedAt?: Date | string | null
  }

  export type EmergencyCreateManyZoneInput = {
    id?: string
    status?: $Enums.EmergencyStatus
    braceletId: string
    nightclubId: string
    responderId?: string | null
    responseTime?: number | null
    escalationDetails?: NullableJsonNullValueInput | InputJsonValue
    resolutionDetails?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    resolvedAt?: Date | string | null
  }

  export type SensorCreateManyZoneInput = {
    id?: string
    type: $Enums.SensorType
    status?: $Enums.SensorStatus
    data?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    lastReading?: Date | string | null
  }

  export type AnomalyCreateManyZoneInput = {
    id?: string
    type: string
    severity: string
    status: string
    description: string
    timestamp?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    nightclubId: string
    modelId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BehaviorAnalysisCreateManyZoneInput = {
    id?: string
    type: string
    timestamp?: Date | string
    insights: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    nightclubId: string
    modelId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RealTimeMetricCreateManyZoneInput = {
    id?: string
    type: string
    value: number
    timestamp?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    nightclubId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PredictionCreateManyZoneInput = {
    id?: string
    type: string
    timestamp?: Date | string
    value: number
    confidence: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    nightclubId: string
    modelId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AlertUpdateWithoutZoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAlertTypeFieldUpdateOperationsInput | $Enums.AlertType
    status?: EnumAlertStatusFieldUpdateOperationsInput | $Enums.AlertStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bracelet?: BraceletUpdateOneRequiredWithoutAlertsNestedInput
    user?: UserUpdateOneRequiredWithoutAlertsNestedInput
  }

  export type AlertUncheckedUpdateWithoutZoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAlertTypeFieldUpdateOperationsInput | $Enums.AlertType
    status?: EnumAlertStatusFieldUpdateOperationsInput | $Enums.AlertStatus
    braceletId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AlertUncheckedUpdateManyWithoutZoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAlertTypeFieldUpdateOperationsInput | $Enums.AlertType
    status?: EnumAlertStatusFieldUpdateOperationsInput | $Enums.AlertStatus
    braceletId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmergencyUpdateWithoutZoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumEmergencyStatusFieldUpdateOperationsInput | $Enums.EmergencyStatus
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    escalationDetails?: NullableJsonNullValueInput | InputJsonValue
    resolutionDetails?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bracelet?: BraceletUpdateOneRequiredWithoutEmergenciesNestedInput
    nightclub?: NightclubUpdateOneRequiredWithoutEmergenciesNestedInput
    responder?: UserUpdateOneWithoutEmergenciesNestedInput
  }

  export type EmergencyUncheckedUpdateWithoutZoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumEmergencyStatusFieldUpdateOperationsInput | $Enums.EmergencyStatus
    braceletId?: StringFieldUpdateOperationsInput | string
    nightclubId?: StringFieldUpdateOperationsInput | string
    responderId?: NullableStringFieldUpdateOperationsInput | string | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    escalationDetails?: NullableJsonNullValueInput | InputJsonValue
    resolutionDetails?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmergencyUncheckedUpdateManyWithoutZoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumEmergencyStatusFieldUpdateOperationsInput | $Enums.EmergencyStatus
    braceletId?: StringFieldUpdateOperationsInput | string
    nightclubId?: StringFieldUpdateOperationsInput | string
    responderId?: NullableStringFieldUpdateOperationsInput | string | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    escalationDetails?: NullableJsonNullValueInput | InputJsonValue
    resolutionDetails?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SensorUpdateWithoutZoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumSensorTypeFieldUpdateOperationsInput | $Enums.SensorType
    status?: EnumSensorStatusFieldUpdateOperationsInput | $Enums.SensorStatus
    data?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastReading?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SensorUncheckedUpdateWithoutZoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumSensorTypeFieldUpdateOperationsInput | $Enums.SensorType
    status?: EnumSensorStatusFieldUpdateOperationsInput | $Enums.SensorStatus
    data?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastReading?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SensorUncheckedUpdateManyWithoutZoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumSensorTypeFieldUpdateOperationsInput | $Enums.SensorType
    status?: EnumSensorStatusFieldUpdateOperationsInput | $Enums.SensorStatus
    data?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastReading?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AnomalyUpdateWithoutZoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nightclub?: NightclubUpdateOneRequiredWithoutAnomaliesNestedInput
    model?: AIModelUpdateOneRequiredWithoutAnomaliesNestedInput
  }

  export type AnomalyUncheckedUpdateWithoutZoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    nightclubId?: StringFieldUpdateOperationsInput | string
    modelId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnomalyUncheckedUpdateManyWithoutZoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    nightclubId?: StringFieldUpdateOperationsInput | string
    modelId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BehaviorAnalysisUpdateWithoutZoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    insights?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nightclub?: NightclubUpdateOneRequiredWithoutBehaviorsNestedInput
    model?: AIModelUpdateOneRequiredWithoutBehaviorAnalysesNestedInput
  }

  export type BehaviorAnalysisUncheckedUpdateWithoutZoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    insights?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    nightclubId?: StringFieldUpdateOperationsInput | string
    modelId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BehaviorAnalysisUncheckedUpdateManyWithoutZoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    insights?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    nightclubId?: StringFieldUpdateOperationsInput | string
    modelId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RealTimeMetricUpdateWithoutZoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nightclub?: NightclubUpdateOneRequiredWithoutRealTimeMetricsNestedInput
  }

  export type RealTimeMetricUncheckedUpdateWithoutZoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    nightclubId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RealTimeMetricUncheckedUpdateManyWithoutZoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    value?: FloatFieldUpdateOperationsInput | number
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    nightclubId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PredictionUpdateWithoutZoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: FloatFieldUpdateOperationsInput | number
    confidence?: FloatFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nightclub?: NightclubUpdateOneRequiredWithoutPredictionsNestedInput
    model?: AIModelUpdateOneRequiredWithoutPredictionsNestedInput
  }

  export type PredictionUncheckedUpdateWithoutZoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: FloatFieldUpdateOperationsInput | number
    confidence?: FloatFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    nightclubId?: StringFieldUpdateOperationsInput | string
    modelId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PredictionUncheckedUpdateManyWithoutZoneInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: FloatFieldUpdateOperationsInput | number
    confidence?: FloatFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    nightclubId?: StringFieldUpdateOperationsInput | string
    modelId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AlertCreateManyBraceletInput = {
    id?: string
    type: $Enums.AlertType
    status?: $Enums.AlertStatus
    userId: string
    zoneId: string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    resolvedAt?: Date | string | null
  }

  export type EmergencyCreateManyBraceletInput = {
    id?: string
    status?: $Enums.EmergencyStatus
    zoneId: string
    nightclubId: string
    responderId?: string | null
    responseTime?: number | null
    escalationDetails?: NullableJsonNullValueInput | InputJsonValue
    resolutionDetails?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    resolvedAt?: Date | string | null
  }

  export type AlertUpdateWithoutBraceletInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAlertTypeFieldUpdateOperationsInput | $Enums.AlertType
    status?: EnumAlertStatusFieldUpdateOperationsInput | $Enums.AlertStatus
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutAlertsNestedInput
    zone?: ZoneUpdateOneRequiredWithoutAlertsNestedInput
  }

  export type AlertUncheckedUpdateWithoutBraceletInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAlertTypeFieldUpdateOperationsInput | $Enums.AlertType
    status?: EnumAlertStatusFieldUpdateOperationsInput | $Enums.AlertStatus
    userId?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AlertUncheckedUpdateManyWithoutBraceletInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAlertTypeFieldUpdateOperationsInput | $Enums.AlertType
    status?: EnumAlertStatusFieldUpdateOperationsInput | $Enums.AlertStatus
    userId?: StringFieldUpdateOperationsInput | string
    zoneId?: StringFieldUpdateOperationsInput | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmergencyUpdateWithoutBraceletInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumEmergencyStatusFieldUpdateOperationsInput | $Enums.EmergencyStatus
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    escalationDetails?: NullableJsonNullValueInput | InputJsonValue
    resolutionDetails?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    zone?: ZoneUpdateOneRequiredWithoutEmergenciesNestedInput
    nightclub?: NightclubUpdateOneRequiredWithoutEmergenciesNestedInput
    responder?: UserUpdateOneWithoutEmergenciesNestedInput
  }

  export type EmergencyUncheckedUpdateWithoutBraceletInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumEmergencyStatusFieldUpdateOperationsInput | $Enums.EmergencyStatus
    zoneId?: StringFieldUpdateOperationsInput | string
    nightclubId?: StringFieldUpdateOperationsInput | string
    responderId?: NullableStringFieldUpdateOperationsInput | string | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    escalationDetails?: NullableJsonNullValueInput | InputJsonValue
    resolutionDetails?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmergencyUncheckedUpdateManyWithoutBraceletInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumEmergencyStatusFieldUpdateOperationsInput | $Enums.EmergencyStatus
    zoneId?: StringFieldUpdateOperationsInput | string
    nightclubId?: StringFieldUpdateOperationsInput | string
    responderId?: NullableStringFieldUpdateOperationsInput | string | null
    responseTime?: NullableIntFieldUpdateOperationsInput | number | null
    escalationDetails?: NullableJsonNullValueInput | InputJsonValue
    resolutionDetails?: NullableJsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PredictionCreateManyModelInput = {
    id?: string
    type: string
    timestamp?: Date | string
    value: number
    confidence: number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    nightclubId: string
    zoneId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AnomalyCreateManyModelInput = {
    id?: string
    type: string
    severity: string
    status: string
    description: string
    timestamp?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    nightclubId: string
    zoneId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BehaviorAnalysisCreateManyModelInput = {
    id?: string
    type: string
    timestamp?: Date | string
    insights: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    nightclubId: string
    zoneId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PredictionUpdateWithoutModelInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: FloatFieldUpdateOperationsInput | number
    confidence?: FloatFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nightclub?: NightclubUpdateOneRequiredWithoutPredictionsNestedInput
    zone?: ZoneUpdateOneWithoutPredictionsNestedInput
  }

  export type PredictionUncheckedUpdateWithoutModelInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: FloatFieldUpdateOperationsInput | number
    confidence?: FloatFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    nightclubId?: StringFieldUpdateOperationsInput | string
    zoneId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PredictionUncheckedUpdateManyWithoutModelInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    value?: FloatFieldUpdateOperationsInput | number
    confidence?: FloatFieldUpdateOperationsInput | number
    metadata?: NullableJsonNullValueInput | InputJsonValue
    nightclubId?: StringFieldUpdateOperationsInput | string
    zoneId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnomalyUpdateWithoutModelInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nightclub?: NightclubUpdateOneRequiredWithoutAnomaliesNestedInput
    zone?: ZoneUpdateOneWithoutAnomaliesNestedInput
  }

  export type AnomalyUncheckedUpdateWithoutModelInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    nightclubId?: StringFieldUpdateOperationsInput | string
    zoneId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AnomalyUncheckedUpdateManyWithoutModelInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    nightclubId?: StringFieldUpdateOperationsInput | string
    zoneId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BehaviorAnalysisUpdateWithoutModelInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    insights?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    nightclub?: NightclubUpdateOneRequiredWithoutBehaviorsNestedInput
    zone?: ZoneUpdateOneWithoutBehaviorsNestedInput
  }

  export type BehaviorAnalysisUncheckedUpdateWithoutModelInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    insights?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    nightclubId?: StringFieldUpdateOperationsInput | string
    zoneId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BehaviorAnalysisUncheckedUpdateManyWithoutModelInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    insights?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    nightclubId?: StringFieldUpdateOperationsInput | string
    zoneId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use NightclubCountOutputTypeDefaultArgs instead
     */
    export type NightclubCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NightclubCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FloorPlanCountOutputTypeDefaultArgs instead
     */
    export type FloorPlanCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FloorPlanCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ZoneCountOutputTypeDefaultArgs instead
     */
    export type ZoneCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ZoneCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BraceletCountOutputTypeDefaultArgs instead
     */
    export type BraceletCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BraceletCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AIModelCountOutputTypeDefaultArgs instead
     */
    export type AIModelCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AIModelCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NightclubDefaultArgs instead
     */
    export type NightclubArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NightclubDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FloorPlanDefaultArgs instead
     */
    export type FloorPlanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FloorPlanDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ZoneDefaultArgs instead
     */
    export type ZoneArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ZoneDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BraceletDefaultArgs instead
     */
    export type BraceletArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BraceletDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AlertDefaultArgs instead
     */
    export type AlertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AlertDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmergencyDefaultArgs instead
     */
    export type EmergencyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmergencyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SensorDefaultArgs instead
     */
    export type SensorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SensorDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AuditLogDefaultArgs instead
     */
    export type AuditLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AuditLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AnalyticsReportDefaultArgs instead
     */
    export type AnalyticsReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AnalyticsReportDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AIModelDefaultArgs instead
     */
    export type AIModelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AIModelDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PredictionDefaultArgs instead
     */
    export type PredictionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PredictionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AnomalyDefaultArgs instead
     */
    export type AnomalyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AnomalyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BehaviorAnalysisDefaultArgs instead
     */
    export type BehaviorAnalysisArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BehaviorAnalysisDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RealTimeMetricDefaultArgs instead
     */
    export type RealTimeMetricArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RealTimeMetricDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DataStreamDefaultArgs instead
     */
    export type DataStreamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DataStreamDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CacheEntryDefaultArgs instead
     */
    export type CacheEntryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CacheEntryDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}